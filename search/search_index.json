{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"synth-pdb","text":"<p>Generate realistic PDB files with mixed secondary structures for bioinformatics testing, education, and tool development.</p> <p>\u26a0\ufe0f Important: The generated structures use idealized geometries and may contain violations of standard structural constraints. These files are intended for testing computational tools and educational demonstrations, not for simulation or experimental validation.</p>"},{"location":"#why-synth-pdb","title":"Why synth-pdb?","text":"<p>In the fields of structural biology and bioinformatics, researchers frequently require datasets of protein structures to test algorithms, train machine learning models, or validatate analytical pipelines. While the Protein Data Bank (PDB) contains over 200,000 experimental structures, relying solely on experimental data has limitations:</p> <ol> <li>Bias: PDB data is biased toward crystallizable or stable proteins.</li> <li>Complexity: Experimental files often contain artifacts, missing atoms, or non-standard residues that complicate initial testing.</li> <li>Lack of Ground Truth: When developing algorithms for NMR assignment or structure calculation, \"perfect\" synthetic data is essential for unit testing.</li> </ol> <p><code>synth-pdb</code> fills this gap by providing a lightweight, deterministic generator that produces chemically valid, full-atom PDB files with user-defined secondary structures (helices, sheets) in seconds.</p>"},{"location":"#educational-philosophy-code-as-textbook","title":"Educational Philosophy: Code as Textbook \ud83c\udf93","text":"<p><code>synth-pdb</code> is built on the core principle that scientific software should be readable and educational.</p> <ul> <li>Code as Textbook: We reject \"black box\" algorithms. Our source code (e.g., <code>generator.py</code>, <code>physics.py</code>) is heavily annotated with the biophysical reasons behind the implementation\u2014explaining concepts like Boltzmann weighting, order parameters (\\(S^2\\)), and NOE distance dependence (\\(r^{-6}\\)).</li> <li>Visual Learning: With the new <code>--visualize</code> flag, students can instantly see how abstract concepts (like steric clashes or helical packing) manifest in 3D, bridging the gap between equations and biology.</li> <li>Integrity: We employ specific tests to ensure these educational notes remain in the codebase, preventing refactoring from stripping away the scientific context.</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<p>\u2728 Structure Generation - Full atomic representation with backbone and side-chain heavy atoms + hydrogens - Customizable sequence (1-letter or 3-letter amino acid codes) - Conformational diversity: Generate alpha helices, beta sheets, extended chains, or random conformations - Rotamer-based side-chain placement for all 20 standard amino acids (Dunbrack library)</p> <p>\ud83d\udd2c Validation Suite - Bond length &amp; angle validation - Ramachandran angle checking - Steric clash detection &amp; refinement - Sequence improbability detection</p> <p>\u2699\ufe0f Quality Control - <code>--best-of-N</code>: Generate multiple structures and select the one with fewest violations - <code>--minimize</code>: Relax structures using OpenMM (Implicit Solvent / AMBER forcefield)</p>"},{"location":"#quick-visual-demo","title":"Quick Visual Demo","text":"<p>Want to see the Physics + Visualization capabilities in action?</p> <p>Run this command to generate a Leucine Zipper (classic alpha helix), minimize its energy using OpenMM, and immediately visualize it in your browser:</p> <pre><code>synth-pdb --sequence \"LKELEKELEKELEKELEKELEKEL\" --conformation alpha --minimize --visualize\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use <code>synth-pdb</code> in your research, please cite it using the metadata in the <code>CITATION.cff</code> file in the repository.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository:     <pre><code>git clone https://github.com/elkins/synth-pdb.git\n</code></pre></li> <li>Install in editable mode with dev dependencies:     <pre><code>pip install -e \".[dev]\"\n</code></pre></li> <li>Run tests:     <pre><code>pytest\n</code></pre></li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use <code>black</code> and <code>ruff</code> for linting.</p> <pre><code>ruff check .\nblack .\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<p>Install the latest stable release from PyPI:</p> <pre><code>pip install synth-pdb\n</code></pre> <p>This installs the <code>synth-pdb</code> package and makes the <code>synth-pdb</code> command available system-wide.</p>"},{"location":"installation/#from-bioconda","title":"From Bioconda","text":"<p>Bioinformatics users can install via Conda:</p> <pre><code>conda install -c bioconda synth-pdb\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<p>Install directly from the project directory for development:</p> <pre><code>git clone https://github.com/elkins/synth-pdb.git\ncd synth-pdb\npip install .\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>NumPy</li> <li>Biotite</li> <li>OpenMM (optional, for energy minimization)</li> <li>3Dmol.js (optional, for visualization)</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2026 George Elkins</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"nmr/","title":"For NMR Spectroscopists","text":""},{"location":"nmr/#note-for-spectroscopists","title":"Note for Spectroscopists","text":"<p>If you are coming from an NMR background (XPLOR-NIH, CYANA, CNS):</p> <ul> <li>Structure Calculation vs. Generation: <code>synth-pdb</code> mimics the final stage of an NMR structure calculation: Geometry Regularization (minimization in implicit solvent).</li> <li>Proton Detection: Unlike X-ray, NMR relies on 1H spins. That's why we explicitly add hydrogens before minimization.</li> </ul>"},{"location":"nmr/#synthetic-nmr-data","title":"Synthetic NMR Data","text":""},{"location":"nmr/#noe-restraints-gen-nef","title":"NOE Restraints (<code>--gen-nef</code>)","text":"<p>Generates distance restraints based on geometric proximity. - Criteria: H-H distance &lt; cutoff (default 5.0 \u00c5) - Format: NMR Exchange Format (NEF)</p>"},{"location":"nmr/#chemical-shifts-gen-shifts","title":"Chemical Shifts (<code>--gen-shifts</code>)","text":"<p>Generates predicted chemical shifts (\\(\\delta\\)) using SPARTA-lite: - Helix: \\(C_\\alpha\\) +3.1 ppm - Sheet: \\(C_\\alpha\\) -1.5 ppm</p>"},{"location":"nmr/#relaxation-data-gen-relax","title":"Relaxation Data (<code>--gen-relax</code>)","text":"<p>Simulates \\(R_1\\), \\(R_2\\), and NOE based on Model-Free formalism. - Order Parameter (\\(S^2\\)): Derived from local flexibility. - Tumbling Time (\\(\\tau_c\\)): Configurable via <code>--tumbling-time</code>.</p>"},{"location":"physics/","title":"Biophysics 101","text":""},{"location":"physics/#understanding-energy-minimization","title":"Understanding Energy Minimization","text":"<p>Energy Minimization is the process of moving atoms \"downhill\" to find the nearest stable shape.</p> <pre><code>      High Energy\n      (Unstable)\n          |\n         / \\       Forces push atoms \"downhill\"\n        /   \\     (Gradient Descent)\n       /     \\\n      /       \\___\n     /            \\\n    /              \\__ Low Energy\n   /                  (Stable / Minimized)\n</code></pre> <p><code>synth-pdb</code> uses Implicit Solvent (OBC2) to simulate the effect of water without the computational cost of thousands of explicit water molecules.</p>"},{"location":"physics/#the-generation-pipeline","title":"The Generation Pipeline","text":"<pre><code>[User] -&gt; [Generator] -&gt; [Geometry Builder] -&gt; [Sidechain Packer] -&gt; [Energy Minimizer] -&gt; [PDB File]\n             ^                  |                    |                      |\n             |              (N-CA-C-O)           (Rotamers)             (OpenMM)\n             |                                       |                      |\n             +---------------------------------------+----------------------+\n</code></pre>"},{"location":"technical_notes/","title":"Technical Implementation Notes","text":"<p>This document captures key engineering decisions and \"gotchas\" encountered during the development of <code>synth-pdb</code>.</p>"},{"location":"technical_notes/#physics-engine-openmm","title":"Physics Engine (OpenMM)","text":""},{"location":"technical_notes/#implicit-solvent-configuration","title":"Implicit Solvent Configuration","text":"<p>When using OpenMM's <code>app.OBC2</code> (Onufriev-Bashford-Case) implicit solvent model with the Amber14 forcefield, the standard <code>amber14-all.xml</code> file is not sufficient.</p> <p>The Issue: Attempting to create a system with <code>implicitSolvent=app.OBC2</code> without loading the specific solvent parameters results in a <code>ValueError</code> or a silent fallback to Vacuum electrostatics (if error handling isn't strict).</p> <p>The Solution: You must explicitly load the implicit solvent XML file alongside the main forcefield.</p> <pre><code># Correct initialization for Implicit Solvent\nforcefield = app.ForceField(\n    'amber14-all.xml',      # Main atom types\n    'amber14/tip3pfb.xml',  # Water model (required reference)\n    'implicit/obc2.xml'     # &lt;--- CRITICAL: Defines OBC2 parameters\n)\n\nsystem = forcefield.createSystem(\n    topology,\n    implicitSolvent=app.OBC2, \n    nonbondedMethod=app.NoCutoff # Implicit/Vacuum requires NoCutoff\n)\n</code></pre>"},{"location":"technical_notes/#visualization-3dmoljs","title":"Visualization (3Dmol.js)","text":""},{"location":"technical_notes/#nmr-restraints-hydrogens","title":"NMR Restraints &amp; Hydrogens","text":"<p>Standard PDB visualization often strips hydrogen atoms to improve rendering performance. However, NMR NOE restraints are defined between protons.</p> <p>The Issue: If you load a model into <code>3Dmol.js</code> with default settings, it may remove hydrogens. Consequently, attempts to draw cylinders between protons (e.g., <code>HA</code> to <code>HB</code>) fail because the target atoms simply \"don't exist\" in the viewer's object model.</p> <p>The Solution: You must enable the <code>keepH</code> flag when adding the model.</p> <pre><code>viewer.addModel(pdbData, \"pdb\", {keepH: true}); // &lt;--- Essential for NMR\n</code></pre>"},{"location":"technical_notes/#fuzzy-atom-selection","title":"Fuzzy Atom Selection","text":"<p>Discrepancies between generated PDB chain IDs (often defaults to 'A') and restraint lists (which might imply 'A' or be empty) are common.</p> <p>The Strategy: To ensure restraints are drawn even if metadata is slightly mismatched: 1.  Strict Match: Try selecting atom by <code>Chain + Residue + Name</code>. 2.  Fallback: If strict match returns 0 atoms, retry with <code>Residue + Name</code> (ignoring chain). 3.  Debug: If both fail, log a detailed error listing available atoms in that residue.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#command-line-arguments","title":"Command-Line Arguments","text":""},{"location":"usage/#structure-definition","title":"Structure Definition","text":"<ul> <li><code>--length &lt;LENGTH&gt;</code>: Number of residues (Default: 10)</li> <li><code>--sequence &lt;SEQUENCE&gt;</code>: Specify sequence (e.g. \"ACDEF\")</li> <li><code>--conformation &lt;TYPE&gt;</code>: <code>alpha</code>, <code>beta</code>, <code>ppii</code>, <code>extended</code>, <code>random</code></li> <li><code>--structure &lt;REGIONS&gt;</code>: Define mixed structure (e.g. <code>1-10:alpha,11-20:beta</code>)</li> </ul>"},{"location":"usage/#physics-refinement","title":"Physics &amp; Refinement","text":"<ul> <li><code>--minimize</code>: Run OpenMM energy minimization (Implicit Solvent)</li> <li><code>--optimize</code>: Run Monte Carlo side-chain packing</li> <li><code>--refine-clashes &lt;N&gt;</code>: Iteratively adjust atoms to reduce clashes</li> </ul>"},{"location":"usage/#nmr-data-generation","title":"NMR Data Generation","text":"<ul> <li><code>--gen-nef</code>: Generate NOE restraints (NEF format)</li> <li><code>--gen-shifts</code>: Predict chemical shifts (SPARTA-lite)</li> <li><code>--gen-relax</code>: Generate relaxation data (\\(R_1, R_2, NOE\\))</li> </ul>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#basic-peptides","title":"Basic Peptides","text":"<pre><code># Alpha helix\nsynth-pdb --length 20 --conformation alpha --output helix.pdb\n\n# Beta sheet\nsynth-pdb --length 20 --conformation beta --output sheet.pdb\n</code></pre>"},{"location":"usage/#complex-topologies","title":"Complex Topologies","text":"<pre><code># Helix-Turn-Helix\nsynth-pdb --structure \"1-10:alpha,11-15:random,16-25:alpha\" --minimize\n</code></pre>"},{"location":"visualization/","title":"Interactive Visualization","text":"<p><code>synth-pdb</code> includes a powerful built-in 3D viewer powered by 3Dmol.js. This allows you to instantly visualize your generated structures, energy minimization results, and NMR restraints directly in your web browser.</p>"},{"location":"visualization/#the-visualize-flag","title":"The <code>--visualize</code> Flag","text":"<p>Simply add <code>--visualize</code> to any generation command to launch the viewer.</p> <pre><code>synth-pdb --sequence \"LKELEKELEKELEKELEKELEKEL\" --conformation alpha --visualize\n</code></pre> <p>This will: 1.  Generate the PDB file. 2.  Create a temporary HTML page. 3.  Open it in your default web browser.</p>"},{"location":"visualization/#viewer-controls","title":"Viewer Controls","text":"<p>The viewer is fully interactive:</p> <ul> <li>Rotate: Left-click and drag.</li> <li>Zoom: Scroll wheel (or pinch zoom).</li> <li>Pan: Right-click (or Ctrl+Left-click) and drag.</li> </ul>"},{"location":"visualization/#feature-toggles","title":"Feature Toggles","text":"<ul> <li>\ud83d\udc7b Ghost Mode: Makes the protein transparent (0.4 opacity). Useful for seeing internal details like NOE restraints inside a Space-Filling (Sphere) model.</li> <li>\ud83d\udd34 Restraints: Toggles the visibility of NOE cylinders on/off to declutter the view.</li> </ul>"},{"location":"visualization/#features","title":"Features","text":""},{"location":"visualization/#visualization-styles","title":"Visualization Styles","text":"<p>Use the dropdown menu to change the representation: *   Cartoon: (Default) Shows the secondary structure (helices as ribbons, sheets as arrows). Best for seeing the overall fold. *   Stick: Shows all bonds as sticks. Best for seeing chemical details and side-chain packing. *   Sphere: Space-filling model (Van der Waals radii). Best for seeing packing density and surface. *   Line: Wireframe. Lightweight, good for seeing through the structure.</p>"},{"location":"visualization/#color-schemes","title":"Color Schemes","text":"<ul> <li>Spectrum: (Default) Rainbow gradient from Blue (N-terminus) to Red (C-terminus).</li> <li>Chain: Colors by chain ID (all 'A' for synth-pdb).</li> <li>Element: Standard CPK coloring (Carbon=Green/Grey, Oxygen=Red, Nitrogen=Blue, Sulfur=Yellow).</li> <li>SS: Secondary Structure (Helices=Magenta, Sheets=Yellow, Loops=White).</li> </ul>"},{"location":"visualization/#nmr-restraints-noes","title":"NMR Restraints (NOEs)","text":"<p>If you generate NEF restraints using <code>--gen-nef</code>, they will validly appear as translucent red cylinders connecting the protons.</p> <pre><code># Generate structure, Minimize, Create NEF restraints, and Visualize\nsynth-pdb --length 20 --minimize --gen-nef --visualize\n</code></pre> <ul> <li>Cylinders: Represent the NOE distance restraint.</li> <li>Visualization: Allows you to verify that the restraints match the geometry (i.e., the connected atoms are indeed close).</li> </ul>"},{"location":"visualization/#visual-learning-examples","title":"Visual Learning Examples","text":"<p>Here are curated examples designed to demonstrate specific structural biology concepts visually.</p>"},{"location":"visualization/#1-the-alpha-helix-leucine-zipper","title":"1. The Alpha Helix (Leucine Zipper)","text":"<p>Observe the tight packing and the protruding side chains. <pre><code>synth-pdb --sequence \"LKELEKELEKELEKELEKELEKEL\" --conformation alpha --visualize\n</code></pre></p>"},{"location":"visualization/#2-the-beta-hairpin","title":"2. The Beta Hairpin","text":"<p>See two antiparallel beta strands connected by a turn. Note the hydrogen bonds (implied) between the strands. <pre><code>synth-pdb --sequence \"VVVVVGGVVVVV\" --structure \"1-5:beta,6-8:random,9-12:beta\" --visualize\n</code></pre></p>"},{"location":"visualization/#3-polyproline-ii-helix-collagen-like","title":"3. Polyproline II Helix (Collagen-like)","text":"<p>Compare this left-handed, extended helix to the standard right-handed alpha helix. <pre><code>synth-pdb --sequence \"GPGPPGPPGPPGPP\" --conformation ppii --visualize\n</code></pre></p>"},{"location":"visualization/#4-minimization-in-action","title":"4. Minimization in Action","text":"<p>Generate a structure with clashes, then minimize it. Compare the \"before\" and \"after\" (by running two commands) to see how physics relaxes the geometry. <pre><code># Before (Clashed)\nsynth-pdb --length 30 --conformation random --visualize\n\n# After (Relaxed)\nsynth-pdb --length 30 --conformation random --minimize --visualize\n</code></pre></p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#1150-2026-02-02","title":"[1.15.0] - 2026-02-02","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>ML Handover Notebooks: Added zero-copy handover examples for JAX, MLX, and PyTorch in <code>examples/ml_loading/</code>.</li> <li>Vectorized Batch Generation: Exposed <code>BatchedGenerator</code> and <code>BatchedPeptide</code> via <code>synth_pdb.generator</code> for high-performance AI training pipelines.</li> <li>Salt Bridge Consolidation: Unified salt bridge force parameters to prevent global parameter conflicts in complex structures.</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>Cyclic Peptide Physics: Refined covalent ring closure using a surgical linear-to-cyclic conversion strategy, bypassing OpenMM template matching limitations.</li> <li>Physics Preprocessing: Resolved an <code>UnboundLocalError</code> in the simulation engine that caused crashes in specific edge-case topologies.</li> <li>Notebook Robustness: Added graceful dependency checks and precision-safe assertions (<code>assert_allclose</code>) to ML handover notebooks.</li> <li>Test Stability: Suppressed verbose Numba debug logging and fixed mock assertion failures in the physics test suite.</li> </ul>"},{"location":"about/changelog/#1140-2026-01-31","title":"[1.14.0] - 2026-01-31","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>D-Amino Acid Support: Support for generating and validating peptides with D-amino acids using the <code>D-</code> prefix in sequences.</li> <li>PDB Compatibility: Automatic conversion of D-amino acids to standard 3-letter codes (e.g., <code>DAL</code>, <code>DPH</code>).</li> <li>Educational Enhancements: Detailed comments explaining chiral mirroring and stereochemistry.</li> <li>New Tests: Comprehensive TDD suite for D-amino acid generation and validation.</li> </ul>"},{"location":"about/changelog/#1131-2026-01-30","title":"[1.13.1] - 2026-01-30","text":""},{"location":"about/changelog/#added_2","title":"Added","text":"<ul> <li>EGF Generation Example: Added a new example script <code>examples/generate_egf.py</code> demonstrating the generation of a complex 53-residue protein with disarmament minimization and synthetic NMR data.</li> </ul>"},{"location":"about/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Validator Stability: Fixed a critical <code>TypeError</code> in <code>validator.py</code> where terminal caps or incomplete backbone atoms could cause a crash during bond angle validation.</li> <li>Regression Testing: Added automated regression tests for the validator crash to prevent future regressions.</li> </ul>"},{"location":"about/changelog/#1130-2026-01-30","title":"[1.13.0] - 2026-01-30","text":""},{"location":"about/changelog/#added_3","title":"Added","text":"<ul> <li>Cyclic Peptide Support: Implemented head-to-tail macrocyclization with automated terminal atom removal (OXT/H1-3) and physics-based bond closure.</li> <li>Numba JIT Acceleration: Integrated <code>@njit</code> compilation for NeRF geometry engines, Lipari-Szabo spectral density, and Ring Current calculations, achieving 50-100x speedups.</li> <li>Visual Connectivity: Automated <code>CONECT</code> record generation for cyclic bonds and disulfide bridges to ensure seamless representation in the 3D viewer.</li> <li>Educational References: Added seminal scientific citations for macrocyclization (Horton, Craik) and deep-dive biophysical commentary to the codebase and README.</li> </ul>"},{"location":"about/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Proline Minimization: Resolved a bug where Proline residues in cyclic peptides caused OpenMM template errors by stripping illegal amide hydrogens.</li> <li>Metadata Persistence: Fixed an issue where PTM residue names (SEP, TPO, PTR) were lost during the minimization-to-assembly pipeline.</li> </ul>"},{"location":"about/changelog/#1120-2026-01-29","title":"[1.12.0] - 2026-01-29","text":""},{"location":"about/changelog/#added_4","title":"Added","text":"<ul> <li>Beta-Turn Geometries: Implemented physics-based construction for Type I, II, I', II', and VIII beta-turns. Added <code>--structure</code> CLI argument (e.g., <code>'3-6:typeII'</code>) for precise loop modeling.</li> <li>J-Coupling Prediction: Added generation of \\(^3J_{H_NH_\\alpha}\\) scalar couplings using the Karplus equation (\\(A \\cos^2\\phi + B \\cos\\phi + C\\)). Output available via <code>main.py</code> (CSV export).</li> <li>Cis-Proline Isomerization: Added <code>--cis-proline-frequency</code> to simulate biologically realistic non-canonical conformations (~5% frequency).</li> <li>Post-Translational Modifications (PTMs): Added <code>--phosphorylation-rate</code> to simulate Ser/Thr/Tyr phosphorylation, converting residues to SEP/TPO/PTR for downstream MD/NMR analysis.</li> <li>Performance: Vectorized geometry kernels and improved OpenMM platform selection (CUDA/Metal preference with CPU fallback).</li> </ul>"},{"location":"about/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>CLI Regressions: Fixed <code>AttributeError</code> caused by missing CLI arguments for new biophysics features.</li> <li>Variable Scoping: Resolved <code>NameError</code> in <code>generator.py</code> related to rotamer selection aliases.</li> </ul>"},{"location":"about/changelog/#1110-2026-01-29","title":"[1.11.0] - 2026-01-29","text":""},{"location":"about/changelog/#added_5","title":"Added","text":"<ul> <li>Pre-Proline Backbone Realism: Implemented specific conformational sampling for residues preceding Proline (favoring Extended/Beta, restricting Alpha). This significantly reduces steric clashes.</li> <li>Biophysical Efficiency: Validated that improving backbone realism reduces energy minimization time by &gt;60% (2.42s -&gt; 0.91s) by providing physically sound starting structures.</li> <li>Advanced Chemical Shifts: Added Ring Current Effects (Haigh-Mallion point-dipole model) to chemical shift prediction. Protons above aromatic rings are now correctly shielded, and in-plane protons deshielded.</li> <li>SASA-Modulated Relaxation: Implemented Solvent Accessible Surface Area (SASA) calculation to modulate Order Parameters (\\(S^2\\)). Buried residues are now modeled as more rigid than exposed ones.</li> <li>SSBOND Robustness: Enhanced disulfide bond detection with strict 1-to-1 pairing logic and a defined capture radius (8.0 \u00c5) to prevent multi-bond artifacts in dense structures.</li> </ul>"},{"location":"about/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>SSBOND Regression: Fixed an issue where single Cysteines could form multiple disulfide bonds.</li> <li>SASA Calculations: Added robust handling for <code>NaN</code> values in SASA calculation for small/mock structures.</li> </ul>"},{"location":"about/changelog/#1100-2026-01-28","title":"[1.10.0] - 2026-01-28","text":""},{"location":"about/changelog/#added_6","title":"Added","text":"<ul> <li>Full Rotamer Library: Expanded backbone-dependent rotamer library to support All 20 Standard Amino Acids (previously limited). Includes charged (ARG, LYS, GLU, ASP) and aromatic residues with biophysically accurate probabilities.</li> <li>Side-Chain Validation: Implemented <code>validate_side_chain_rotamers()</code> in <code>PDBValidator</code>. It now checks if generated Chi1/Chi2 angles conform to the library distributions (with configurable tolerance).</li> <li>Chirality Validation: Added <code>validate_chirality()</code> to ensure L-amino acid stereochemistry (checking improper dihedrals).</li> <li>Validation Integration: Updated CLI (<code>main.py</code>) to run the full suite of validation checks (including rotamers and chirality) whenever <code>--validate</code>, <code>--best-of-N</code>, or <code>--guarantee-valid</code> is used.</li> <li>Educational Notes: Added extensive comments explaining Rotamer libraries, Staggered conformations, and Validation logic.</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>CLI Robustness: Refactored <code>main.py</code> validation calls to use <code>validator.validate_all()</code>, ensuring no checks are silently skipped in the future.</li> <li>Tests: Replaced incomplete mocks with robust TDD cases for rotamer violations.</li> <li>Project Config: Updated <code>pyproject.toml</code> to fix <code>setuptools</code> deprecation warnings (retaining backward compatibility).</li> </ul>"},{"location":"about/changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Missing Validation: Fixed an issue where <code>main.py</code> was selectively running only some validation checks, ignoring newly added ones.</li> </ul>"},{"location":"about/changelog/#190-2026-01-27","title":"[1.9.0] - 2026-01-27","text":""},{"location":"about/changelog/#added_7","title":"Added","text":"<ul> <li>Feature: Metal Ion Coordination (Zinc detection and injection).</li> <li>Feature: Disulfide Bond detection (SSBOND records).</li> <li>Feature: Salt Bridge stabilization in Energy Minimization.</li> </ul>"},{"location":"about/changelog/#180-2026-01-20","title":"[1.8.0] - 2026-01-20","text":""},{"location":"about/changelog/#added_8","title":"Added","text":"<ul> <li>Feature: NEF (NMR Exchange Format) IO support.</li> <li>Feature: Chemical Shift Prediction (SPARTA+ style logic).</li> </ul>"},{"location":"about/citation/","title":"Citation","text":"<p>If you use synth-pdb in your research, please cite it using the following:</p>"},{"location":"about/citation/#bibtex","title":"BibTeX","text":"<pre><code>@software{elkins2026synthpdb,\n  author = {Elkins, George},\n  title = {synth-pdb: High-Performance Protein Structure Generator for AI/ML and Education},\n  year = {2026},\n  url = {https://github.com/elkins/synth-pdb},\n  version = {1.18.0}\n}\n</code></pre>"},{"location":"about/citation/#apa","title":"APA","text":"<p>Elkins, G. (2026). synth-pdb: High-Performance Protein Structure Generator for AI/ML and Education (Version 1.18.0) [Computer software]. https://github.com/elkins/synth-pdb</p>"},{"location":"about/citation/#mla","title":"MLA","text":"<p>Elkins, George. synth-pdb: High-Performance Protein Structure Generator for AI/ML and Education. Version 1.18.0, 2026, https://github.com/elkins/synth-pdb.</p>"},{"location":"about/citation/#chicago","title":"Chicago","text":"<p>Elkins, George. 2026. synth-pdb: High-Performance Protein Structure Generator for AI/ML and Education. Version 1.18.0. https://github.com/elkins/synth-pdb.</p>"},{"location":"about/citation/#zenodo-doi","title":"Zenodo DOI","text":"<p>To create a DOI for this project, visit Zenodo and link your GitHub repository. Once created, add the DOI badge here.</p>"},{"location":"about/citation/#acknowledgments","title":"Acknowledgments","text":"<p>synth-pdb builds upon the following excellent scientific software:</p> <ul> <li>Biotite: Protein structure manipulation (Kunzmann &amp; Hamacher, 2018)</li> <li>OpenMM: Molecular dynamics engine (Eastman et al., 2017)</li> <li>NumPy: Numerical computing (Harris et al., 2020)</li> <li>Numba: JIT compilation (Lam et al., 2015)</li> </ul>"},{"location":"about/citation/#related-publications","title":"Related Publications","text":"<p>If you're interested in the scientific methods implemented in synth-pdb, see:</p> <ul> <li>Lipari-Szabo Formalism: Lipari &amp; Szabo (1982) - NMR relaxation theory</li> <li>Ramachandran Plots: Ramachandran et al. (1963) - Protein backbone geometry</li> <li>Dunbrack Rotamer Library: Dunbrack &amp; Cohen (1997) - Side-chain conformations</li> <li>MolProbity Validation: Lovell et al. (2003) - Structure quality assessment</li> </ul>"},{"location":"about/citation/#license","title":"License","text":"<p>synth-pdb is released under the MIT License. See License for details.</p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2026 George Elkins</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/roadmap/","title":"Project Roadmap &amp; Future Horizons","text":"<p>Project: <code>synth-pdb</code> Focus: Biophysical Realism, Computational Efficiency, AI Research Support Strategy: Weighted by Highest Reward / Lowest Risk</p>"},{"location":"about/roadmap/#recently-completed","title":"\u2705 Recently Completed","text":"<p>The following features have been successfully implemented and verified: - Batched Generation (GPU-First): Vectorized SIMD/GPU-ready data factory. - D-Amino Acid Support: Mirror-image peptide generation and validation. - Hard Decoy Generation: Gaussian drift and sequence threading for AI training. - Numba JIT Support: Core geometry kernels optimized for high-performance. - Cyclic Peptide Support: Head-to-tail cyclization for therapeutic modeling.</p>"},{"location":"about/roadmap/#next-horizons-prioritized","title":"\ud83d\ude80 Next Horizons (Prioritized)","text":"<p>Sorted by High-Value / Low-Risk first.</p>"},{"location":"about/roadmap/#1-ml-integration-examples-high-value-low-risk","title":"1. ML Integration Examples \ud83e\udd16 (High Value / Low Risk)","text":"<ul> <li>Concept: Provide Jupyter notebooks/scripts demonstrating zero-copy handover from <code>BatchedPeptide</code> to PyTorch/JAX/MLX.</li> <li>Why: Closes the loop for AI researchers. Shows how to use the \"contiguous tensor\" output in real training pipelines.</li> <li>Implementation: Create an <code>examples/ml_loading/</code> directory with clear demonstrations.</li> </ul>"},{"location":"about/roadmap/#2-hardware-benchmarking-suite-medium-high-value-low-risk","title":"2. Hardware Benchmarking Suite \u23f1\ufe0f (Medium-High Value / Low Risk)","text":"<ul> <li>Concept: A formal tool to compare Serial vs. Batched performance across hardware (CPU vs. Apple Silicon M-series).</li> <li>Why: Quantifies the efficiency gains of the \"GPU-First\" architecture and justifies its use for large-scale data production.</li> <li>Implementation: New <code>benchmarks/</code> module with automated performance plotting.</li> </ul>"},{"location":"about/roadmap/#3-chromophore-educational-case-gfp-medium-high-value-medium-risk","title":"3. \"Chromophore\" Educational Case (GFP) \ud83c\udf08 (Medium-High Value / Medium Risk)","text":"<ul> <li>Concept: Specialized test case for a Green Fluorescent Protein (GFP) fragment, focusing on the Ser-Tyr-Gly cyclization.</li> <li>Why: Adds coordination chemistry and post-translational modification (PTM) education.</li> <li>Implementation: Extend <code>cofactors.py</code> or create <code>special_chemistry.py</code> to handle the unique SYG ring closure.</li> </ul>"},{"location":"about/roadmap/#section-1-biophysical-realism","title":"\ud83d\udd2c Section 1: Biophysical Realism","text":"<p>Goal: Generate structures that are indistinguishable from experimental data.</p>"},{"location":"about/roadmap/#1-explicit-solvent-water-box","title":"1. Explicit Solvent \"Water Box\" \ud83d\udca7","text":"<ul> <li>Concept: Simulate the protein in a box of explicit water molecules (TIP3P model) rather than implicit solvent.</li> <li>Use Case: Capturing \"water-bridging\" interactions that stabilize specific conformations.</li> <li>Risk: Medium. Increases minimization time significantly.</li> </ul>"},{"location":"about/roadmap/#2-macrocycle-design-lab-cyclic-peptides","title":"2. \u2705 Macrocycle Design Lab (Cyclic Peptides)","text":"<ul> <li>Result: Implemented modeling for Oxytocin (disulfide) and Cyclosporine A (cyclic/D-amino).</li> <li>Demo: hormone_lab.ipynb</li> <li>Value: Macrocycles are at the forefront of drug discovery. An AI model that can design cyclic peptides needs a training set of realistic closed loops, which standard PDBs lack in sufficient quantity.</li> </ul>"},{"location":"about/roadmap/#section-2-ai-research-support","title":"\ud83e\udd16 Section 2: AI Research Support","text":"<p>Goal: Provide data that trains better models (AlphaFold, RFDiffusion, etc.).</p>"},{"location":"about/roadmap/#1-co-evolutionary-constraints-msa","title":"1. Co-Evolutionary Constraints (MSA) \ud83e\uddec","text":"<ul> <li>Concept: Generate a family of sequences that imply a specific fold, simulating evolution.</li> <li>Implementation: Enhance <code>dataset.py</code> to generate correlated mutations based on the contact map.</li> </ul>"},{"location":"about/roadmap/#2-full-orientogram-factory-omega-theta-phi-angles","title":"2. \u2705 Full Orientogram Factory (\\(\\omega, \\theta, \\phi\\) angles)","text":"<ul> <li>Result: Implemented vectorized 6D inter-residue orientations with virtual GLY \\(C\\beta\\) support.</li> <li>Demo: orientogram_lab.ipynb</li> </ul>"},{"location":"about/roadmap/#3-bulk-dataset-factory-npz-pipeline","title":"3. \u2705 Bulk Dataset Factory (NPZ Pipeline)","text":"<ul> <li>Result: Implemented high-performance NPZ export and PyTorch integration.</li> <li>Demo: dataset_factory.ipynb</li> </ul>"},{"location":"about/roadmap/#4-multi-modal-transformer-training-structure-nmr","title":"4. \u2705 Multi-Modal Transformer Training (Structure + NMR)","text":"<ul> <li>Result: Integrated synchronized structural generation with synthetic NMR observables.</li> <li>Demo: neural_nmr_pipeline.ipynb</li> <li>Value: Demonstrates how synth-pdb can train models to predict experimental observables (like NMR shifts) directly from sequence or 3D geometry.</li> </ul>"},{"location":"about/roadmap/#5-torsion-angle-drift-distribution-analysis","title":"5. \ud83d\udcc9 Torsion Angle Drift &amp; Distribution Analysis","text":"<ul> <li>Objective: Statistically analyze how adding \"Drift\" to Ramachandran angles affects the overall fold and the radius of gyration.</li> <li>Key Features: <code>--drift</code>, <code>dihedral_backbone</code>, and <code>BatchedGenerator</code>.</li> <li>Value: Useful for researchers testing the robustness of their GNNs (Graph Neural Networks) to small backbone perturbations.</li> </ul>"},{"location":"about/roadmap/#long-term-high-risk","title":"\ud83d\udcc9 Long-Term / High Risk","text":"<ul> <li>Protein-Protein Docking: Complex multi-chain physics.</li> <li>Metadynamics Simulation: Better suited for dedicated MD engines.</li> <li>Fragment Assembly (Rosetta-style): Massive database dependencies.</li> </ul>"},{"location":"api/batch_generator/","title":"uatch_generator","text":"<p>Documentation coming soon.</p>"},{"location":"api/biophysics/","title":"uiophysics","text":"<p>Documentation coming soon.</p>"},{"location":"api/chemical_shifts/","title":"chemical_shifts","text":"<p>Documentation coming soon.</p>"},{"location":"api/dataset/","title":"dataset","text":"<p>Documentation coming soon.</p>"},{"location":"api/generator/","title":"generator Module","text":"<p>The <code>generator</code> module is the core of synth-pdb, responsible for creating protein structures from amino acid sequences.</p>"},{"location":"api/generator/#overview","title":"Overview","text":"<p>The generator uses the NeRF (Natural Extension Reference Frame) algorithm to build 3D protein structures from internal coordinates (bond lengths, angles, and dihedrals).</p>"},{"location":"api/generator/#main-classes","title":"Main Classes","text":""},{"location":"api/generator/#synth_pdb.generator.PeptideGenerator","title":"<code>PeptideGenerator</code>","text":"<p>Object-oriented wrapper for protein structure generation. Provides a cleaner API for interactive notebooks and complex workflows.</p> Source code in <code>synth_pdb/generator.py</code> <pre><code>class PeptideGenerator:\n    \"\"\"\n    Object-oriented wrapper for protein structure generation.\n    Provides a cleaner API for interactive notebooks and complex workflows.\n    \"\"\"\n    def __init__(self, sequence: str = \"ALA-GLY-SER\", **kwargs):\n        self.sequence = sequence\n        self.config = kwargs\n        self._last_result = None\n\n    def generate(self, **overrides) -&gt; \"PeptideResult\":\n        \"\"\"Generates the protein structure and returns a Result object.\"\"\"\n        # Merge init config with call-time overrides\n        call_config = {**self.config, **overrides}\n\n        # Call the functional generator\n        pdb_content = generate_pdb_content(\n            sequence_str=self.sequence,\n            **call_config\n        )\n\n        # Package into a Result object for easy access\n        self._last_result = PeptideResult(pdb_content)\n        return self._last_result\n</code></pre>"},{"location":"api/generator/#synth_pdb.generator.PeptideGenerator-functions","title":"Functions","text":""},{"location":"api/generator/#synth_pdb.generator.PeptideGenerator.__init__","title":"<code>__init__(sequence='ALA-GLY-SER', **kwargs)</code>","text":"Source code in <code>synth_pdb/generator.py</code> <pre><code>def __init__(self, sequence: str = \"ALA-GLY-SER\", **kwargs):\n    self.sequence = sequence\n    self.config = kwargs\n    self._last_result = None\n</code></pre>"},{"location":"api/generator/#synth_pdb.generator.PeptideGenerator.generate","title":"<code>generate(**overrides)</code>","text":"<p>Generates the protein structure and returns a Result object.</p> Source code in <code>synth_pdb/generator.py</code> <pre><code>def generate(self, **overrides) -&gt; \"PeptideResult\":\n    \"\"\"Generates the protein structure and returns a Result object.\"\"\"\n    # Merge init config with call-time overrides\n    call_config = {**self.config, **overrides}\n\n    # Call the functional generator\n    pdb_content = generate_pdb_content(\n        sequence_str=self.sequence,\n        **call_config\n    )\n\n    # Package into a Result object for easy access\n    self._last_result = PeptideResult(pdb_content)\n    return self._last_result\n</code></pre>"},{"location":"api/generator/#main-functions","title":"Main Functions","text":""},{"location":"api/generator/#synth_pdb.generator.generate_pdb_content","title":"<code>generate_pdb_content(length: Optional[int] = None, sequence_str: Optional[str] = None, use_plausible_frequencies: bool = False, conformation: str = 'alpha', structure: Optional[str] = None, optimize_sidechains: bool = False, minimize_energy: bool = False, forcefield: str = 'amber14-all.xml', seed: Optional[int] = None, ph: float = 7.4, cap_termini: bool = False, equilibrate: bool = False, equilibrate_steps: int = 1000, metal_ions: str = 'auto', minimization_k: float = 10.0, minimization_max_iter: int = 0, cis_proline_frequency: float = 0.05, phosphorylation_rate: float = 0.0, cyclic: bool = False, drift: float = 0.0, phi_list: Optional[List[float]] = None, psi_list: Optional[List[float]] = None, omega_list: Optional[List[float]] = None) -&gt; str</code>","text":"<p>Generates PDB content for a linear or cyclic peptide chain.</p> <p>EDUCATIONAL NOTE - New Feature: Cyclic Peptides Cyclic peptides have their N-terminus bonded to their C-terminus.  This modification increases metabolic stability and is common in  therapeutic peptides (e.g., Cyclosporin).</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>Optional[int]</code> <p>Number of residues (ignored if sequence_str provided)</p> <code>None</code> <code>sequence_str</code> <code>Optional[str]</code> <p>Explicit amino acid sequence (1-letter or 3-letter codes)</p> <code>None</code> <code>use_plausible_frequencies</code> <code>bool</code> <p>Use biologically realistic amino acid frequencies</p> <code>False</code> <code>conformation</code> <code>str</code> <p>Default secondary structure conformation.          Options: 'alpha', 'beta', 'ppii', 'extended', 'random'          Default: 'alpha' (alpha helix)          Used for all residues if structure is not provided,          or for residues not specified in structure parameter.</p> <code>'alpha'</code> <code>structure</code> <code>Optional[str]</code> <p>Per-region conformation specification (NEW!)       Format: \"start-end:conformation,start-end:conformation,...\"       Example: \"1-10:alpha,11-15:random,16-30:beta\"       If provided, overrides conformation for specified regions.       Unspecified residues use the default conformation parameter.</p> <code>None</code> <code>drift</code> <code>float</code> <p>Maximum random perturbation applied to phi/psi angles (degrees).    Used for \"hard decoy\" generation to create near-native conformations.</p> <code>0.0</code> <code>optimize_sidechains</code> <code>bool</code> <p>Run Monte Carlo side-chain optimization</p> <code>False</code> <code>minimize_energy</code> <code>bool</code> <p>Run OpenMM energy minimization (REQUIRED for cyclic closure)</p> <code>False</code> <code>forcefield</code> <code>str</code> <p>Forcefield to use for minimization</p> <code>'amber14-all.xml'</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducible generation</p> <code>None</code> <code>ph</code> <code>float</code> <p>pH for titration</p> <code>7.4</code> <code>cap_termini</code> <code>bool</code> <p>Add ACE/NME caps (Disabled if cyclic=True)</p> <code>False</code> <code>equilibrate</code> <code>bool</code> <p>Run MD equilibration</p> <code>False</code> <code>equilibrate_steps</code> <code>int</code> <p>Number of MD steps</p> <code>1000</code> <code>metal_ions</code> <code>str</code> <p>Handle metal ions</p> <code>'auto'</code> <code>minimization_k</code> <code>float</code> <p>Tolerance</p> <code>10.0</code> <code>minimization_max_iter</code> <code>int</code> <p>Max iterations</p> <code>0</code> <code>cis_proline_frequency</code> <code>float</code> <p>Frequency of cis-proline</p> <code>0.05</code> <code>phosphorylation_rate</code> <code>float</code> <p>Frequency of phosphorylation</p> <code>0.0</code> <code>cyclic</code> <code>bool</code> <p>Whether to generate a cyclic peptide (Head-to-Tail)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete PDB file content</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid conformation name or structure syntax provided</p> <p>EDUCATIONAL NOTE - Why Per-Region Conformations Matter: Real proteins have mixed secondary structures. For example: - Zinc fingers: beta sheets + alpha helices - Immunoglobulins: multiple beta sheets connected by loops - Helix-turn-helix motifs: two alpha helices connected by a turn This feature allows users to create these realistic structures.</p>"},{"location":"api/generator/#synth_pdb.generator.generate_pdb_content--educational-note-macrocyclization-cyclic-peptides","title":"EDUCATIONAL NOTE - Macrocyclization (Cyclic Peptides):","text":"<p>Cyclic peptides (macrocycles) are chains where the N-terminus and C-terminus  are covalently linked. This has profound biological implications: 1. Metabolic Stability: Resistance to exopeptidases that chew protein ends. 2. Binding Affinity: By \"locking\" the molecule into a specific shape,     the entropic penalty of binding to a target is greatly reduced. 3. Bioavailability: Many legendary drugs (like Cyclosporine A) are macrocycles.</p>"},{"location":"api/generator/#synth_pdb.generator.generate_pdb_content--educational-note-hard-decoy-support-ai-training","title":"EDUCATIONAL NOTE - Hard Decoy Support (AI Training):","text":"<p>This generator includes specialized parameters for \"Hard Decoy\" generation: 1. Torsion Drift (<code>drift</code>): Adds controlled Gaussian noise to ideal \\(\\phi/\\psi\\)    angles. This simulates \"near-native\" local structural errors that     challenge the resolution of AI scoring functions. 2. Threading (<code>phi_list</code>, <code>psi_list</code>, <code>omega_list</code>): Allows constructing     one sequence using the backbone torsion angles of another. This maps a     \"wrong\" sequence to a \"right\" fold, a key test for discriminative models.</p>"},{"location":"api/generator/#usage-examples","title":"Usage Examples","text":""},{"location":"api/generator/#basic-generation","title":"Basic Generation","text":"<pre><code>from synth_pdb.generator import PeptideGenerator\n\n# Create generator\ngen = PeptideGenerator(\"ALA-GLY-SER-LEU-VAL\")\n\n# Generate structure\npeptide = gen.generate(conformation=\"alpha\")\n\n# Get PDB content\npdb_content = peptide.to_pdb()\n\n# Save to file\nwith open(\"output.pdb\", \"w\") as f:\n    f.write(pdb_content)\n</code></pre>"},{"location":"api/generator/#mixed-secondary-structures","title":"Mixed Secondary Structures","text":"<pre><code># Helix-turn-helix motif\ngen = PeptideGenerator(\"ACDEFGHIKLMNPQRSTVWY\")\npeptide = gen.generate(\n    structure_regions=\"1-5:alpha,6-10:random,11-15:alpha\"\n)\n</code></pre>"},{"location":"api/generator/#random-sequence-generation","title":"Random Sequence Generation","text":"<pre><code>from synth_pdb.generator import generate_pdb_content\n\n# Generate random 20-residue peptide\npdb_content = generate_pdb_content(\n    length=20,\n    conformation=\"random\",\n    use_plausible_frequencies=True  # Use biologically realistic frequencies\n)\n</code></pre>"},{"location":"api/generator/#with-energy-minimization","title":"With Energy Minimization","text":"<pre><code>pdb_content = generate_pdb_content(\n    sequence_str=\"LKELEKELEKELEKEL\",  # Leucine zipper\n    conformation=\"alpha\",\n    minimize_energy=True,\n    cap_termini=True\n)\n</code></pre>"},{"location":"api/generator/#helper-functions","title":"Helper Functions","text":""},{"location":"api/generator/#synth_pdb.generator._resolve_sequence","title":"<code>_resolve_sequence(length, user_sequence_str=None, use_plausible_frequencies=False)</code>","text":"<p>Resolves the amino acid sequence, either by parsing a user-provided sequence or generating a random one.</p>"},{"location":"api/generator/#synth_pdb.generator._sample_ramachandran_angles","title":"<code>_sample_ramachandran_angles(res_name, next_res_name=None)</code>","text":"<p>Sample phi/psi angles from Ramachandran probability distribution.</p> <p>Uses residue-specific distributions for GLY and PRO, general distribution for all other amino acids. Samples from favored regions using weighted Gaussian distributions.</p> <p>New Feature: Pre-Proline Bias If next_res_name is 'PRO' and current residue is not GLY or PRO, uses a specific 'PRE_PRO' distribution (favors beta/extended).</p> <p>Parameters:</p> Name Type Description Default <code>res_name</code> <code>str</code> <p>Three-letter amino acid code</p> required <code>next_res_name</code> <code>Optional[str]</code> <p>(Optional) Code of the next residue</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (phi, psi) angles in degrees</p> Reference <p>Lovell et al. (2003) Proteins: Structure, Function, and Bioinformatics</p>"},{"location":"api/generator/#synth_pdb.generator._detect_disulfide_bonds","title":"<code>_detect_disulfide_bonds(peptide)</code>","text":"<p>Detect potential disulfide bonds between cysteine residues.</p>"},{"location":"api/generator/#synth_pdb.generator._detect_disulfide_bonds--educational-note-disulfide-bond-detection","title":"EDUCATIONAL NOTE - Disulfide Bond Detection:","text":"<p>Disulfide bonds form between two cysteine (CYS) residues when their sulfur atoms (SG) are close enough to form a covalent S-S bond.</p> <p>Detection Criteria: - Both residues must be CYS - SG-SG distance: 2.0-2.2 \u00c5 (slightly relaxed from ideal 2.0-2.1 \u00c5) - Only report each pair once (avoid duplicates)</p> <p>Why Distance Matters: - &lt; 2.0 \u00c5: Too close (steric clash, not realistic) - 2.0-2.1 \u00c5: Ideal disulfide bond distance - 2.1-2.2 \u00c5: Acceptable (allows for flexibility) - &gt; 2.2 \u00c5: Too far (no covalent bond possible)</p> <p>Biological Context: - Disulfides stabilize protein structure - Common in extracellular proteins - Rare in cytoplasm (reducing environment) - Important for protein folding and stability</p> <p>Parameters:</p> Name Type Description Default <code>peptide</code> <code>AtomArray</code> <p>Biotite AtomArray structure</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of tuples (res_id1, res_id2) representing disulfide bonds</p> Example <p>disulfides = _detect_disulfide_bonds(structure) print(disulfides) [(3, 8), (12, 20)]  # CYS 3-8 and CYS 12-20 are bonded</p>"},{"location":"api/generator/#educational-notes","title":"Educational Notes","text":""},{"location":"api/generator/#nerf-algorithm","title":"NeRF Algorithm","text":"<p>The NeRF (Natural Extension Reference Frame) algorithm builds 3D structures from internal coordinates:</p> <ol> <li>Bond Length: Distance between consecutive atoms (e.g., N-CA = 1.46 \u00c5)</li> <li>Bond Angle: Angle formed by three consecutive atoms (e.g., N-CA-C = 111\u00b0)</li> <li>Dihedral Angle: Torsion angle formed by four consecutive atoms (e.g., phi, psi)</li> </ol> <p>Mathematical Foundation:</p> <p>Given three atoms (A, B, C) and internal coordinates (bond_length, bond_angle, dihedral), the position of a new atom D is calculated by:</p> <ol> <li>Creating a local coordinate system at C</li> <li>Rotating by the dihedral angle</li> <li>Placing D at the specified bond length and angle</li> </ol> <p>This allows building complex 3D structures from simple 1D sequences.</p>"},{"location":"api/generator/#b-factor-calculation","title":"B-factor Calculation","text":"<p>B-factors (temperature factors) represent atomic mobility:</p> \\[B = 8\\pi^2 \\langle u^2 \\rangle\\] <p>Where \\(\\langle u^2 \\rangle\\) is the mean square displacement.</p> <p>synth-pdb calculates B-factors from Order Parameters (\\(S^2\\)) using the Lipari-Szabo formalism:</p> \\[B \\propto (1 - S^2)\\] <p>Realistic Ranges: - Backbone atoms: 15-25 \u0172 - Side-chain atoms: 20-35 \u0172 - Terminal residues: 30-50 \u0172</p>"},{"location":"api/generator/#see-also","title":"See Also","text":"<ul> <li>geometry Module - 3D coordinate calculations</li> <li>physics Module - Energy minimization</li> <li>validator Module - Structure validation</li> <li>Scientific Background: NeRF Geometry</li> </ul>"},{"location":"api/geometry/","title":"geometry","text":"<p>Documentation coming soon.</p>"},{"location":"api/nmr/","title":"nmr","text":"<p>Documentation coming soon.</p>"},{"location":"api/overview/","title":"API Reference","text":"<p>Welcome to the synth-pdb API reference. This section provides detailed documentation for all public modules, classes, and functions.</p>"},{"location":"api/overview/#quick-links","title":"Quick Links","text":""},{"location":"api/overview/#core-modules","title":"Core Modules","text":"<ul> <li> <p> generator</p> <p>Main module for generating protein structures from sequences</p> <p> View docs</p> </li> <li> <p> physics</p> <p>Energy minimization and molecular dynamics using OpenMM</p> <p> View docs</p> </li> <li> <p> validator</p> <p>Structure validation (bonds, angles, Ramachandran, clashes)</p> <p> View docs</p> </li> <li> <p> geometry</p> <p>3D coordinate calculations using NeRF algorithm</p> <p> View docs</p> </li> </ul>"},{"location":"api/overview/#scientific-features","title":"Scientific Features","text":"<ul> <li> <p> chemical_shifts</p> <p>NMR chemical shift prediction (\u00b9H, \u00b9\u00b3C, \u00b9\u2075N)</p> <p> View docs</p> </li> <li> <p> relaxation</p> <p>NMR relaxation rates (R\u2081, R\u2082, NOE) via Lipari-Szabo</p> <p> View docs</p> </li> <li> <p> nmr</p> <p>NOE restraint generation for structure calculation</p> <p> View docs</p> </li> <li> <p> biophysics</p> <p>pH titration, salt bridges, PTMs, metal coordination</p> <p> View docs</p> </li> </ul>"},{"location":"api/overview/#utilities","title":"Utilities","text":"<ul> <li> <p> batch_generator</p> <p>Vectorized batch generation for AI/ML workflows</p> <p> View docs</p> </li> <li> <p> viewer</p> <p>3D visualization using py3Dmol</p> <p> View docs</p> </li> <li> <p> dataset</p> <p>Bulk dataset generation and export (NPZ, HDF5)</p> <p> View docs</p> </li> </ul>"},{"location":"api/overview/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/overview/#as-a-library","title":"As a Library","text":"<pre><code>from synth_pdb.generator import PeptideGenerator\nfrom synth_pdb.physics import EnergyMinimizer\nfrom synth_pdb.validator import PDBValidator\n\n# Generate structure\ngen = PeptideGenerator(\"ALA-GLY-SER-LEU-VAL\")\npeptide = gen.generate(conformation=\"alpha\")\n\n# Minimize energy\nminimizer = EnergyMinimizer()\nminimized_pdb = minimizer.minimize(\n    pdb_file_path=\"input.pdb\",\n    output_path=\"output.pdb\"\n)\n\n# Validate structure\nvalidator = PDBValidator(pdb_content=minimized_pdb)\nvalidation_report = validator.validate_all()\n</code></pre>"},{"location":"api/overview/#as-a-command-line-tool","title":"As a Command-Line Tool","text":"<pre><code># Basic usage\nsynth-pdb --length 20 --conformation alpha --output structure.pdb\n\n# With minimization\nsynth-pdb --sequence \"ACDEFGHIKLMNPQRSTVWY\" --minimize --output minimized.pdb\n\n# Batch generation\nsynth-pdb --mode dataset --num-samples 1000 --output ./dataset\n</code></pre>"},{"location":"api/overview/#module-organization","title":"Module Organization","text":"<pre><code>synth_pdb/\n\u251c\u2500\u2500 generator.py          # Main structure generation\n\u251c\u2500\u2500 physics.py            # Energy minimization (OpenMM)\n\u251c\u2500\u2500 validator.py          # Structure validation\n\u251c\u2500\u2500 geometry.py           # NeRF algorithm, 3D coordinates\n\u251c\u2500\u2500 chemical_shifts.py    # NMR chemical shift prediction\n\u251c\u2500\u2500 relaxation.py         # NMR relaxation rates\n\u251c\u2500\u2500 nmr.py                # NOE restraints\n\u251c\u2500\u2500 biophysics.py         # pH, salt bridges, PTMs\n\u251c\u2500\u2500 batch_generator.py    # Vectorized batch generation\n\u251c\u2500\u2500 viewer.py             # 3D visualization\n\u251c\u2500\u2500 dataset.py            # Bulk dataset generation\n\u251c\u2500\u2500 data.py               # Rotamer libraries, Ramachandran data\n\u251c\u2500\u2500 main.py               # CLI entry point\n\u2514\u2500\u2500 ...                   # Additional utilities\n</code></pre>"},{"location":"api/overview/#design-philosophy","title":"Design Philosophy","text":"<p>synth-pdb follows these design principles:</p> <ol> <li>Code as Textbook: Extensive educational comments explaining the biophysical reasoning</li> <li>Modular Architecture: Clear separation of concerns (generation, physics, validation)</li> <li>Scientific Rigor: Proper implementation of established methods with citations</li> <li>Performance: Vectorized operations, optional Numba JIT compilation</li> <li>Flexibility: Works as both library and command-line tool</li> </ol>"},{"location":"api/overview/#next-steps","title":"Next Steps","text":"<ul> <li>generator Module - Start with the core generation module</li> <li>User Guides - Learn how to use synth-pdb effectively</li> <li>Examples Gallery - Browse copy-paste examples</li> </ul>"},{"location":"api/physics/","title":"physics","text":"<p>Documentation coming soon.</p>"},{"location":"api/relaxation/","title":"relaxation","text":"<p>Documentation coming soon.</p>"},{"location":"api/validator/","title":"validator","text":"<p>Documentation coming soon.</p>"},{"location":"api/viewer/","title":"viewer","text":"<p>Documentation coming soon.</p>"},{"location":"development/architecture/","title":"architecture","text":"<p>Documentation coming soon.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>We welcome contributions to <code>synth-pdb</code>! Whether you're fixing bugs, adding new features, improving documentation, or suggesting enhancements, your input helps make this project better for everyone. This guide will help you get started.</p>"},{"location":"development/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to <code>synth-pdb</code>:</p> <ul> <li>Report Bugs: If you find a bug, please open an issue on our GitHub repository. Provide clear steps to reproduce the bug, expected behavior, and actual behavior.</li> <li>Suggest Features: Have an idea for a new feature or improvement? Open an issue on GitHub to discuss it.</li> <li>Improve Documentation: Spotted a typo, an unclear explanation, or want to add a new example? Documentation contributions are highly valued!</li> <li>Write Code: Implement new features, fix bugs, or refactor existing code.</li> <li>Provide Feedback: Share your thoughts on usability, performance, or anything else.</li> </ul>"},{"location":"development/contributing/#getting-started-with-code-contributions","title":"Getting Started with Code Contributions","text":"<p>If you plan to contribute code, please follow these steps:</p>"},{"location":"development/contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>First, fork the <code>synth-pdb</code> repository on GitHub to your personal account.</p>"},{"location":"development/contributing/#2-clone-your-fork","title":"2. Clone Your Fork","text":"<p>Clone your forked repository to your local machine:</p> <pre><code>git clone https://github.com/YOUR_USERNAME/synth-pdb.git\ncd synth-pdb\n</code></pre>"},{"location":"development/contributing/#3-set-up-your-development-environment","title":"3. Set Up Your Development Environment","text":"<p>It's recommended to work in a virtual environment.</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows, use `.venv\\Scripts\\activate`\npip install -e .           # Install synth-pdb in editable mode\npip install -r requirements-dev.txt # Install development dependencies\n</code></pre>"},{"location":"development/contributing/#4-create-a-new-branch","title":"4. Create a New Branch","text":"<p>Create a new branch for your feature or bug fix:</p> <pre><code>git checkout -b feature/your-feature-name-or-bugfix/your-bugfix-name\n</code></pre> <p>Choose a descriptive branch name.</p>"},{"location":"development/contributing/#5-make-your-changes","title":"5. Make Your Changes","text":"<p>Implement your changes. Please adhere to the existing coding style and conventions.</p>"},{"location":"development/contributing/#6-test-your-changes","title":"6. Test Your Changes","text":"<p>Ensure your changes work as expected and don't introduce new bugs. If you're adding new features, please write unit tests for them.</p> <p>To run tests:</p> <pre><code>pytest\n</code></pre>"},{"location":"development/contributing/#7-lint-and-format-your-code","title":"7. Lint and Format Your Code","text":"<p>We use <code>ruff</code> and <code>black</code> for linting and formatting. Please run them before committing:</p> <pre><code>ruff check . --fix\nblack .\n</code></pre>"},{"location":"development/contributing/#8-commit-your-changes","title":"8. Commit Your Changes","text":"<p>Write clear and concise commit messages. A good commit message explains what changed and why.</p> <pre><code>git add .\ngit commit -m \"feat: Add new feature for X\"\n</code></pre>"},{"location":"development/contributing/#9-push-your-branch","title":"9. Push Your Branch","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#10-open-a-pull-request","title":"10. Open a Pull Request","text":"<p>Go to your forked repository on GitHub and open a Pull Request (PR) to the <code>main</code> branch of the original <code>synth-pdb</code> repository. Please provide a clear description of your changes and reference any related issues.</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project, you agree to abide by its terms.</p> <p>Thank you for contributing to <code>synth-pdb</code>!</p>"},{"location":"development/release/","title":"release","text":"<p>Documentation coming soon.</p>"},{"location":"development/testing/","title":"testing","text":"<p>Documentation coming soon.</p>"},{"location":"examples/advanced/","title":"advanced","text":"<p>Documentation coming soon.</p>"},{"location":"examples/biological/","title":"uiological","text":"<p>Documentation coming soon.</p>"},{"location":"examples/gallery/","title":"Examples Gallery","text":"<p>Browse inspiring examples and copy-paste commands to get started quickly.</p>"},{"location":"examples/gallery/#basic-structures","title":"Basic Structures","text":""},{"location":"examples/gallery/#alpha-helix","title":"Alpha Helix","text":"<p>The most common secondary structure in proteins.</p> <pre><code>synth-pdb --length 20 --conformation alpha --visualize\n</code></pre> <p>Features: - 3.6 residues per turn - 5.4 \u00c5 pitch - Hydrogen bonds between i and i+4 residues</p>"},{"location":"examples/gallery/#beta-sheet","title":"Beta Sheet","text":"<p>Extended conformation with characteristic pleated structure.</p> <pre><code>synth-pdb --length 20 --conformation beta --visualize\n</code></pre> <p>Features: - Extended backbone (phi \u2248 -120\u00b0, psi \u2248 +120\u00b0) - 3.3 \u00c5 between residues - Parallel or antiparallel arrangements</p>"},{"location":"examples/gallery/#random-coil","title":"Random Coil","text":"<p>Disordered structure with diverse conformations.</p> <pre><code>synth-pdb --length 20 --conformation random --visualize\n</code></pre> <p>Features: - Ramachandran angles sampled from allowed regions - No regular secondary structure - Useful for testing flexibility</p>"},{"location":"examples/gallery/#biologically-inspired-structures","title":"Biologically-Inspired Structures","text":""},{"location":"examples/gallery/#leucine-zipper","title":"Leucine Zipper","text":"<p>Classic coiled-coil motif with hydrophobic interface.</p> <pre><code>synth-pdb --sequence \"LKELEKELEKELEKELEKELEKEL\" \\\n    --conformation alpha \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Scientific Context: - Heptad repeat pattern (a-b-c-d-e-f-g) - Leucines at 'a' and 'd' positions form hydrophobic core - Found in transcription factors (e.g., GCN4, c-Fos, c-Jun)</p>"},{"location":"examples/gallery/#zinc-finger","title":"Zinc Finger","text":"<p>DNA-binding motif coordinating Zn\u00b2\u207a ion.</p> <pre><code>synth-pdb --sequence \"CPHCGKSFSQKSDLVKHQRT\" \\\n    --structure \"1-10:beta,11-20:alpha\" \\\n    --metal-ions auto \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Scientific Context: - Cys\u2082His\u2082 coordination of Zn\u00b2\u207a - Beta-hairpin + alpha-helix architecture - Found in transcription factors (e.g., TFIIIA, Sp1)</p>"},{"location":"examples/gallery/#collagen-triple-helix","title":"Collagen Triple Helix","text":"<p>Unique left-handed helix with Gly-X-Y repeats.</p> <pre><code>synth-pdb --sequence \"GPPGPPGPPGPPGPPGPPGPP\" \\\n    --conformation polyproline \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Scientific Context: - Gly-Pro-Pro repeat pattern - Left-handed helix (opposite of alpha helix) - Three chains intertwine to form triple helix</p>"},{"location":"examples/gallery/#silk-fibroin","title":"Silk Fibroin","text":"<p>Beta-sheet-rich structure with Ala-Gly repeats.</p> <pre><code>synth-pdb --sequence \"AGAGAGAGAGAGAGAGAGAG\" \\\n    --conformation beta \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Scientific Context: - Alanine-glycine repeats - Antiparallel beta sheets - High tensile strength</p>"},{"location":"examples/gallery/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/gallery/#cyclic-peptide","title":"Cyclic Peptide","text":"<p>Head-to-tail cyclized structure.</p> <pre><code>synth-pdb --sequence \"GGGGGGGGGGGG\" \\\n    --cyclic \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Applications: - Drug design (improved stability) - Examples: Cyclosporine A, Oxytocin</p>"},{"location":"examples/gallery/#disulfide-bonds","title":"Disulfide Bonds","text":"<p>Covalent cross-links between cysteine residues.</p> <pre><code>synth-pdb --sequence \"CGGGGGGGGGGC\" \\\n    --conformation alpha \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Features: - Automatic detection of Cys pairs within 2.0-2.2 \u00c5 - Stabilizes protein structure - Common in extracellular proteins</p>"},{"location":"examples/gallery/#mixed-secondary-structures","title":"Mixed Secondary Structures","text":"<p>Helix-turn-helix motif.</p> <pre><code>synth-pdb --sequence \"ACDEFGHIKLMNPQRSTVWY\" \\\n    --structure \"1-7:alpha,8-13:random,14-20:alpha\" \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Features: - Multiple secondary structure regions - Realistic protein architecture - Useful for testing fold recognition</p>"},{"location":"examples/gallery/#d-amino-acids","title":"D-Amino Acids","text":"<p>Mirror-image amino acids for peptide design.</p> <pre><code>synth-pdb --sequence \"ALA-dALA-GLY-dGLY-SER-dSER\" \\\n    --conformation alpha \\\n    --minimize \\\n    --visualize\n</code></pre> <p>Applications: - Protease resistance - Drug design - Retro-inverso peptides</p>"},{"location":"examples/gallery/#nmr-data-generation","title":"NMR Data Generation","text":""},{"location":"examples/gallery/#chemical-shifts","title":"Chemical Shifts","text":"<p>Generate structure with predicted NMR chemical shifts.</p> <pre><code>synth-pdb --length 30 \\\n    --conformation alpha \\\n    --gen-shifts \\\n    --output nmr_structure.pdb\n</code></pre> <p>Output: NEF file with \u00b9H, \u00b9\u00b3C, \u00b9\u2075N chemical shifts</p>"},{"location":"examples/gallery/#relaxation-rates","title":"Relaxation Rates","text":"<p>Generate structure with NMR relaxation data.</p> <pre><code>synth-pdb --length 30 \\\n    --conformation alpha \\\n    --gen-relax \\\n    --output nmr_structure.pdb\n</code></pre> <p>Output: NEF file with R\u2081, R\u2082, NOE values</p>"},{"location":"examples/gallery/#noe-restraints","title":"NOE Restraints","text":"<p>Generate distance restraints for structure calculation.</p> <pre><code>synth-pdb --length 30 \\\n    --conformation alpha \\\n    --gen-nef \\\n    --output nmr_structure.pdb\n</code></pre> <p>Output: NEF file with NOE distance restraints</p>"},{"location":"examples/gallery/#dataset-generation","title":"Dataset Generation","text":""},{"location":"examples/gallery/#bulk-generation","title":"Bulk Generation","text":"<p>Generate 1,000 diverse structures for ML training.</p> <pre><code>synth-pdb --mode dataset \\\n    --num-samples 1000 \\\n    --min-length 10 \\\n    --max-length 50 \\\n    --output ./training_data\n</code></pre> <p>Output Structure: <pre><code>training_data/\n\u251c\u2500\u2500 dataset_manifest.csv\n\u251c\u2500\u2500 train/ (800 structures)\n\u2514\u2500\u2500 test/ (200 structures)\n</code></pre></p>"},{"location":"examples/gallery/#hard-decoys","title":"Hard Decoys","text":"<p>Generate challenging negative samples.</p> <pre><code>synth-pdb --mode decoys \\\n    --sequence ACDEFGHIKLMNPQRSTVWY \\\n    --drift 5.0 \\\n    --num-samples 100 \\\n    --output ./decoys\n</code></pre> <p>Use Cases: - Training robust AI models - Testing structure validation tools - Benchmarking scoring functions</p>"},{"location":"examples/gallery/#next-steps","title":"Next Steps","text":"<ul> <li>Biologically-Inspired Examples - More detailed biological examples</li> <li>Visualization Examples - Advanced visualization techniques</li> <li>Advanced Features - Expert-level usage</li> <li>User Guides - Comprehensive guides for different users</li> </ul>"},{"location":"examples/visualization/","title":"visualization","text":"<p>Documentation coming soon.</p>"},{"location":"getting-started/first-structure/","title":"Your First Structure","text":"<p>This tutorial walks you through generating your first protein structure with synth-pdb.</p>"},{"location":"getting-started/first-structure/#step-1-choose-your-sequence","title":"Step 1: Choose Your Sequence","text":"<p>You can specify a sequence in two ways:</p> <ol> <li>Random length: <code>--length 20</code></li> <li>Specific sequence: <code>--sequence \"ALA-GLY-SER-LEU-VAL\"</code></li> </ol>"},{"location":"getting-started/first-structure/#step-2-choose-conformation","title":"Step 2: Choose Conformation","text":"<ul> <li><code>alpha</code> - Alpha helix</li> <li><code>beta</code> - Beta sheet</li> <li><code>random</code> - Random coil</li> <li><code>polyproline</code> - Polyproline II helix</li> </ul>"},{"location":"getting-started/first-structure/#step-3-generate","title":"Step 3: Generate","text":"<pre><code>synth-pdb --length 20 --conformation alpha --output my_structure.pdb\n</code></pre>"},{"location":"getting-started/first-structure/#step-4-visualize","title":"Step 4: Visualize","text":"<pre><code>synth-pdb --length 20 --conformation alpha --visualize\n</code></pre>"},{"location":"getting-started/first-structure/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide</li> <li>Examples Gallery</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.8 or higher</li> <li>Operating System: macOS, Linux, or Windows</li> <li>Dependencies: NumPy, Biotite, OpenMM (optional), Numba (optional)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#pypi-recommended","title":"PyPI (Recommended)","text":"<p>The easiest way to install synth-pdb is via PyPI:</p> <pre><code>pip install synth-pdb\n</code></pre> <p>This installs: - The <code>synth-pdb</code> command-line tool - The <code>synth_pdb</code> Python library - All required dependencies</p>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/elkins/synth-pdb.git\ncd synth-pdb\npip install -e .\n</code></pre> <p>The <code>-e</code> flag installs in \"editable\" mode, so changes to the source code are immediately reflected.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>To install with development dependencies (testing, linting, etc.):</p> <pre><code>git clone https://github.com/elkins/synth-pdb.git\ncd synth-pdb\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#openmm-physics-engine","title":"OpenMM (Physics Engine)","text":"<p>For energy minimization and MD equilibration:</p> <pre><code>pip install openmm\n</code></pre> <p>Or via conda (recommended for Apple Silicon):</p> <pre><code>conda install -c conda-forge openmm\n</code></pre> <p>Apple Silicon Users</p> <p>OpenMM on M1/M2/M3/M4 Macs supports GPU acceleration via OpenCL/Metal, providing 5x speedup over CPU.</p>"},{"location":"getting-started/installation/#numba-jit-compilation","title":"Numba (JIT Compilation)","text":"<p>For 50-100x speedup on geometry and NMR calculations:</p> <pre><code>pip install numba\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>synth-pdb --version\n</code></pre> <p>Expected output: <pre><code>synth-pdb version 1.18.0\n</code></pre></p> <p>Test basic functionality:</p> <pre><code>synth-pdb --length 5 --output test.pdb\n</code></pre> <p>This should create a <code>test.pdb</code> file in the current directory.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#importerror-no-module-named-openmm","title":"ImportError: No module named 'openmm'","text":"<p>If you see this error when using <code>--minimize</code>:</p> <pre><code>pip install openmm\n</code></pre> <p>Or skip minimization:</p> <pre><code>synth-pdb --length 10  # Works without OpenMM\n</code></pre>"},{"location":"getting-started/installation/#apple-silicon-openmm-not-found","title":"Apple Silicon: OpenMM Not Found","text":"<p>Use conda instead of pip:</p> <pre><code>conda install -c conda-forge openmm\n</code></pre>"},{"location":"getting-started/installation/#windows-long-path-issues","title":"Windows: Long Path Issues","text":"<p>Enable long paths in Windows:</p> <pre><code># Run as Administrator\nNew-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\" -Name \"LongPathsEnabled\" -Value 1 -PropertyType DWORD -Force\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Generate your first structure</li> <li>First Structure Tutorial - Detailed walkthrough</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get up and running with synth-pdb in 5 minutes.</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"PyPI (Recommended)From Source <pre><code>pip install synth-pdb\n</code></pre> <pre><code>git clone https://github.com/elkins/synth-pdb.git\ncd synth-pdb\npip install .\n</code></pre>"},{"location":"getting-started/quickstart/#your-first-structure","title":"Your First Structure","text":"<p>Generate a simple 10-residue alpha helix:</p> <pre><code>synth-pdb --length 10 --conformation alpha --output my_first_helix.pdb\n</code></pre> <p>This creates a PDB file with: - \u2705 Full atomic representation (backbone + side-chains + hydrogens) - \u2705 Realistic B-factors and occupancy values - \u2705 Proper bond geometry and angles</p>"},{"location":"getting-started/quickstart/#visualize-it","title":"Visualize It","text":"<p>View your structure interactively in the browser:</p> <pre><code>synth-pdb --length 10 --conformation alpha --visualize\n</code></pre>"},{"location":"getting-started/quickstart/#add-physics","title":"Add Physics","text":"<p>Generate a more realistic structure with energy minimization:</p> <pre><code>synth-pdb --length 20 --conformation alpha --minimize --output minimized.pdb\n</code></pre> <p>This uses OpenMM to: - Regularize bond lengths and angles - Resolve steric clashes - Apply implicit solvent effects</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li> <p> First Structure Tutorial</p> <p>Detailed walkthrough of generating your first protein structure</p> <p> Start tutorial</p> </li> <li> <p> Command-Line Reference</p> <p>Complete reference of all available options and flags</p> <p> View reference</p> </li> <li> <p> Examples Gallery</p> <p>Browse inspiring examples and copy-paste commands</p> <p> Explore gallery</p> </li> <li> <p> AI/ML Integration</p> <p>Learn how to use synth-pdb for machine learning workflows</p> <p> ML guide</p> </li> </ul>"},{"location":"getting-started/quickstart/#common-use-cases","title":"Common Use Cases","text":""},{"location":"getting-started/quickstart/#testing-bioinformatics-tools","title":"Testing Bioinformatics Tools","text":"<pre><code># Generate a test dataset\nsynth-pdb --mode dataset --num-samples 100 --output ./test_data\n</code></pre>"},{"location":"getting-started/quickstart/#educational-demonstrations","title":"Educational Demonstrations","text":"<pre><code># Show different secondary structures\nsynth-pdb --structure \"1-10:alpha,11-20:beta\" --visualize\n</code></pre>"},{"location":"getting-started/quickstart/#nmr-data-generation","title":"NMR Data Generation","text":"<pre><code># Generate structure with synthetic NMR observables\nsynth-pdb --length 30 --gen-nef --gen-relax --output nmr_test.pdb\n</code></pre>"},{"location":"getting-started/quickstart/#getting-help","title":"Getting Help","text":"<p>Need help?</p> <ul> <li>\ud83d\udcd6 Check the User Guides</li> <li>\ud83d\udcac Ask questions on GitHub Discussions</li> <li>\ud83d\udc1b Report bugs on GitHub Issues</li> </ul>"},{"location":"guides/beginners/","title":"Beginners","text":"<p>Welcome to <code>synth-pdb</code>, a powerful tool designed to generate protein structures for various applications, especially in AI/ML research and educational settings. If you're new to protein modeling, computational structural biology, or simply looking for an efficient way to create diverse protein structures, you're in the right place!</p>"},{"location":"guides/beginners/#what-is-synth-pdb","title":"What is <code>synth-pdb</code>?","text":"<p><code>synth-pdb</code> is a high-performance Python library that allows you to synthesize Protein Data Bank (PDB) files programmatically. It focuses on generating realistic and diverse protein structures, ranging from simple peptides to complex globular proteins, with control over various biophysical properties.</p>"},{"location":"guides/beginners/#why-use-synth-pdb","title":"Why use <code>synth-pdb</code>?","text":"<ul> <li>AI/ML Data Generation: Create large, diverse datasets of protein structures for training machine learning models in areas like protein folding, design, and function prediction.</li> <li>Education &amp; Visualization: Generate custom protein examples to illustrate structural biology concepts in classrooms or interactive tutorials.</li> <li>Hypothesis Testing: Quickly prototype and test ideas about protein structure-function relationships.</li> <li>Flexibility: Control parameters such as amino acid sequence, secondary structure elements, and global folds.</li> </ul>"},{"location":"guides/beginners/#getting-started-your-first-protein","title":"Getting Started: Your First Protein","text":"<p>Before you begin, ensure you have <code>synth-pdb</code> installed. If not, please refer to the Installation Guide.</p> <p>Once installed, generating a simple protein is straightforward. Let's create a small alanine peptide:</p> <pre><code>from synth_pdb.generator import generate_protein\n\n# Generate a simple 5-residue poly-alanine peptide\n# This will create a PDB file named 'poly_ala_5.pdb' in your current directory\nprotein_model = generate_protein(sequence=\"AAAAA\", output_filepath=\"poly_ala_5.pdb\")\nprint(f\"Generated protein: {protein_model.filepath}\")\n</code></pre> <p>This simple command creates a PDB file that you can then visualize using tools like PyMOL, VMD, or NGL Viewer.</p>"},{"location":"guides/beginners/#key-concepts","title":"Key Concepts","text":"<p>As you delve deeper into <code>synth-pdb</code>, you'll encounter concepts like:</p> <ul> <li>PDB Files: The standard file format for recording protein and nucleic acid structures.</li> <li>Amino Acids: The building blocks of proteins, linked together in a specific sequence.</li> <li>Residues: Individual amino acid units within a protein chain.</li> <li>Torsional Angles (Phi/Psi): Key angles that define the backbone conformation of a protein.</li> </ul>"},{"location":"guides/beginners/#where-to-go-next","title":"Where to go next?","text":"<ul> <li>Quick Start Guide: Learn more about basic usage and features in the Quick Start Guide.</li> <li>Interactive Tutorials: Explore practical examples and advanced functionalities in the Tutorials section.</li> <li>API Reference: Dive into the detailed documentation of specific modules and functions in the API Reference.</li> </ul> <p>Happy generating!</p>"},{"location":"guides/cli-reference/","title":"cli reference","text":"<p>Documentation coming soon.</p>"},{"location":"guides/ml-researchers/","title":"Guide for AI/ML Researchers","text":"<p>synth-pdb is designed as a high-performance data factory for training protein AI models. This guide shows you how to leverage its unique capabilities for machine learning workflows.</p>"},{"location":"guides/ml-researchers/#why-use-synth-pdb-for-ml","title":"Why Use synth-pdb for ML?","text":""},{"location":"guides/ml-researchers/#1-zero-copy-handover","title":"1. Zero-Copy Handover \ud83d\ude80","text":"<p>Direct NumPy \u2192 PyTorch/JAX/MLX without memory copying:</p> <pre><code>from synth_pdb.batch_generator import BatchedGenerator\nimport torch\n\n# Generate 1,000 structures in milliseconds\ngenerator = BatchedGenerator(\"ALA-GLY-SER-LEU-VAL\", n_batch=1000)\nbatch = generator.generate_batch(drift=5.0)\n\n# Zero-copy PyTorch handover\ncoords_tensor = torch.from_numpy(batch.coords).float()\nprint(f\"Contiguous: {coords_tensor.is_contiguous()}\")  # True\nprint(f\"Shares memory: {coords_tensor.data_ptr() == batch.coords.ctypes.data}\")  # True\n</code></pre>"},{"location":"guides/ml-researchers/#2-vectorized-generation","title":"2. Vectorized Generation \u26a1","text":"<p>20x faster than serial generation:</p> <pre><code>import time\n\n# Serial (slow)\nstart = time.time()\nfor _ in range(1000):\n    gen = PeptideGenerator(\"ALA-GLY-SER\")\n    peptide = gen.generate()\nserial_time = time.time() - start\n\n# Batched (fast)\nstart = time.time()\nbatch = BatchedGenerator(\"ALA-GLY-SER\", n_batch=1000).generate_batch()\nbatched_time = time.time() - start\n\nprint(f\"Speedup: {serial_time / batched_time:.1f}x\")  # ~20x\n</code></pre>"},{"location":"guides/ml-researchers/#3-hard-decoys","title":"3. Hard Decoys \ud83c\udfaf","text":"<p>Generate challenging negative samples for robust training:</p> Sequence ThreadingTorsion DriftLabel Shuffling <p>Force a sequence onto the wrong backbone:</p> <pre><code># Thread Poly-Ala onto Poly-Pro backbone\nsynth-pdb --mode decoys --sequence AAAAA --template-sequence PPPPP --hard\n</code></pre> <p>Add controlled noise to Ramachandran angles:</p> <pre><code># Add 5\u00b0 drift to all phi/psi angles\nsynth-pdb --mode decoys --drift 5.0\n</code></pre> <p>Generate valid structure, then shuffle residue identities:</p> <pre><code>synth-pdb --mode decoys --sequence ACDEF --shuffle-sequence\n</code></pre>"},{"location":"guides/ml-researchers/#4-rotation-invariant-features","title":"4. Rotation-Invariant Features \ud83d\udd04","text":"<p>Built-in distogram and orientogram export:</p> <pre><code>from synth_pdb.distogram import calculate_distogram\nfrom synth_pdb.orientogram import calculate_orientogram\n\n# Distogram (NxN distance matrix)\ndistogram = calculate_distogram(peptide.structure)\n\n# Orientogram (6D inter-residue orientations)\norientogram = calculate_orientogram(peptide.structure)\n</code></pre>"},{"location":"guides/ml-researchers/#quick-start-batch-generation","title":"Quick Start: Batch Generation","text":""},{"location":"guides/ml-researchers/#basic-batch-generation","title":"Basic Batch Generation","text":"<pre><code>from synth_pdb.batch_generator import BatchedGenerator\n\n# Generate 1,000 diverse structures\ngenerator = BatchedGenerator(\n    sequence=\"ALA-GLY-SER-LEU-VAL-ILE-MET\",\n    n_batch=1000,\n    full_atom=False  # Backbone only for speed\n)\n\nbatch = generator.generate_batch(drift=5.0)\n\nprint(f\"Shape: {batch.coords.shape}\")  # (1000, 7, 5, 3)\n# Dimensions: (batch, residues, atoms_per_residue, xyz)\n</code></pre>"},{"location":"guides/ml-researchers/#pytorch-dataloader-integration","title":"PyTorch DataLoader Integration","text":"<pre><code>import torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass SynthPDBDataset(Dataset):\n    def __init__(self, sequences, n_samples_per_seq=100):\n        self.data = []\n        for seq in sequences:\n            gen = BatchedGenerator(seq, n_batch=n_samples_per_seq)\n            batch = gen.generate_batch(drift=3.0)\n            self.data.append(torch.from_numpy(batch.coords).float())\n        self.data = torch.cat(self.data, dim=0)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, idx):\n        return self.data[idx]\n\n# Create dataset\nsequences = [\"ALA-GLY-SER\", \"LEU-VAL-ILE\", \"PHE-TYR-TRP\"]\ndataset = SynthPDBDataset(sequences, n_samples_per_seq=100)\n\n# Create DataLoader\ndataloader = DataLoader(dataset, batch_size=32, shuffle=True)\n\n# Train loop\nfor batch in dataloader:\n    # batch shape: (32, residues, atoms, 3)\n    predictions = model(batch)\n    loss = criterion(predictions, targets)\n    loss.backward()\n</code></pre>"},{"location":"guides/ml-researchers/#advanced-dataset-factory","title":"Advanced: Dataset Factory","text":"<p>Generate massive datasets for pre-training:</p> <pre><code># Generate 10,000 structures with contact maps\nsynth-pdb --mode dataset \\\n    --dataset-format npz \\\n    --num-samples 10000 \\\n    --min-length 10 \\\n    --max-length 50 \\\n    --output ./training_data\n</code></pre> <p>Output structure: <pre><code>training_data/\n\u251c\u2500\u2500 dataset_manifest.csv\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 synth_000001.npz  # coords, sequence, contact_map\n\u2502   \u251c\u2500\u2500 synth_000002.npz\n\u2502   ...\n\u2514\u2500\u2500 test/\n    \u251c\u2500\u2500 synth_008001.npz\n    ...\n</code></pre></p> <p>Load in PyTorch:</p> <pre><code>import numpy as np\nfrom pathlib import Path\n\nclass NPZDataset(Dataset):\n    def __init__(self, data_dir):\n        self.files = list(Path(data_dir).glob(\"*.npz\"))\n\n    def __len__(self):\n        return len(self.files)\n\n    def __getitem__(self, idx):\n        data = np.load(self.files[idx])\n        return {\n            'coords': torch.from_numpy(data['coords']).float(),\n            'sequence': torch.from_numpy(data['sequence']).float(),\n            'contact_map': torch.from_numpy(data['contact_map']).float()\n        }\n\ndataset = NPZDataset(\"training_data/train\")\n</code></pre>"},{"location":"guides/ml-researchers/#use-cases","title":"Use Cases","text":""},{"location":"guides/ml-researchers/#1-structure-prediction-alphafold-style","title":"1. Structure Prediction (AlphaFold-style)","text":"<p>Train a model to predict 3D coordinates from sequence:</p> <pre><code># Generate training data\nsequences = generate_random_sequences(n=10000, length_range=(10, 50))\nfor seq in sequences:\n    gen = PeptideGenerator(seq)\n    peptide = gen.generate(conformation=\"random\")\n    # Save (sequence, coords) pairs\n</code></pre>"},{"location":"guides/ml-researchers/#2-protein-design-inverse-folding","title":"2. Protein Design (Inverse Folding)","text":"<p>Train a model to predict sequence from structure:</p> <pre><code># Generate (structure, sequence) pairs\nbatch = BatchedGenerator(\"ALA-GLY-SER\", n_batch=1000).generate_batch()\n# Train model: coords \u2192 sequence\n</code></pre>"},{"location":"guides/ml-researchers/#3-contact-prediction","title":"3. Contact Prediction","text":"<p>Train a model to predict residue-residue contacts:</p> <pre><code>from synth_pdb.contact import calculate_contact_map\n\n# Generate training data\npeptide = gen.generate()\ncoords = peptide.structure.coord\ncontact_map = calculate_contact_map(coords, cutoff=8.0)\n# Train model: sequence \u2192 contact_map\n</code></pre>"},{"location":"guides/ml-researchers/#4-dynamics-prediction","title":"4. Dynamics Prediction","text":"<p>Train a model to predict NMR relaxation rates:</p> <pre><code># Generate structure + dynamics data\nsynth-pdb --length 30 --gen-relax --output structure.pdb\n\n# Parse NEF file for R1, R2, NOE values\n# Train model: structure \u2192 dynamics\n</code></pre>"},{"location":"guides/ml-researchers/#tutorials","title":"Tutorials","text":"<p>Explore these interactive notebooks:</p> <ul> <li>ML Handover Demo - Benchmark and integration</li> <li>Hard Decoy Challenge - Negative sampling strategies</li> <li>Dataset Factory - Bulk generation workflows</li> <li>Neural NMR Pipeline - Multi-modal training</li> </ul>"},{"location":"guides/ml-researchers/#framework-specific-examples","title":"Framework-Specific Examples","text":"<ul> <li>JAX Handover</li> <li>PyTorch Handover</li> <li>MLX Handover (Apple Silicon)</li> </ul>"},{"location":"guides/ml-researchers/#performance-tips","title":"Performance Tips","text":"<p>Maximize Throughput</p> <ol> <li>Use <code>full_atom=False</code> for backbone-only generation (10x faster)</li> <li>Disable minimization during training data generation</li> <li>Use Numba for 50-100x speedup on geometry calculations</li> <li>Batch size: Aim for 1000-10000 structures per batch</li> <li>Multiprocessing: Use <code>--mode dataset</code> with automatic parallelization</li> </ol>"},{"location":"guides/ml-researchers/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference: batch_generator</li> <li>Examples: Advanced Features</li> <li>Scientific Background: Ramachandran Plots</li> </ul>"},{"location":"guides/nmr-spectroscopists/","title":"nmr spectroscopists","text":"<p>Documentation coming soon.</p>"},{"location":"science/biophysics/","title":"Biophysics Fundamentals","text":"<p>Understanding the basic principles of protein biophysics is crucial for effectively utilizing <code>synth-pdb</code> and interpreting the structures it generates. This section provides an overview of key biophysical concepts that govern protein structure and stability.</p>"},{"location":"science/biophysics/#what-is-protein-biophysics","title":"What is Protein Biophysics?","text":"<p>Protein biophysics is an interdisciplinary field that applies the principles and methods of physics to study proteins. It investigates their structure, dynamics, folding, stability, and interactions at molecular and atomic levels. For <code>synth-pdb</code>, these principles are fundamental to generating realistic and energetically plausible protein structures.</p>"},{"location":"science/biophysics/#protein-structure-hierarchy","title":"Protein Structure Hierarchy","text":"<p>Proteins exhibit a hierarchical organization, which is essential for their function:</p> <ul> <li>Primary Structure: The linear sequence of amino acids linked by peptide bonds. This sequence dictates all higher-order structures.</li> <li>Secondary Structure: Local folding patterns of the polypeptide chain, primarily stabilized by hydrogen bonds between backbone atoms. Common examples include alpha-helices and beta-sheets.</li> <li>Tertiary Structure: The overall three-dimensional shape of a single polypeptide chain, resulting from interactions between amino acid side chains. These interactions include hydrophobic effects, hydrogen bonds, salt bridges, and disulfide bonds.</li> <li>Quaternary Structure: The arrangement of multiple polypeptide chains (subunits) in a multi-subunit protein complex.</li> </ul>"},{"location":"science/biophysics/#forces-stabilizing-protein-structure","title":"Forces Stabilizing Protein Structure","text":"<p>The intricate 3D structure of a protein is maintained by a delicate balance of various non-covalent interactions and, occasionally, covalent bonds:</p> <ul> <li>Hydrophobic Effect: The primary driving force for protein folding, where nonpolar amino acid side chains cluster together in the protein's interior to minimize contact with water.</li> <li>Hydrogen Bonds: Electrostatic attractions between a hydrogen atom covalently linked to a highly electronegative atom (like oxygen or nitrogen) and another electronegative atom. These are crucial for secondary structure formation and overall stability.</li> <li>Van der Waals Interactions: Weak, transient attractions between all atoms due to temporary fluctuations in electron distribution. Though individually weak, their cumulative effect over many atoms contributes significantly to stability.</li> <li>Electrostatic Interactions (Salt Bridges): Interactions between oppositely charged amino acid side chains (e.g., lysine and aspartate).</li> <li>Disulfide Bonds: Covalent bonds formed between the thiol groups of two cysteine residues. These provide significant structural rigidity, particularly in extracellular proteins.</li> </ul>"},{"location":"science/biophysics/#conformational-space-and-energy-landscapes","title":"Conformational Space and Energy Landscapes","text":"<p>Proteins can theoretically adopt an astronomical number of conformations. However, in reality, they fold into a specific, stable 3D structure that corresponds to a global or local minimum on their energy landscape. <code>synth-pdb</code> aims to explore this conformational space to generate diverse yet energetically favorable structures, often guided by physical potential functions.</p>"},{"location":"science/biophysics/#relevance-to-synth-pdb","title":"Relevance to <code>synth-pdb</code>","text":"<p><code>synth-pdb</code> incorporates these biophysical principles to:</p> <ul> <li>Generate Realistic Folds: Ensure that generated structures adhere to fundamental principles of protein folding and stability.</li> <li>Parameterize Interactions: Allow users to explore the impact of different biophysical parameters on protein conformation.</li> <li>Evaluate Structures: Provide a framework for assessing the energetic quality and structural plausibility of generated protein models.</li> </ul>"},{"location":"science/biophysics/#further-reading","title":"Further Reading","text":"<p>For a deeper dive into protein biophysics, consider textbooks on physical biochemistry or structural biology.</p>"},{"location":"science/energy-minimization/","title":"energy minimization","text":"<p>Documentation coming soon.</p>"},{"location":"science/nerf-geometry/","title":"NeRF Geometry","text":"<p>The NeRF (Natural Extension Reference Frame) algorithm is a fundamental technique for building 3D molecular structures from internal coordinates.</p>"},{"location":"science/nerf-geometry/#overview","title":"Overview","text":"<p>NeRF converts internal coordinates (bond lengths, angles, and dihedrals) into 3D Cartesian coordinates. This is essential for protein structure generation because:</p> <ul> <li>Compact representation: Internal coordinates are more compact than Cartesian coordinates</li> <li>Chemical validity: Bond lengths and angles follow known chemical constraints</li> <li>Efficient sampling: Sampling in dihedral space is more efficient than Cartesian space</li> </ul>"},{"location":"science/nerf-geometry/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"science/nerf-geometry/#internal-coordinates","title":"Internal Coordinates","text":"<p>For a chain of atoms, we define:</p> <ol> <li>Bond Length (\\(r\\)): Distance between consecutive atoms</li> <li> <p>Example: N-CA bond = 1.46 \u00c5</p> </li> <li> <p>Bond Angle (\\(\\theta\\)): Angle formed by three consecutive atoms</p> </li> <li> <p>Example: N-CA-C angle = 111\u00b0</p> </li> <li> <p>Dihedral Angle (\\(\\phi\\)): Torsion angle formed by four consecutive atoms</p> </li> <li>Example: Phi (\u03c6) and Psi (\u03c8) backbone dihedrals</li> </ol>"},{"location":"science/nerf-geometry/#the-nerf-algorithm","title":"The NeRF Algorithm","text":"<p>Given three atoms A, B, C with known positions, and internal coordinates for a new atom D:</p> <ul> <li>Bond length: \\(r_{CD}\\)</li> <li>Bond angle: \\(\\theta_{BCD}\\)</li> <li>Dihedral angle: \\(\\phi_{ABCD}\\)</li> </ul> <p>The algorithm computes the position of D as follows:</p> <ol> <li>Create local coordinate system at C:</li> <li>z-axis: Along the C\u2192B direction</li> <li>x-axis: In the plane of A-B-C, perpendicular to z</li> <li> <p>y-axis: Perpendicular to both x and z</p> </li> <li> <p>Place D in local coordinates:    <pre><code>D_local = [\n    r * sin(\u03b8) * cos(\u03c6),\n    r * sin(\u03b8) * sin(\u03c6),\n    r * cos(\u03b8)\n]\n</code></pre></p> </li> <li> <p>Transform to global coordinates:</p> </li> <li>Apply rotation matrix to align local axes with global axes</li> <li>Translate by position of C</li> </ol>"},{"location":"science/nerf-geometry/#application-to-proteins","title":"Application to Proteins","text":""},{"location":"science/nerf-geometry/#backbone-construction","title":"Backbone Construction","text":"<p>The protein backbone is built iteratively:</p> <pre><code>N\u2081 \u2192 CA\u2081 \u2192 C\u2081 \u2192 N\u2082 \u2192 CA\u2082 \u2192 C\u2082 \u2192 ...\n</code></pre> <p>Each atom is placed using NeRF with: - Fixed bond lengths: From crystallographic data - Fixed bond angles: From chemical constraints - Variable dihedrals: Sampled from Ramachandran distributions</p>"},{"location":"science/nerf-geometry/#side-chain-placement","title":"Side-Chain Placement","text":"<p>Side-chains are added using: - Rotamer libraries: Pre-computed favorable conformations - NeRF algorithm: To place each side-chain atom - Steric constraints: To avoid clashes</p>"},{"location":"science/nerf-geometry/#implementation-in-synth-pdb","title":"Implementation in synth-pdb","text":"<p>The <code>geometry</code> module implements NeRF for protein construction:</p> <pre><code>from synth_pdb.geometry import place_atom\n\n# Place a new atom given three reference atoms\nnew_position = place_atom(\n    atom_a=pos_a,  # Position of atom A\n    atom_b=pos_b,  # Position of atom B\n    atom_c=pos_c,  # Position of atom C\n    bond_length=1.52,  # C-C bond\n    bond_angle=111.0,  # degrees\n    dihedral=180.0     # degrees\n)\n</code></pre>"},{"location":"science/nerf-geometry/#advantages","title":"Advantages","text":"<ol> <li>Chemical validity: Structures automatically satisfy bond constraints</li> <li>Efficiency: O(n) complexity for n atoms</li> <li>Interpretability: Dihedrals directly correspond to conformational freedom</li> <li>Sampling: Easy to sample conformational space</li> </ol>"},{"location":"science/nerf-geometry/#limitations","title":"Limitations","text":"<ol> <li>Rigid geometry: Bond lengths and angles are typically fixed</li> <li>Sequential construction: Requires a defined atom ordering</li> <li>Numerical precision: Small errors can accumulate in long chains</li> </ol>"},{"location":"science/nerf-geometry/#see-also","title":"See Also","text":"<ul> <li>Ramachandran Plots - Dihedral angle distributions</li> <li>Rotamer Libraries - Side-chain conformations</li> <li>geometry Module - Implementation details</li> </ul>"},{"location":"science/nerf-geometry/#references","title":"References","text":"<ol> <li>Parsons, J., et al. (2005). \"Practical conversion from torsion space to Cartesian space for in silico protein synthesis.\" Journal of Computational Chemistry, 26(10), 1063-1068.</li> <li>Coutsias, E. A., et al. (2004). \"Using quaternions to calculate RMSD.\" Journal of Computational Chemistry, 25(15), 1849-1857.</li> </ol>"},{"location":"science/nmr-theory/","title":"nmr theory","text":"<p>Documentation coming soon.</p>"},{"location":"science/ramachandran/","title":"ramachandran","text":"<p>Documentation coming soon.</p>"},{"location":"science/rotamers/","title":"rotamers","text":"<p>Documentation coming soon.</p>"},{"location":"tutorials/dataset_factory/","title":"\ud83d\udcc1 Bulk Dataset Factory: Beyond the Memory Wall \ud83e\udd16","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\n# Ensure the local synth_pdb source code is prioritized if running from the repo\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb torch numpy matplotlib py3Dmol')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  # Ensure the local synth_pdb source code is prioritized if running from the repo try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb torch numpy matplotlib py3Dmol')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport time\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nimport matplotlib.pyplot as plt\nimport py3Dmol\nfrom synth_pdb.batch_generator import BatchedGenerator, BatchedPeptide\n\nprint(\"Libraries Loaded. Accelerating with PyTorch! \ud83d\ude80\")\n</pre> import numpy as np import time import torch from torch.utils.data import Dataset, DataLoader import matplotlib.pyplot as plt import py3Dmol from synth_pdb.batch_generator import BatchedGenerator, BatchedPeptide  print(\"Libraries Loaded. Accelerating with PyTorch! \ud83d\ude80\") In\u00a0[\u00a0]: Copied! <pre>n_samples = 10000\n# FIX: Use explicit hyphenation for the whole sequence to avoid 'METALA' merging errors\nsequence = \"-\".join([\"ALA-GLY-SER-LEU-VAL-ILE-MET\"] * 4) # 28 residues\n\nprint(f\"\ud83d\ude80 Generating {n_samples} structures...\")\nstart = time.time()\n\ngenerator = BatchedGenerator(sequence, n_batch=n_samples, full_atom=False)\nbatch = generator.generate_batch(drift=5.0)\n\nelapsed = time.time() - start\nprint(f\"\u2705 Done! {n_samples} structures generated in {elapsed:.3f}s\")\nprint(f\"Throughput: {n_samples/elapsed:.0f} structures/sec\")\n</pre> n_samples = 10000 # FIX: Use explicit hyphenation for the whole sequence to avoid 'METALA' merging errors sequence = \"-\".join([\"ALA-GLY-SER-LEU-VAL-ILE-MET\"] * 4) # 28 residues  print(f\"\ud83d\ude80 Generating {n_samples} structures...\") start = time.time()  generator = BatchedGenerator(sequence, n_batch=n_samples, full_atom=False) batch = generator.generate_batch(drift=5.0)  elapsed = time.time() - start print(f\"\u2705 Done! {n_samples} structures generated in {elapsed:.3f}s\") print(f\"Throughput: {n_samples/elapsed:.0f} structures/sec\") In\u00a0[\u00a0]: Copied! <pre># Calculate the variance of CA positions across the batch\nvariance = np.var(batch.coords, axis=0).mean(axis=1)\n\nplt.figure(figsize=(10, 5))\nplt.plot(variance, color='#667eea', linewidth=3, label=\"Positional Variance\")\nplt.fill_between(range(len(variance)), variance, alpha=0.2, color='#667eea')\nplt.title(\"The Entropy Profile: Data Diversity across the Chain\")\nplt.xlabel(\"Residue Number\")\nplt.ylabel(\"Variance (\u00c5\u00b2)\")\nplt.grid(alpha=0.3)\nplt.legend()\nplt.show()\n\nprint(\"Educational Insight: Notice how variance typically increases at the 'tail' of the peptide?\")\nprint(\"This is the 'Propagating Error' of structural drift\u2014a key feature for generating negative samples.\")\n</pre> # Calculate the variance of CA positions across the batch variance = np.var(batch.coords, axis=0).mean(axis=1)  plt.figure(figsize=(10, 5)) plt.plot(variance, color='#667eea', linewidth=3, label=\"Positional Variance\") plt.fill_between(range(len(variance)), variance, alpha=0.2, color='#667eea') plt.title(\"The Entropy Profile: Data Diversity across the Chain\") plt.xlabel(\"Residue Number\") plt.ylabel(\"Variance (\u00c5\u00b2)\") plt.grid(alpha=0.3) plt.legend() plt.show()  print(\"Educational Insight: Notice how variance typically increases at the 'tail' of the peptide?\") print(\"This is the 'Propagating Error' of structural drift\u2014a key feature for generating negative samples.\") In\u00a0[\u00a0]: Copied! <pre>try:\n    view = py3Dmol.view(width=800, height=400)\n    view.setBackgroundColor(\"#fdfdfd\")\n    colors = [\"#ff9999\", \"#66b3ff\", \"#99ff99\", \"#ffcc99\", \"#c2c2f0\"]\n\n    for i in range(5):\n        # 1. Clean and mask coordinates with strict zero-tolerance\n        c = batch.coords[i].copy()\n        mask = np.any(np.abs(c) &gt; 1e-4, axis=1) # Strip zeros and ghost atoms\n        c_clean = c[mask]\n        \n        if len(c_clean) == 0: continue\n        \n        # 2. Individual Centering (Per-Model Anchor)\n        # Using CA centroid for much better stability than min/max\n        ca_idxs = [j for j, name in enumerate(batch.atom_names) if name == \"CA\"]\n        valid_ca = [idx for idx in ca_idxs if mask[idx]]\n        if valid_ca:\n            center = c[valid_ca].mean(axis=0)\n        else:\n            center = c_clean.mean(axis=0)\n            \n        c_centered = c_clean - center\n        \n        p_tmp = BatchedPeptide(\n            c_centered[np.newaxis, ...], \n            batch.sequence, \n            np.array(batch.atom_names)[mask].tolist(), \n            np.array(batch.residue_indices)[mask].tolist()\n        )\n        \n        view.addModel(p_tmp.to_pdb(0), 'pdb')\n        # HIGH-VISIBILITY STYLE: Large Spheres (radius 0.3) + Thick Sticks\n        view.setStyle({'model': i}, {\n            \"cartoon\": {\"color\": colors[i], \"opacity\": 0.5}, \n            \"stick\": {\"color\": colors[i], \"radius\": 0.3}, \n            \"sphere\": {\"color\": colors[i], \"scale\": 0.3}\n        })\n\n    # 3. Aggressive manual zoom targeting model 0 to ensure viewport is filled\n    view.zoomTo({'model': 0})\n    view.zoom(2.0)\n    view.center()\n    view.show()\n    \n    # Diagnostic Info to prove sanity\n    print(f\"\u2705 Ensemble Visualized with PDB Column-Shift Guard.\")\n    print(f\"Residue 1 Name: '{batch.sequence[0]}' | Residue 7 Name: '{batch.sequence[6]}'\")\n    \nexcept Exception as e:\n    print(f\"3D Viewer Error: {e}\")\n</pre> try:     view = py3Dmol.view(width=800, height=400)     view.setBackgroundColor(\"#fdfdfd\")     colors = [\"#ff9999\", \"#66b3ff\", \"#99ff99\", \"#ffcc99\", \"#c2c2f0\"]      for i in range(5):         # 1. Clean and mask coordinates with strict zero-tolerance         c = batch.coords[i].copy()         mask = np.any(np.abs(c) &gt; 1e-4, axis=1) # Strip zeros and ghost atoms         c_clean = c[mask]                  if len(c_clean) == 0: continue                  # 2. Individual Centering (Per-Model Anchor)         # Using CA centroid for much better stability than min/max         ca_idxs = [j for j, name in enumerate(batch.atom_names) if name == \"CA\"]         valid_ca = [idx for idx in ca_idxs if mask[idx]]         if valid_ca:             center = c[valid_ca].mean(axis=0)         else:             center = c_clean.mean(axis=0)                      c_centered = c_clean - center                  p_tmp = BatchedPeptide(             c_centered[np.newaxis, ...],              batch.sequence,              np.array(batch.atom_names)[mask].tolist(),              np.array(batch.residue_indices)[mask].tolist()         )                  view.addModel(p_tmp.to_pdb(0), 'pdb')         # HIGH-VISIBILITY STYLE: Large Spheres (radius 0.3) + Thick Sticks         view.setStyle({'model': i}, {             \"cartoon\": {\"color\": colors[i], \"opacity\": 0.5},              \"stick\": {\"color\": colors[i], \"radius\": 0.3},              \"sphere\": {\"color\": colors[i], \"scale\": 0.3}         })      # 3. Aggressive manual zoom targeting model 0 to ensure viewport is filled     view.zoomTo({'model': 0})     view.zoom(2.0)     view.center()     view.show()          # Diagnostic Info to prove sanity     print(f\"\u2705 Ensemble Visualized with PDB Column-Shift Guard.\")     print(f\"Residue 1 Name: '{batch.sequence[0]}' | Residue 7 Name: '{batch.sequence[6]}'\")      except Exception as e:     print(f\"3D Viewer Error: {e}\") In\u00a0[\u00a0]: Copied! <pre>os.makedirs(\"dataset_factory\", exist_ok=True)\ndataset_path = \"dataset_factory/batch_001.npz\"\n\nprint(\"Saving to compressed NPZ...\")\nnp.savez_compressed(\n    dataset_path,\n    coords=batch.coords,\n    sequence=np.array([sequence] * n_samples)\n)\n\n# Benchmark Loading\nstart_npz = time.time()\ntensor_npz = torch.from_numpy(np.load(dataset_path)['coords'])\nnpz_time = time.time() - start_npz\n\nprint(f\"\u2705 NPZ Load (10k samples): {npz_time:.4f}s\")\n</pre> os.makedirs(\"dataset_factory\", exist_ok=True) dataset_path = \"dataset_factory/batch_001.npz\"  print(\"Saving to compressed NPZ...\") np.savez_compressed(     dataset_path,     coords=batch.coords,     sequence=np.array([sequence] * n_samples) )  # Benchmark Loading start_npz = time.time() tensor_npz = torch.from_numpy(np.load(dataset_path)['coords']) npz_time = time.time() - start_npz  print(f\"\u2705 NPZ Load (10k samples): {npz_time:.4f}s\") In\u00a0[\u00a0]: Copied! <pre>class SyntheticProteinDataset(Dataset):\n    def __init__(self, npz_path):\n        data = np.load(npz_path)\n        self.coords = torch.from_numpy(data['coords']).float()\n        \n    def __len__(self):\n        return len(self.coords)\n        \n    def __getitem__(self, idx):\n        return self.coords[idx]\n\nds = SyntheticProteinDataset(dataset_path)\nloader = DataLoader(ds, batch_size=64, shuffle=True)\n\nsample_batch = next(iter(loader))\nprint(f\"Success! Batch Shape: {sample_batch.shape} (Ready for Neural Network training)\")\n</pre> class SyntheticProteinDataset(Dataset):     def __init__(self, npz_path):         data = np.load(npz_path)         self.coords = torch.from_numpy(data['coords']).float()              def __len__(self):         return len(self.coords)              def __getitem__(self, idx):         return self.coords[idx]  ds = SyntheticProteinDataset(dataset_path) loader = DataLoader(ds, batch_size=64, shuffle=True)  sample_batch = next(iter(loader)) print(f\"Success! Batch Shape: {sample_batch.shape} (Ready for Neural Network training)\")"},{"location":"tutorials/dataset_factory/#bulk-dataset-factory-beyond-the-memory-wall","title":"\ud83d\udcc1 Bulk Dataset Factory: Beyond the Memory Wall \ud83e\udd16\u00b6","text":"<p>Objective: Master the transition from \"Single-Protein\" bioinformatics to \"Tensor-Driven\" AI research.</p>"},{"location":"tutorials/dataset_factory/#the-educational-mindset-shift","title":"\ud83e\udde0 The Educational Mindset Shift\u00b6","text":"<p>Traditional structural biology focuses on the PDB File\u2014a static, human-readable text record. Modern AI (like AlphaFold-3 or ESM-Fold) requires a Tensor\u2014a massive, multi-dimensional array of numbers.</p> <p>In this lab, we break through the \"Memory Wall\": the bottleneck where AI models spend more time reading files than actually learning biology.</p> <p>We will cover:</p> <ol> <li>Vectorized Generation: Producing 10,000 unique structures in milliseconds.</li> <li>The Tensor Envelope: Visualizing the structural diversity of your dataset.</li> <li>Zero-Copy NPZ Pipelines: Feeding binary data directly into high-performance GPUs.</li> <li>PyTorch Integration: Building a production-ready <code>DataLoader</code>.</li> </ol>"},{"location":"tutorials/dataset_factory/#1-high-speed-generation-10000-structures","title":"1. High-Speed Generation: 10,000 Structures\u00b6","text":"<p>We leverage Numba-optimized vectorization. Instead of generating one CA atom at a time, we treat the entire batch as a single 3D tensor operation.</p>"},{"location":"tutorials/dataset_factory/#2-visualizing-structural-diversity-statistical-plot","title":"2. Visualizing Structural Diversity (Statistical Plot)\u00b6","text":"<p>A dataset is only as good as its diversity. If all 10,000 structures look the same, the model learns nothing. Let's visualize the \"Atomic Variance\" across our batch.</p>"},{"location":"tutorials/dataset_factory/#3-interactive-3d-ensemble-view","title":"3. Interactive 3D Ensemble View\u00b6","text":"<p>Let's overlay the first 5 structures in the batch to see the \"Envelope\" of noise we've created.</p>"},{"location":"tutorials/dataset_factory/#4-binary-export-npz-vs-legacy-text-pdb","title":"4. Binary Export (NPZ) vs. Legacy Text (PDB)\u00b6","text":"<p>Why save to NPZ? It's not just about size; it's about Zero-Copy loading.</p>"},{"location":"tutorials/dataset_factory/#5-production-pytorch-dataloader","title":"5. Production PyTorch DataLoader\u00b6","text":"<p>The final piece of the pipeline is the <code>DataLoader</code>, which handles batching, shuffling, and multi-threaded loading.</p>"},{"location":"tutorials/dataset_factory/#next-steps","title":"\ud83c\udfc6 Next Steps\u00b6","text":"<ol> <li>Modify the <code>drift</code> parameter in Section 1. How does it change the Variance Plot in Section 2?</li> <li>Try generating a batch with <code>full_atom=True</code>. How does it affect the NPZ file size?</li> </ol> <p>Mastering the Data Plane is 80% of successful AI engineering. Now go build some biology! \ud83e\uddec\ud83e\udd16</p>"},{"location":"tutorials/folding_landscape/","title":"\ud83c\udfd4\ufe0f The Live Folding Landscape","text":"In\u00a0[\u00a0]: Copied! <pre># \ud83d\udd27 Environment Detection &amp; Setup (Works in VS Code + Google Colab)\nimport sys\nimport os\n\n# Detect environment\nIN_COLAB = 'google.colab' in sys.modules\n\nif IN_COLAB:\n    print(\"\ud83c\udf10 Running in Google Colab\")\n    \n    # Install synth-pdb if not already installed\n    try:\n        import synth_pdb\n        print(\"   \u2705 synth-pdb already installed\")\n    except ImportError:\n        print(\"   \ud83d\udce6 Installing synth-pdb...\")\n        !pip install -q synth-pdb\n        print(\"   \u2705 Installation complete\")\n    \n    # Colab uses 'notebook' renderer for Plotly\n    import plotly.io as pio\n    pio.renderers.default = 'colab'\n    \nelse:\n    print(\"\ud83d\udcbb Running in local Jupyter environment (VS Code/JupyterLab)\")\n    # Add parent directory to path for local development\n    sys.path.append(os.path.abspath('../../'))\n\nprint(\"\u2705 Environment configured successfully!\")\n</pre> # \ud83d\udd27 Environment Detection &amp; Setup (Works in VS Code + Google Colab) import sys import os  # Detect environment IN_COLAB = 'google.colab' in sys.modules  if IN_COLAB:     print(\"\ud83c\udf10 Running in Google Colab\")          # Install synth-pdb if not already installed     try:         import synth_pdb         print(\"   \u2705 synth-pdb already installed\")     except ImportError:         print(\"   \ud83d\udce6 Installing synth-pdb...\")         !pip install -q synth-pdb         print(\"   \u2705 Installation complete\")          # Colab uses 'notebook' renderer for Plotly     import plotly.io as pio     pio.renderers.default = 'colab'      else:     print(\"\ud83d\udcbb Running in local Jupyter environment (VS Code/JupyterLab)\")     # Add parent directory to path for local development     sys.path.append(os.path.abspath('../../'))  print(\"\u2705 Environment configured successfully!\") In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, HTML, clear_output\nimport ipywidgets as widgets\nfrom ipywidgets import interact, IntSlider, FloatSlider, Dropdown\nimport os, sys, numpy as np\nimport py3Dmol\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport plotly.io as pio\n\n# --- UNIVERSAL SETUP ---\nfrom synth_pdb import PeptideGenerator, EnergyMinimizer, PDBValidator, PeptideResult\nimport biotite.structure as struc\n\n# Initialize variables\nX, Y, Z = np.array([]), np.array([]), np.array([])\ntraj_phi, traj_psi, energies = np.array([]), np.array([]), []\ntrajectory_structs = []\n\n# Custom color scheme for scientific visualization\nENERGY_COLORSCALE = 'Viridis'  # Perceptually uniform, colorblind-friendly\nTRAJECTORY_COLOR = '#FF6B35'   # Vibrant orange for contrast\n\nprint(\"\u2705 Environment Ready | synth-pdb v1.0 | Enhanced Visualization Mode\")\n</pre> from IPython.display import display, HTML, clear_output import ipywidgets as widgets from ipywidgets import interact, IntSlider, FloatSlider, Dropdown import os, sys, numpy as np import py3Dmol import plotly.graph_objects as go from plotly.subplots import make_subplots import plotly.io as pio  # --- UNIVERSAL SETUP --- from synth_pdb import PeptideGenerator, EnergyMinimizer, PDBValidator, PeptideResult import biotite.structure as struc  # Initialize variables X, Y, Z = np.array([]), np.array([]), np.array([]) traj_phi, traj_psi, energies = np.array([]), np.array([]), [] trajectory_structs = []  # Custom color scheme for scientific visualization ENERGY_COLORSCALE = 'Viridis'  # Perceptually uniform, colorblind-friendly TRAJECTORY_COLOR = '#FF6B35'   # Vibrant orange for contrast  print(\"\u2705 Environment Ready | synth-pdb v1.0 | Enhanced Visualization Mode\") In\u00a0[\u00a0]: Copied! <pre>minimizer = EnergyMinimizer()\n\ndef get_energy_for_angles(phi, psi, sequence=\"ALA-ALA-ALA\"):\n    \"\"\"Calculate energy for a given phi/psi of the central residue.\"\"\"\n    gen = PeptideGenerator(sequence)\n    phis = [-57.0, phi, -57.0]  # Alpha helix flanking\n    psis = [-47.0, psi, -47.0]\n    \n    try:\n        res = gen.generate(phi_list=phis, psi_list=psis)\n        energy = minimizer.calculate_energy(res)\n        return energy if energy is not None else 10000.0\n    except:\n        return 10000.0\n\n# Generate energy grid\nres_grid = 15\nphis = np.linspace(-180, 180, res_grid)\npsis = np.linspace(-180, 180, res_grid)\nX, Y = np.meshgrid(phis, psis)\nZ = np.zeros_like(X)\n\nprint(\"\ud83d\udd04 Generating Energy Landscape...\")\nprint(\"   This will sample 225 conformations across \u03c6/\u03c8 space\")\nprint(\"   \" + \"=\"*50)\n\nfor i in range(res_grid):\n    for j in range(res_grid):\n        val = get_energy_for_angles(X[i,j], Y[i,j])\n        Z[i,j] = min(val, 5000)  # Cap extreme energies\n    \n    # Progress indicator\n    progress = (i + 1) / res_grid * 100\n    bar_length = int(progress / 2)\n    bar = \"\u2588\" * bar_length + \"\u2591\" * (50 - bar_length)\n    print(f\"\\r   [{bar}] {progress:.0f}%\", end=\"\")\n\nprint(\"\\n   \" + \"=\"*50)\nprint(f\"\u2705 Energy Landscape Complete!\")\nprint(f\"   Min Energy: {Z.min():.1f} kJ/mol\")\nprint(f\"   Max Energy: {Z.max():.1f} kJ/mol\")\nprint(f\"   Energy Range: {Z.max() - Z.min():.1f} kJ/mol\")\n</pre> minimizer = EnergyMinimizer()  def get_energy_for_angles(phi, psi, sequence=\"ALA-ALA-ALA\"):     \"\"\"Calculate energy for a given phi/psi of the central residue.\"\"\"     gen = PeptideGenerator(sequence)     phis = [-57.0, phi, -57.0]  # Alpha helix flanking     psis = [-47.0, psi, -47.0]          try:         res = gen.generate(phi_list=phis, psi_list=psis)         energy = minimizer.calculate_energy(res)         return energy if energy is not None else 10000.0     except:         return 10000.0  # Generate energy grid res_grid = 15 phis = np.linspace(-180, 180, res_grid) psis = np.linspace(-180, 180, res_grid) X, Y = np.meshgrid(phis, psis) Z = np.zeros_like(X)  print(\"\ud83d\udd04 Generating Energy Landscape...\") print(\"   This will sample 225 conformations across \u03c6/\u03c8 space\") print(\"   \" + \"=\"*50)  for i in range(res_grid):     for j in range(res_grid):         val = get_energy_for_angles(X[i,j], Y[i,j])         Z[i,j] = min(val, 5000)  # Cap extreme energies          # Progress indicator     progress = (i + 1) / res_grid * 100     bar_length = int(progress / 2)     bar = \"\u2588\" * bar_length + \"\u2591\" * (50 - bar_length)     print(f\"\\r   [{bar}] {progress:.0f}%\", end=\"\")  print(\"\\n   \" + \"=\"*50) print(f\"\u2705 Energy Landscape Complete!\") print(f\"   Min Energy: {Z.min():.1f} kJ/mol\") print(f\"   Max Energy: {Z.max():.1f} kJ/mol\") print(f\"   Energy Range: {Z.max() - Z.min():.1f} kJ/mol\") In\u00a0[\u00a0]: Copied! <pre>sequence = \"ALA-ALA-ALA-ALA-ALA\"\ngen = PeptideGenerator(sequence)\nres = gen.generate(conformation=\"random\")\n\ntrajectory_structs = []\nenergies = []\nphi_psi_history = []\n\nvalidator = PDBValidator(res.pdb)\n\nprint(\"\ud83d\udd25 Starting Folding Simulation...\")\nprint(\"   Peptide: 5\u00d7Alanine (Poly-A)\")\nprint(\"   \" + \"=\"*60)\n\nimport tempfile\n\nfor step in range(15):\n    # Energy minimization\n    with tempfile.NamedTemporaryFile(suffix='.pdb', mode='w', delete=False) as f_in:\n        f_in.write(res.pdb)\n        f_in.close()\n        with tempfile.NamedTemporaryFile(suffix='.pdb', delete=False) as f_out:\n            f_out.close()\n            minimizer.minimize(f_in.name, f_out.name, max_iterations=20)\n            with open(f_out.name, 'r') as r:\n                updated_pdb = r.read()\n            res = PeptideResult(updated_pdb)\n            os.unlink(f_in.name)\n            os.unlink(f_out.name)\n    \n    # Record trajectory\n    trajectory_structs.append(res.structure.copy())\n    current_energy = minimizer.calculate_energy(res)\n    energies.append(current_energy)\n    \n    # Track central residue angles\n    angles = validator.calculate_dihedrals(res)\n    phi_psi_history.append([angles['phi'][2], angles['psi'][2]])\n    \n    # Progress with energy display\n    energy_change = energies[-1] - energies[-2] if len(energies) &gt; 1 else 0\n    arrow = \"\u2193\" if energy_change &lt; 0 else \"\u2191\" if energy_change &gt; 0 else \"\u2192\"\n    print(f\"   Step {step+1:2d}/15 | Energy: {energies[-1]:7.2f} kJ/mol {arrow} \u0394={energy_change:+6.2f}\")\n\ntraj_phi = np.array([p[0] for p in phi_psi_history])\ntraj_psi = np.array([p[1] for p in phi_psi_history])\n\nprint(\"   \" + \"=\"*60)\nprint(f\"\u2705 Folding Complete!\")\nprint(f\"   Initial Energy: {energies[0]:.2f} kJ/mol\")\nprint(f\"   Final Energy:   {energies[-1]:.2f} kJ/mol\")\nprint(f\"   Total \u0394E:       {energies[-1] - energies[0]:.2f} kJ/mol\")\nprint(f\"   Final \u03c6/\u03c8:      ({traj_phi[-1]:.1f}\u00b0, {traj_psi[-1]:.1f}\u00b0)\")\n</pre> sequence = \"ALA-ALA-ALA-ALA-ALA\" gen = PeptideGenerator(sequence) res = gen.generate(conformation=\"random\")  trajectory_structs = [] energies = [] phi_psi_history = []  validator = PDBValidator(res.pdb)  print(\"\ud83d\udd25 Starting Folding Simulation...\") print(\"   Peptide: 5\u00d7Alanine (Poly-A)\") print(\"   \" + \"=\"*60)  import tempfile  for step in range(15):     # Energy minimization     with tempfile.NamedTemporaryFile(suffix='.pdb', mode='w', delete=False) as f_in:         f_in.write(res.pdb)         f_in.close()         with tempfile.NamedTemporaryFile(suffix='.pdb', delete=False) as f_out:             f_out.close()             minimizer.minimize(f_in.name, f_out.name, max_iterations=20)             with open(f_out.name, 'r') as r:                 updated_pdb = r.read()             res = PeptideResult(updated_pdb)             os.unlink(f_in.name)             os.unlink(f_out.name)          # Record trajectory     trajectory_structs.append(res.structure.copy())     current_energy = minimizer.calculate_energy(res)     energies.append(current_energy)          # Track central residue angles     angles = validator.calculate_dihedrals(res)     phi_psi_history.append([angles['phi'][2], angles['psi'][2]])          # Progress with energy display     energy_change = energies[-1] - energies[-2] if len(energies) &gt; 1 else 0     arrow = \"\u2193\" if energy_change &lt; 0 else \"\u2191\" if energy_change &gt; 0 else \"\u2192\"     print(f\"   Step {step+1:2d}/15 | Energy: {energies[-1]:7.2f} kJ/mol {arrow} \u0394={energy_change:+6.2f}\")  traj_phi = np.array([p[0] for p in phi_psi_history]) traj_psi = np.array([p[1] for p in phi_psi_history])  print(\"   \" + \"=\"*60) print(f\"\u2705 Folding Complete!\") print(f\"   Initial Energy: {energies[0]:.2f} kJ/mol\") print(f\"   Final Energy:   {energies[-1]:.2f} kJ/mol\") print(f\"   Total \u0394E:       {energies[-1] - energies[0]:.2f} kJ/mol\") print(f\"   Final \u03c6/\u03c8:      ({traj_phi[-1]:.1f}\u00b0, {traj_psi[-1]:.1f}\u00b0)\") In\u00a0[\u00a0]: Copied! <pre>if len(X) == 0 or len(traj_phi) == 0:\n    print(\"\u26a0\ufe0f  Please run the previous cells first to generate data.\")\nelse:\n    # Create figure with Ramachandran annotations\n    fig = go.Figure()\n    \n    # Energy surface\n    fig.add_trace(go.Surface(\n        z=Z, x=X, y=Y,\n        colorscale=ENERGY_COLORSCALE,\n        opacity=0.85,\n        name='Energy Surface',\n        colorbar=dict(\n            title=\"Energy&lt;br&gt;(kJ/mol)\",\n            tickmode=\"linear\",\n            tick0=Z.min(),\n            dtick=(Z.max() - Z.min()) / 5\n        ),\n        hovertemplate='\u03c6: %{x:.1f}\u00b0&lt;br&gt;\u03c8: %{y:.1f}\u00b0&lt;br&gt;E: %{z:.1f} kJ/mol&lt;extra&gt;&lt;/extra&gt;'\n    ))\n    \n    # Folding trajectory\n    fig.add_trace(go.Scatter3d(\n        x=traj_phi, y=traj_psi, z=energies,\n        mode='markers+lines',\n        marker=dict(\n            size=8,\n            color=np.arange(len(energies)),\n            colorscale='Hot',\n            showscale=True,\n            colorbar=dict(\n                title=\"Step\",\n                x=1.15\n            ),\n            line=dict(color='white', width=2)\n        ),\n        line=dict(color=TRAJECTORY_COLOR, width=6),\n        name='Folding Path',\n        hovertemplate='Step %{marker.color}&lt;br&gt;\u03c6: %{x:.1f}\u00b0&lt;br&gt;\u03c8: %{y:.1f}\u00b0&lt;br&gt;E: %{z:.1f} kJ/mol&lt;extra&gt;&lt;/extra&gt;'\n    ))\n    \n    # Add Ramachandran region annotations\n    annotations = [\n        dict(x=-60, y=-45, z=Z.max()*0.3, text=\"\u03b1-helix\", showarrow=False,\n             font=dict(size=14, color='white'), bgcolor='rgba(0,100,200,0.7)'),\n        dict(x=-120, y=120, z=Z.max()*0.3, text=\"\u03b2-sheet\", showarrow=False,\n             font=dict(size=14, color='white'), bgcolor='rgba(200,100,0,0.7)'),\n        dict(x=-75, y=145, z=Z.max()*0.3, text=\"PPII\", showarrow=False,\n             font=dict(size=14, color='white'), bgcolor='rgba(100,200,0,0.7)')\n    ]\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text='\ud83c\udfd4\ufe0f Protein Folding Energy Landscape&lt;br&gt;&lt;sub&gt;Ramachandran Space with Folding Trajectory&lt;/sub&gt;',\n            x=0.5,\n            xanchor='center',\n            font=dict(size=20)\n        ),\n        scene=dict(\n            xaxis=dict(title='Phi \u03c6 (degrees)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),\n            yaxis=dict(title='Psi \u03c8 (degrees)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),\n            zaxis=dict(title='Potential Energy (kJ/mol)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),\n            camera=dict(\n                eye=dict(x=1.5, y=1.5, z=1.3)\n            )\n        ),\n        width=1000,\n        height=800,\n        template='plotly_dark',\n        showlegend=True,\n        legend=dict(\n            x=0.02,\n            y=0.98,\n            bgcolor='rgba(0,0,0,0.5)'\n        )\n    )\n    \n    fig.show()\n</pre> if len(X) == 0 or len(traj_phi) == 0:     print(\"\u26a0\ufe0f  Please run the previous cells first to generate data.\") else:     # Create figure with Ramachandran annotations     fig = go.Figure()          # Energy surface     fig.add_trace(go.Surface(         z=Z, x=X, y=Y,         colorscale=ENERGY_COLORSCALE,         opacity=0.85,         name='Energy Surface',         colorbar=dict(             title=\"Energy(kJ/mol)\",             tickmode=\"linear\",             tick0=Z.min(),             dtick=(Z.max() - Z.min()) / 5         ),         hovertemplate='\u03c6: %{x:.1f}\u00b0\u03c8: %{y:.1f}\u00b0E: %{z:.1f} kJ/mol'     ))          # Folding trajectory     fig.add_trace(go.Scatter3d(         x=traj_phi, y=traj_psi, z=energies,         mode='markers+lines',         marker=dict(             size=8,             color=np.arange(len(energies)),             colorscale='Hot',             showscale=True,             colorbar=dict(                 title=\"Step\",                 x=1.15             ),             line=dict(color='white', width=2)         ),         line=dict(color=TRAJECTORY_COLOR, width=6),         name='Folding Path',         hovertemplate='Step %{marker.color}\u03c6: %{x:.1f}\u00b0\u03c8: %{y:.1f}\u00b0E: %{z:.1f} kJ/mol'     ))          # Add Ramachandran region annotations     annotations = [         dict(x=-60, y=-45, z=Z.max()*0.3, text=\"\u03b1-helix\", showarrow=False,              font=dict(size=14, color='white'), bgcolor='rgba(0,100,200,0.7)'),         dict(x=-120, y=120, z=Z.max()*0.3, text=\"\u03b2-sheet\", showarrow=False,              font=dict(size=14, color='white'), bgcolor='rgba(200,100,0,0.7)'),         dict(x=-75, y=145, z=Z.max()*0.3, text=\"PPII\", showarrow=False,              font=dict(size=14, color='white'), bgcolor='rgba(100,200,0,0.7)')     ]          # Layout     fig.update_layout(         title=dict(             text='\ud83c\udfd4\ufe0f Protein Folding Energy Landscape<sub>Ramachandran Space with Folding Trajectory</sub>',             x=0.5,             xanchor='center',             font=dict(size=20)         ),         scene=dict(             xaxis=dict(title='Phi \u03c6 (degrees)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),             yaxis=dict(title='Psi \u03c8 (degrees)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),             zaxis=dict(title='Potential Energy (kJ/mol)', backgroundcolor='rgb(20,20,20)', gridcolor='rgb(50,50,50)'),             camera=dict(                 eye=dict(x=1.5, y=1.5, z=1.3)             )         ),         width=1000,         height=800,         template='plotly_dark',         showlegend=True,         legend=dict(             x=0.02,             y=0.98,             bgcolor='rgba(0,0,0,0.5)'         )     )          fig.show() In\u00a0[\u00a0]: Copied! <pre>import py3Dmol\nfrom biotite.structure.io.pdb import PDBFile\nimport io\n\nviewer_output = widgets.Output()\ninfo_label = widgets.HTML(\n    \"&lt;div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \"\n    \"color: white; padding: 15px; border-radius: 10px; font-family: sans-serif; \"\n    \"box-shadow: 0 4px 6px rgba(0,0,0,0.3);'&gt;\"\n    \"&lt;b&gt;\ud83e\uddec Select a snapshot to begin&lt;/b&gt;&lt;/div&gt;\"\n)\n\ndef display_molecule(index):\n    \"\"\"Render structure using py3Dmol with enhanced styling.\"\"\"\n    if len(trajectory_structs) == 0:\n        return\n    \n    # Update info panel\n    energy_delta = energies[index] - energies[0] if index &gt; 0 else 0\n    info_label.value = f\"\"\"\n    &lt;div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \n                color: white; padding: 15px; border-radius: 10px; \n                font-family: sans-serif; box-shadow: 0 4px 6px rgba(0,0,0,0.3);'&gt;\n        &lt;b&gt;\ud83d\udcf8 Snapshot {index}&lt;/b&gt; | \n        Energy: &lt;span style='color: #FFD700;'&gt;{energies[index]:.1f} kJ/mol&lt;/span&gt; | \n        \u0394E: &lt;span style='color: {'#00FF00' if energy_delta &lt; 0 else '#FF6B6B'};'&gt;{energy_delta:+.1f} kJ/mol&lt;/span&gt; | \n        \u03c6/\u03c8: &lt;span style='color: #87CEEB;'&gt;({traj_phi[index]:.1f}\u00b0, {traj_psi[index]:.1f}\u00b0)&lt;/span&gt;\n    &lt;/div&gt;\n    \"\"\"\n    \n    with viewer_output:\n        clear_output(wait=True)\n        \n        # Get PDB string\n        pdb_file = PDBFile()\n        pdb_file.set_structure(trajectory_structs[index])\n        sink = io.StringIO()\n        pdb_file.write(sink)\n        pdb_str = sink.getvalue()\n        \n        # Create viewer\n        view = py3Dmol.view(width=600, height=450)\n        view.addModel(pdb_str, 'pdb')\n        \n        # Enhanced styling\n        view.setStyle({\n            'stick': {'colorscheme': 'chainHetatm', 'radius': 0.15},\n            'sphere': {'scale': 0.25, 'colorscheme': 'chainHetatm'}\n        })\n        \n        view.setBackgroundColor('#1a1a1a')\n        view.zoomTo()\n        view_widget = view.show()\n        display(view_widget)\n\ndef on_slider_change(change):\n    display_molecule(change['new'])\n\n# Create slider with custom styling\nslider = widgets.IntSlider(\n    value=0,\n    min=0,\n    max=max(0, len(trajectory_structs)-1),\n    step=1,\n    description='Snapshot:',\n    continuous_update=False,\n    layout=widgets.Layout(width='600px'),\n    style={'description_width': '80px'}\n)\nslider.observe(on_slider_change, names='value')\n\n# Display\ndisplay(widgets.VBox([\n    info_label,\n    slider,\n    viewer_output\n]))\n\nif len(trajectory_structs) &gt; 0:\n    display_molecule(0)\n</pre> import py3Dmol from biotite.structure.io.pdb import PDBFile import io  viewer_output = widgets.Output() info_label = widgets.HTML(     \"\"     \"\ud83e\uddec Select a snapshot to begin\" )  def display_molecule(index):     \"\"\"Render structure using py3Dmol with enhanced styling.\"\"\"     if len(trajectory_structs) == 0:         return          # Update info panel     energy_delta = energies[index] - energies[0] if index &gt; 0 else 0     info_label.value = f\"\"\"      \ud83d\udcf8 Snapshot {index} |          Energy: {energies[index]:.1f} kJ/mol |          \u0394E: {energy_delta:+.1f} kJ/mol |          \u03c6/\u03c8: ({traj_phi[index]:.1f}\u00b0, {traj_psi[index]:.1f}\u00b0)      \"\"\"          with viewer_output:         clear_output(wait=True)                  # Get PDB string         pdb_file = PDBFile()         pdb_file.set_structure(trajectory_structs[index])         sink = io.StringIO()         pdb_file.write(sink)         pdb_str = sink.getvalue()                  # Create viewer         view = py3Dmol.view(width=600, height=450)         view.addModel(pdb_str, 'pdb')                  # Enhanced styling         view.setStyle({             'stick': {'colorscheme': 'chainHetatm', 'radius': 0.15},             'sphere': {'scale': 0.25, 'colorscheme': 'chainHetatm'}         })                  view.setBackgroundColor('#1a1a1a')         view.zoomTo()         view_widget = view.show()         display(view_widget)  def on_slider_change(change):     display_molecule(change['new'])  # Create slider with custom styling slider = widgets.IntSlider(     value=0,     min=0,     max=max(0, len(trajectory_structs)-1),     step=1,     description='Snapshot:',     continuous_update=False,     layout=widgets.Layout(width='600px'),     style={'description_width': '80px'} ) slider.observe(on_slider_change, names='value')  # Display display(widgets.VBox([     info_label,     slider,     viewer_output ]))  if len(trajectory_structs) &gt; 0:     display_molecule(0)"},{"location":"tutorials/folding_landscape/#the-live-folding-landscape","title":"\ud83c\udfd4\ufe0f The Live Folding Landscape\u00b6","text":""},{"location":"tutorials/folding_landscape/#visualizing-the-energy-funnel-theory-of-protein-folding","title":"Visualizing the Energy Funnel Theory of Protein Folding\u00b6","text":""},{"location":"tutorials/folding_landscape/#learning-objectives","title":"\ud83c\udfaf Learning Objectives\u00b6","text":"<p>In this tutorial, we explore one of the most profound concepts in structural biology: the Energy Funnel. Proteins do not fold by random searching (which would take longer than the age of the universe, known as Levinthal's Paradox). Instead, they follow a rugged energy landscape that guides them toward their most stable, \"native\" state.</p> <p>You will learn:</p> <ol> <li>\ud83e\uddee How to generate a Ramachandran-style Energy Surface for a peptide</li> <li>\ud83d\udd25 How to run Simulated Annealing using the <code>synth-pdb</code> physics engine</li> <li>\ud83d\udcca How to visualize the folding trajectory on a 3D energy landscape</li> <li>\ud83c\udfa8 How canonical secondary structures (\u03b1-helix, \u03b2-sheet) appear as energy minima</li> </ol> <p>\ud83d\udca1 Scientific Context: The energy landscape theory, pioneered by Wolynes, Onuchic, and others in the 1990s, revolutionized our understanding of protein folding. It explains how proteins can fold rapidly despite astronomical conformational possibilities.</p>"},{"location":"tutorials/folding_landscape/#theoretical-foundation","title":"\ud83d\udcda Theoretical Foundation\u00b6","text":""},{"location":"tutorials/folding_landscape/#the-energy-landscape-paradigm","title":"The Energy Landscape Paradigm\u00b6","text":"<p>The protein folding energy landscape can be described mathematically as:</p> <p>$$E(\\phi, \\psi) = E_{\\text{bond}} + E_{\\text{angle}} + E_{\\text{dihedral}} + E_{\\text{vdW}} + E_{\\text{elec}}$$</p> <p>Where:</p> <ul> <li>$\\phi$ (phi) = backbone dihedral angle C-N-C\u03b1-C</li> <li>$\\psi$ (psi) = backbone dihedral angle N-C\u03b1-C-N</li> <li>$E_{\\text{vdW}}$ = van der Waals interactions (steric clashes)</li> <li>$E_{\\text{elec}}$ = electrostatic interactions</li> </ul>"},{"location":"tutorials/folding_landscape/#ramachandran-regions","title":"Ramachandran Regions\u00b6","text":"Region \u03c6 (degrees) \u03c8 (degrees) Secondary Structure \u03b1-helix -60 -45 Right-handed helix \u03b2-sheet -120 +120 Extended strand PPII -75 +145 Polyproline II helix Left \u03b1 +60 +45 Left-handed helix (rare) <p>\u26a0\ufe0f Note: Glycine (no side chain) can access all regions. Proline (cyclic) is restricted to \u03c6 \u2248 -60\u00b0.</p>"},{"location":"tutorials/folding_landscape/#1-creating-the-energy-landscape-with-ramachandran-overlays","title":"1\ufe0f\u20e3 Creating the Energy Landscape with Ramachandran Overlays\u00b6","text":"<p>We'll systematically scan the \u03c6/\u03c8 space and calculate the potential energy at each point. This creates a 2D energy surface that reveals the \"allowed\" and \"forbidden\" regions of conformational space.</p> <p>\ud83d\udd2c Computational Details:</p> <ul> <li>Grid resolution: 15\u00d715 (225 conformations)</li> <li>Force field: AMBER14</li> <li>Energy calculation: Single-point (no minimization)</li> <li>Expected runtime: ~30 seconds</li> </ul>"},{"location":"tutorials/folding_landscape/#2-running-the-folding-trajectory","title":"2\ufe0f\u20e3 Running the Folding Trajectory\u00b6","text":"<p>Now we simulate the folding process using iterative energy minimization. Starting from a random conformation, we allow the peptide to relax toward its energy minimum.</p> <p>\ud83e\uddea Simulation Protocol:</p> <ul> <li>Initial state: Random conformation</li> <li>Algorithm: Steepest descent minimization</li> <li>Steps: 15 refinement cycles</li> <li>Iterations per cycle: 20</li> <li>Tracking: Energy, \u03c6/\u03c8 angles, structure snapshots</li> </ul>"},{"location":"tutorials/folding_landscape/#3-the-interactive-3d-energy-funnel","title":"3\ufe0f\u20e3 The Interactive 3D Energy Funnel\u00b6","text":"<p>This visualization combines:</p> <ul> <li>\ud83d\uddfa\ufe0f Energy surface (blue gradient) showing the conformational landscape</li> <li>\ud83c\udfaf Folding trajectory (orange path) showing the actual folding route</li> <li>\ud83d\udccd Ramachandran regions (annotated) showing canonical secondary structures</li> </ul> <p>\ud83c\udfa8 Interaction Tips:</p> <ul> <li>Rotate: Click and drag</li> <li>Zoom: Scroll or pinch</li> <li>Pan: Right-click and drag</li> <li>Hover: See exact \u03c6/\u03c8/E values</li> </ul>"},{"location":"tutorials/folding_landscape/#4-molecular-structure-viewer","title":"4\ufe0f\u20e3 Molecular Structure Viewer\u00b6","text":"<p>Browse through the folding trajectory snapshots to see the backbone actually condensing into its stable form.</p> <p>\ud83d\udd0d Visualization Features:</p> <ul> <li>Stick representation with spectrum coloring (N\u2192C terminus: blue\u2192red)</li> <li>Sphere representation for atoms</li> <li>Interactive rotation and zoom</li> <li>Real-time energy display</li> </ul>"},{"location":"tutorials/folding_landscape/#key-takeaways","title":"\ud83c\udf93 Key Takeaways\u00b6","text":"<ol> <li>Energy Landscapes are Rugged: The folding pathway navigates through multiple local minima</li> <li>Ramachandran Constraints: Only certain \u03c6/\u03c8 combinations are sterically allowed</li> <li>Funnel Topology: Proteins fold via a funnel-shaped landscape, not a single pathway</li> <li>Secondary Structure Stability: \u03b1-helices and \u03b2-sheets occupy deep energy wells</li> </ol>"},{"location":"tutorials/folding_landscape/#further-reading","title":"\ud83d\udcd6 Further Reading\u00b6","text":"<ul> <li>Dill &amp; MacCallum (2012). \"The Protein-Folding Problem, 50 Years On.\" Science 338:1042-1046. DOI: 10.1126/science.1219021</li> <li>Onuchic et al. (1997). \"Theory of protein folding: the energy landscape perspective.\" Annu Rev Phys Chem 48:545-600. DOI: 10.1146/annurev.physchem.48.1.545</li> <li>Ramachandran et al. (1963). \"Stereochemistry of polypeptide chain configurations.\" J Mol Biol 7:95-99. DOI: 10.1016/S0022-2836(63)80023-680023-6)</li> </ul>"},{"location":"tutorials/folding_landscape/#next-steps","title":"\ud83d\ude80 Next Steps\u00b6","text":"<p>Try modifying the code to:</p> <ul> <li>Use different amino acid sequences (e.g., <code>GLY-ALA-GLY</code> to see glycine flexibility)</li> <li>Increase grid resolution for smoother landscapes</li> <li>Compare different force fields</li> <li>Analyze multi-domain proteins</li> </ul> \ud83c\udf89 Tutorial Complete! <p>You've successfully visualized the protein folding energy landscape using <code>synth-pdb</code></p> <p>Continue exploring the other interactive tutorials to learn more!</p>"},{"location":"tutorials/gfp_molecular_forge/","title":"\ud83e\uddea The GFP \"Molecular Forge\"","text":"In\u00a0[\u00a0]: Copied! <pre># \ud83d\udd27 Environment Detection &amp; Setup\nimport sys, os\nIN_COLAB = 'google.colab' in sys.modules\n\nif IN_COLAB:\n    print('\ud83c\udf10 Running in Google Colab')\n    try:\n        import synth_pdb\n        print('   \u2705 synth-pdb already installed')\n    except ImportError:\n        print('   \ud83d\udce6 Installing synth-pdb...')\n        !pip install -q synth-pdb\n        print('   \u2705 Installation complete')\n    import plotly.io as pio\n    pio.renderers.default = 'colab'\nelse:\n    print('\ud83d\udcbb Running in local Jupyter environment')\n    sys.path.append(os.path.abspath('../../'))\n\nprint('\u2705 Environment configured!')\n</pre> # \ud83d\udd27 Environment Detection &amp; Setup import sys, os IN_COLAB = 'google.colab' in sys.modules  if IN_COLAB:     print('\ud83c\udf10 Running in Google Colab')     try:         import synth_pdb         print('   \u2705 synth-pdb already installed')     except ImportError:         print('   \ud83d\udce6 Installing synth-pdb...')         !pip install -q synth-pdb         print('   \u2705 Installation complete')     import plotly.io as pio     pio.renderers.default = 'colab' else:     print('\ud83d\udcbb Running in local Jupyter environment')     sys.path.append(os.path.abspath('../../'))  print('\u2705 Environment configured!') In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, HTML, clear_output\nimport ipywidgets as widgets\nfrom ipywidgets import interact, SelectionSlider\nimport numpy as np\nimport py3Dmol\nimport plotly.graph_objects as go\nfrom synth_pdb import PeptideGenerator\nimport biotite.structure as struc\nfrom biotite.structure.io.pdb import PDBFile\nimport tempfile\n\nprint('\u2705 GFP Molecular Forge Ready!')\n</pre> from IPython.display import display, HTML, clear_output import ipywidgets as widgets from ipywidgets import interact, SelectionSlider import numpy as np import py3Dmol import plotly.graph_objects as go from synth_pdb import PeptideGenerator import biotite.structure as struc from biotite.structure.io.pdb import PDBFile import tempfile  print('\u2705 GFP Molecular Forge Ready!') In\u00a0[\u00a0]: Copied! <pre>sequence = \"VAL-PRO-SER-TYR-GLY-VAL-LEU\"\n\ndisplay(HTML(\"\"\"\n&lt;div style='background: linear-gradient(135deg, #00C853 0%, #00796B 100%);\n            color: white; padding: 15px; border-radius: 10px;\n            font-family: monospace; margin-bottom: 15px;'&gt;\n    &lt;b&gt;\ud83e\uddec GFP Chromophore Motif&lt;/b&gt;&lt;br&gt;\n    Sequence: VAL-PRO-&lt;span style='color: #FFD700;'&gt;SER-TYR-GLY&lt;/span&gt;-VAL-LEU&lt;br&gt;\n    Critical residues: SER65, TYR66, GLY67&lt;br&gt;\n    Status: Pre-maturation (non-fluorescent)\n&lt;/div&gt;\n\"\"\"))\n\ngen = PeptideGenerator(sequence)\npeptide = gen.generate(conformation=\"alpha\")\nnative_struct = peptide.structure.copy()\n\nprint(\"\u2705 Motif generated (pre-maturation state)\")\n</pre> sequence = \"VAL-PRO-SER-TYR-GLY-VAL-LEU\"  display(HTML(\"\"\"  \ud83e\uddec GFP Chromophore Motif     Sequence: VAL-PRO-SER-TYR-GLY-VAL-LEU     Critical residues: SER65, TYR66, GLY67     Status: Pre-maturation (non-fluorescent)  \"\"\"))  gen = PeptideGenerator(sequence) peptide = gen.generate(conformation=\"alpha\") native_struct = peptide.structure.copy()  print(\"\u2705 Motif generated (pre-maturation state)\") In\u00a0[\u00a0]: Copied! <pre>def get_step_info(step_name):\n    \"\"\"Return description and color for each maturation step.\"\"\"\n    info = {\n        \"1. Native\": {\n            \"desc\": \"Standard polypeptide backbone. No fluorescence.\",\n            \"bg_color\": \"#1a1a1a\",\n            \"chemistry\": \"SER-TYR-GLY in linear configuration\"\n        },\n        \"2. Cyclization\": {\n            \"desc\": \"Gly67 N attacks Ser65 C=O \u2192 5-membered ring formed.\",\n            \"bg_color\": \"#1a1a2a\",\n            \"chemistry\": \"Nucleophilic addition-elimination\"\n        },\n        \"3. Dehydration\": {\n            \"desc\": \"Water elimination from Tyr66 C\u03b1 \u2192 double bond created.\",\n            \"bg_color\": \"#1a2a1a\",\n            \"chemistry\": \"C\u03b1=C\u03b2 conjugation begins\"\n        },\n        \"4. Oxidation\": {\n            \"desc\": \"O\u2082 oxidizes Tyr66 \u2192 full \u03c0-conjugation \u2192 FLUORESCENCE!\",\n            \"bg_color\": \"#001a00\",\n            \"chemistry\": \"Complete p-hydroxybenzylidene-imidazolinone\"\n        }\n    }\n    return info[step_name]\n\nsteps = [\"1. Native\", \"2. Cyclization\", \"3. Dehydration\", \"4. Oxidation\"]\n</pre> def get_step_info(step_name):     \"\"\"Return description and color for each maturation step.\"\"\"     info = {         \"1. Native\": {             \"desc\": \"Standard polypeptide backbone. No fluorescence.\",             \"bg_color\": \"#1a1a1a\",             \"chemistry\": \"SER-TYR-GLY in linear configuration\"         },         \"2. Cyclization\": {             \"desc\": \"Gly67 N attacks Ser65 C=O \u2192 5-membered ring formed.\",             \"bg_color\": \"#1a1a2a\",             \"chemistry\": \"Nucleophilic addition-elimination\"         },         \"3. Dehydration\": {             \"desc\": \"Water elimination from Tyr66 C\u03b1 \u2192 double bond created.\",             \"bg_color\": \"#1a2a1a\",             \"chemistry\": \"C\u03b1=C\u03b2 conjugation begins\"         },         \"4. Oxidation\": {             \"desc\": \"O\u2082 oxidizes Tyr66 \u2192 full \u03c0-conjugation \u2192 FLUORESCENCE!\",             \"bg_color\": \"#001a00\",             \"chemistry\": \"Complete p-hydroxybenzylidene-imidazolinone\"         }     }     return info[step_name]  steps = [\"1. Native\", \"2. Cyclization\", \"3. Dehydration\", \"4. Oxidation\"] In\u00a0[\u00a0]: Copied! <pre># Output widget for clean updates\nout = widgets.Output()\n\n# Slider\nslider = SelectionSlider(options=steps, value=steps[0], description='Maturation:', layout=widgets.Layout(width='500px'))\n\n# Track initialization\n_initializing = True\n\ndef view_forge(change=None):\n    global _initializing\n    if _initializing and change is not None:\n        return\n    \n    step = slider.value\n    info = get_step_info(step)\n    \n    with out:\n        clear_output(wait=True)\n        \n        # Display step information\n        display(HTML(f\"\"\"\n        &lt;div style='background: linear-gradient(135deg, #00C853 0%, #00796B 100%);\n                    color: white; padding: 15px; border-radius: 10px;\n                    font-family: monospace; margin-bottom: 15px;'&gt;\n            &lt;b&gt;\u2697\ufe0f {step}&lt;/b&gt;&lt;br&gt;\n            {info['desc']}&lt;br&gt;\n            &lt;b&gt;Chemistry:&lt;/b&gt; {info['chemistry']}\n        &lt;/div&gt;\n        \"\"\"))\n        \n        # 3D viewer\n        struct = native_struct.copy()\n        \n        # Convert to PDB\n        temp = tempfile.NamedTemporaryFile(suffix=\".pdb\", delete=False)\n        f = PDBFile()\n        f.set_structure(struct)\n        f.write(temp.name)\n        with open(temp.name, 'r') as r:\n            pdb_content = r.read()\n        os.unlink(temp.name)\n        \n        view = py3Dmol.view(width=700, height=450)\n        view.addModel(pdb_content, \"pdb\")\n        \n        # Style: Highlight chromophore motif\n        view.setStyle({'resn': ['VAL', 'PRO', 'LEU']}, \n                     {'stick': {'color': 'gray', 'opacity': 0.4}})\n        view.setStyle({'resn': ['SER', 'TYR', 'GLY']}, \n                     {'stick': {'colorscheme': 'magentaCarbon', 'radius': 0.25}})\n        \n        # Add glow effect for final step\n        if step == \"4. Oxidation\":\n            view.setBackgroundColor(info['bg_color'])\n            view.addLabel(\"\ud83d\udc9a FLUORESCENT!\", \n                         {'position': {'x': 0, 'y': 5, 'z': 0}, \n                          'backgroundColor': '#00FF00', \n                          'fontColor': 'black',\n                          'fontSize': 14})\n        else:\n            view.setBackgroundColor(info['bg_color'])\n        \n        view.zoomTo({'resn': ['SER', 'TYR', 'GLY']})\n        display(view.show())\n\n# Connect slider\nslider.observe(view_forge, 'value')\n\n# Display UI\ndisplay(widgets.VBox([slider, out]))\n\n# Initialize\n_initializing = False\nview_forge()\n</pre> # Output widget for clean updates out = widgets.Output()  # Slider slider = SelectionSlider(options=steps, value=steps[0], description='Maturation:', layout=widgets.Layout(width='500px'))  # Track initialization _initializing = True  def view_forge(change=None):     global _initializing     if _initializing and change is not None:         return          step = slider.value     info = get_step_info(step)          with out:         clear_output(wait=True)                  # Display step information         display(HTML(f\"\"\"          \u2697\ufe0f {step}             {info['desc']} Chemistry: {info['chemistry']}                  \"\"\"))                  # 3D viewer         struct = native_struct.copy()                  # Convert to PDB         temp = tempfile.NamedTemporaryFile(suffix=\".pdb\", delete=False)         f = PDBFile()         f.set_structure(struct)         f.write(temp.name)         with open(temp.name, 'r') as r:             pdb_content = r.read()         os.unlink(temp.name)                  view = py3Dmol.view(width=700, height=450)         view.addModel(pdb_content, \"pdb\")                  # Style: Highlight chromophore motif         view.setStyle({'resn': ['VAL', 'PRO', 'LEU']},                       {'stick': {'color': 'gray', 'opacity': 0.4}})         view.setStyle({'resn': ['SER', 'TYR', 'GLY']},                       {'stick': {'colorscheme': 'magentaCarbon', 'radius': 0.25}})                  # Add glow effect for final step         if step == \"4. Oxidation\":             view.setBackgroundColor(info['bg_color'])             view.addLabel(\"\ud83d\udc9a FLUORESCENT!\",                           {'position': {'x': 0, 'y': 5, 'z': 0},                            'backgroundColor': '#00FF00',                            'fontColor': 'black',                           'fontSize': 14})         else:             view.setBackgroundColor(info['bg_color'])                  view.zoomTo({'resn': ['SER', 'TYR', 'GLY']})         display(view.show())  # Connect slider slider.observe(view_forge, 'value')  # Display UI display(widgets.VBox([slider, out]))  # Initialize _initializing = False view_forge()  In\u00a0[\u00a0]: Copied! <pre># Create absorption and emission spectra\nwavelengths = np.linspace(350, 600, 500)\n\n# Gaussian approximations of GFP spectra\ndef gaussian(x, mu, sigma, amplitude):\n    return amplitude * np.exp(-0.5 * ((x - mu) / sigma) ** 2)\n\n# Two absorption peaks\nabs_395 = gaussian(wavelengths, 395, 15, 0.6)\nabs_475 = gaussian(wavelengths, 475, 20, 1.0)\nabsorption = abs_395 + abs_475\n\n# Emission peak\nemission = gaussian(wavelengths, 508, 25, 0.79)\n\n# Plot\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=wavelengths, y=absorption,\n    name='Absorption',\n    line=dict(color='blue', width=3),\n    fill='tozeroy',\n    fillcolor='rgba(0,0,255,0.2)'\n))\n\nfig.add_trace(go.Scatter(\n    x=wavelengths, y=emission,\n    name='Emission',\n    line=dict(color='green', width=3),\n    fill='tozeroy',\n    fillcolor='rgba(0,255,0,0.2)'\n))\n\nfig.update_layout(\n    title='GFP Absorption &amp; Emission Spectra',\n    xaxis_title='Wavelength (nm)',\n    yaxis_title='Normalized Intensity',\n    template='plotly_dark',\n    width=800, height=500,\n    annotations=[\n        dict(x=395, y=0.6, text=\"\u03bb_abs = 395 nm\", showarrow=True, arrowhead=2),\n        dict(x=475, y=1.0, text=\"\u03bb_abs = 475 nm\", showarrow=True, arrowhead=2),\n        dict(x=508, y=0.79, text=\"\u03bb_em = 508 nm\", showarrow=True, arrowhead=2)\n    ]\n)\n\nfig.show()\n</pre> # Create absorption and emission spectra wavelengths = np.linspace(350, 600, 500)  # Gaussian approximations of GFP spectra def gaussian(x, mu, sigma, amplitude):     return amplitude * np.exp(-0.5 * ((x - mu) / sigma) ** 2)  # Two absorption peaks abs_395 = gaussian(wavelengths, 395, 15, 0.6) abs_475 = gaussian(wavelengths, 475, 20, 1.0) absorption = abs_395 + abs_475  # Emission peak emission = gaussian(wavelengths, 508, 25, 0.79)  # Plot fig = go.Figure()  fig.add_trace(go.Scatter(     x=wavelengths, y=absorption,     name='Absorption',     line=dict(color='blue', width=3),     fill='tozeroy',     fillcolor='rgba(0,0,255,0.2)' ))  fig.add_trace(go.Scatter(     x=wavelengths, y=emission,     name='Emission',     line=dict(color='green', width=3),     fill='tozeroy',     fillcolor='rgba(0,255,0,0.2)' ))  fig.update_layout(     title='GFP Absorption &amp; Emission Spectra',     xaxis_title='Wavelength (nm)',     yaxis_title='Normalized Intensity',     template='plotly_dark',     width=800, height=500,     annotations=[         dict(x=395, y=0.6, text=\"\u03bb_abs = 395 nm\", showarrow=True, arrowhead=2),         dict(x=475, y=1.0, text=\"\u03bb_abs = 475 nm\", showarrow=True, arrowhead=2),         dict(x=508, y=0.79, text=\"\u03bb_em = 508 nm\", showarrow=True, arrowhead=2)     ] )  fig.show()"},{"location":"tutorials/gfp_molecular_forge/#the-gfp-molecular-forge","title":"\ud83e\uddea The GFP \"Molecular Forge\"\u00b6","text":""},{"location":"tutorials/gfp_molecular_forge/#witnessing-the-birth-of-biological-light","title":"Witnessing the Birth of Biological Light\u00b6","text":""},{"location":"tutorials/gfp_molecular_forge/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn\u00b6","text":"<p>The Green Fluorescent Protein (GFP) revolutionized cell biology by enabling scientists to watch living processes in real-time. Its discovery earned the 2008 Nobel Prize in Chemistry.</p> <p>What makes GFP special?</p> <p>Unlike other fluorescent molecules that must be added to cells, GFP creates its own chromophore through an autocatalytic process. Three amino acids (<code>SER65-TYR66-GLY67</code>) spontaneously rearrange to form a fluorescent \u03c0-conjugated system.</p> <p>In this tutorial:</p> <ul> <li>\ud83d\udd2c Visualize the SER-TYR-GLY motif before maturation</li> <li>\u2697\ufe0f Walk through the 3-step maturation: Cyclization \u2192 Dehydration \u2192 Oxidation</li> <li>\ud83c\udf08 Understand the spectroscopy: why green? (\u03bb_max \u2248 508 nm)</li> <li>\ud83e\uddec See how \u03c0-conjugation creates fluorescence</li> </ul> <p>\ud83d\udca1 Nobel Prize Context: Osamu Shimomura, Martin Chalfie, and Roger Tsien shared the 2008 Nobel Prize \"for the discovery and development of the green fluorescent protein, GFP.\"</p>"},{"location":"tutorials/gfp_molecular_forge/#chromophore-chemistry-spectroscopy","title":"\ud83d\udcda Chromophore Chemistry &amp; Spectroscopy\u00b6","text":""},{"location":"tutorials/gfp_molecular_forge/#the-maturation-mechanism","title":"The Maturation Mechanism\u00b6","text":"<p>GFP's chromophore forms through three autocatalytic steps:</p>"},{"location":"tutorials/gfp_molecular_forge/#step-1-cyclization-nucleophilic-attack","title":"Step 1: Cyclization (Nucleophilic Attack)\u00b6","text":"<p>The glycine-67 backbone nitrogen attacks the serine-65 carbonyl carbon, forming a 5-membered imidazolinone ring.</p> <pre><code>Ser65-Tyr66-Gly67  \u2192  [Cyclic intermediate]\n</code></pre> <p>Mechanism: Nucleophilic addition-elimination</p> <ul> <li>Gly67 N: acts as nucleophile</li> <li>Ser65 C=O: electrophilic carbonyl</li> <li>Result: 5-membered heterocycle</li> </ul>"},{"location":"tutorials/gfp_molecular_forge/#step-2-dehydration","title":"Step 2: Dehydration\u00b6","text":"<p>Water is eliminated from the Tyr66 C\u03b1, creating a double bond that extends conjugation.</p> <pre><code>[Cyclic intermediate] - H\u2082O  \u2192  [Dehydrated intermediate]\n</code></pre> <p>Result: C\u03b1=C\u03b2 double bond in Tyr66</p>"},{"location":"tutorials/gfp_molecular_forge/#step-3-oxidation","title":"Step 3: Oxidation\u00b6","text":"<p>Molecular oxygen (O\u2082) oxidizes the Tyr66 C\u03b1-C\u03b2 bond, completing the \u03c0-conjugated system.</p> <pre><code>[Dehydrated intermediate] + O\u2082  \u2192  [Mature chromophore] + H\u2082O\u2082\n</code></pre> <p>Result: Fully conjugated p-hydroxybenzylidene-imidazolinone</p>"},{"location":"tutorials/gfp_molecular_forge/#why-green-spectroscopy-fundamentals","title":"Why Green? Spectroscopy Fundamentals\u00b6","text":"<p>Absorption and Emission</p> <p>The mature chromophore has:</p> <ul> <li>Absorption maximum: \u03bb_abs \u2248 395 nm (UV) and 475 nm (blue)</li> <li>Emission maximum: \u03bb_em \u2248 508 nm (green)</li> <li>Stokes shift: ~33 nm</li> </ul> <p>The Physics</p> <p>Fluorescence occurs through electronic transitions:</p> <ol> <li>Absorption: Blue photon (475 nm) excites electron from HOMO \u2192 LUMO</li> <li>Vibrational relaxation: Energy dissipates as heat</li> <li>Emission: Electron returns to ground state, emitting green photon (508 nm)</li> </ol> <p>Energy relationship:</p> <p>$$E = h\\nu = \\frac{hc}{\\lambda}$$</p> <p>Where:</p> <ul> <li>E = photon energy</li> <li>h = Planck's constant (6.626 \u00d7 10\u207b\u00b3\u2074 J\u00b7s)</li> <li>c = speed of light (3 \u00d7 10\u2078 m/s)</li> <li>\u03bb = wavelength</li> </ul> <p>HOMO-LUMO Gap</p> <p>The \u03c0-conjugation length determines the energy gap:</p> <ul> <li>Longer conjugation \u2192 smaller gap \u2192 red-shifted emission</li> <li>Shorter conjugation \u2192 larger gap \u2192 blue-shifted emission</li> </ul> <p>GFP's 11-atom conjugated system gives the perfect gap for green light!</p> <p>Quantum Yield</p> <p>GFP has a quantum yield (\u03a6) of ~0.79, meaning:</p> <p>$$\\Phi = \\frac{\\text{photons emitted}}{\\text{photons absorbed}} \\approx 0.79$$</p> <p>This is exceptionally high - 79% of absorbed photons result in fluorescence!</p>"},{"location":"tutorials/gfp_molecular_forge/#1-the-starting-motif","title":"1. The Starting Motif\u00b6","text":"<p>We generate a peptide containing the critical <code>SER-TYR-GLY</code> motif. Before maturation, this is just a standard polypeptide backbone.</p>"},{"location":"tutorials/gfp_molecular_forge/#2-the-maturation-process","title":"2. The Maturation Process\u00b6","text":"<p>The chromophore matures through three chemical transformations. While we can't show actual bond rearrangements in this simplified model, we'll highlight the critical residues at each stage.</p>"},{"location":"tutorials/gfp_molecular_forge/#3-the-interactive-molecular-forge","title":"3. The Interactive Molecular Forge\u00b6","text":"<p>Use the slider to progress through the maturation steps. Watch the chromophore region (SER-TYR-GLY) highlighted in magenta.</p>"},{"location":"tutorials/gfp_molecular_forge/#4-absorption-emission-spectra","title":"4. Absorption &amp; Emission Spectra\u00b6","text":"<p>Visualizing the spectroscopic properties of mature GFP.</p>"},{"location":"tutorials/gfp_molecular_forge/#key-insights","title":"\ud83c\udf93 Key Insights\u00b6","text":"<ol> <li>Autocatalytic Maturation: GFP creates its own chromophore without external cofactors</li> <li>Three-Step Process: Cyclization \u2192 Dehydration \u2192 Oxidation</li> <li>\u03c0-Conjugation: Extended conjugated system creates the HOMO-LUMO gap for green emission</li> <li>High Quantum Yield: 79% efficiency makes GFP an excellent fluorescent marker</li> <li>Irreversible: Once formed, the chromophore is stable for the protein's lifetime</li> </ol>"},{"location":"tutorials/gfp_molecular_forge/#scientific-fact","title":"\ud83d\udca1 Scientific Fact\u00b6","text":"<p>The maturation process is irreversible and takes ~4 hours at 37\u00b0C. However, the \u03b2-barrel structure is critical - if it unfolds (e.g., high temperature), water quenching instantly destroys fluorescence!</p>"},{"location":"tutorials/gfp_molecular_forge/#further-reading","title":"\ud83d\udcd6 Further Reading\u00b6","text":"<p>Discovery &amp; Development:</p> <ul> <li>Shimomura et al. (1962). \"Extraction, purification and properties of aequorin.\" J Cell Comp Physiol 59:223-239. DOI: 10.1002/jcp.1030590302</li> <li>Chalfie et al. (1994). \"Green fluorescent protein as a marker for gene expression.\" Science 263:802-805. DOI: 10.1126/science.8303295</li> </ul> <p>Structure &amp; Mechanism:</p> <ul> <li>Orm\u00f6 et al. (1996). \"Crystal structure of the Aequorea victoria green fluorescent protein.\" Science 273:1392-1395. DOI: 10.1126/science.273.5280.1392</li> <li>Heim et al. (1994). \"Wavelength mutations and posttranslational autoxidation of green fluorescent protein.\" PNAS 91:12501-12504. DOI: 10.1073/pnas.91.26.12501</li> </ul> <p>Spectroscopy:</p> <ul> <li>Tsien, R.Y. (1998). \"The green fluorescent protein.\" Annu Rev Biochem 67:509-544. DOI: 10.1146/annurev.biochem.67.1.509</li> </ul> <p>Nobel Prize:</p> <ul> <li>The Nobel Prize in Chemistry 2008: nobelprize.org/prizes/chemistry/2008/summary</li> </ul> \ud83c\udf89 Forge Session Complete! <p>You've witnessed the birth of biological light! \ud83d\udc9a</p>"},{"location":"tutorials/hard_decoy_challenge/","title":"\ud83e\uddec The Hard Decoy Challenge","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\n# Ensure the local synth_pdb source code is prioritized if running from the repo\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  # Ensure the local synth_pdb source code is prioritized if running from the repo try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport py3Dmol\nfrom synth_pdb.batch_generator import BatchedGenerator, BatchedPeptide\nfrom synth_pdb.generator import generate_pdb_content\n\nprint(\"Libraries Loaded.\")\n</pre> import numpy as np import matplotlib.pyplot as plt import py3Dmol from synth_pdb.batch_generator import BatchedGenerator, BatchedPeptide from synth_pdb.generator import generate_pdb_content  print(\"Libraries Loaded.\") In\u00a0[\u00a0]: Copied! <pre># Generate an ensemble with increasing amounts of noise\nsequence = \"LEU-LYS-GLU-LEU-GLU-LYS-GLU-LEU-GLU-LYS-GLU-LEU-GLU-LYS-GLU-LEU\" # Zipper fragment\ngenerator = BatchedGenerator(sequence, n_batch=100, full_atom=True)\n\nprint(\"Generating Native (Drift = 0.0)...\")\nnative = generator.generate_batch(drift=0.0)\n\nprint(\"Generating Hard Decoy (Drift = 15.0)...\")\nhard_decoy = generator.generate_batch(drift=15.0)\n\nprint(\"Generation Complete.\")\n</pre> # Generate an ensemble with increasing amounts of noise sequence = \"LEU-LYS-GLU-LEU-GLU-LYS-GLU-LEU-GLU-LYS-GLU-LEU-GLU-LYS-GLU-LEU\" # Zipper fragment generator = BatchedGenerator(sequence, n_batch=100, full_atom=True)  print(\"Generating Native (Drift = 0.0)...\") native = generator.generate_batch(drift=0.0)  print(\"Generating Hard Decoy (Drift = 15.0)...\") hard_decoy = generator.generate_batch(drift=15.0)  print(\"Generation Complete.\") In\u00a0[\u00a0]: Copied! <pre>def get_rama_angles(pdb_str):\n    \"\"\"Extract phi/psi angles using biotite\"\"\"\n    import biotite.structure as struc\n    import biotite.structure.io.pdb as pdb\n    from io import StringIO\n    \n    text_file = StringIO(pdb_str)\n    array = pdb.PDBFile.read(text_file).get_structure(model=1)\n    # dihedral_backbone returns (phi, psi, omega) arrays\n    phi, psi, omega = struc.dihedral_backbone(array)\n    return np.degrees(phi), np.degrees(psi)\n\ndef plot_ramachandran(batch, title):\n    all_phi = []\n    all_psi = []\n    # Sample 10 structures from the batch\n    for i in range(min(10, batch.coords.shape[0])):\n        phi, psi = get_rama_angles(batch.to_pdb(i))\n        all_phi.extend(phi[~np.isnan(phi)])\n        all_psi.extend(psi[~np.isnan(psi)])\n        \n    plt.figure(figsize=(6, 6))\n    plt.scatter(all_phi, all_psi, alpha=0.5, s=10, color='#667eea')\n    plt.xlim(-180, 180)\n    plt.ylim(-180, 180)\n    plt.axhline(0, color='grey', lw=1, alpha=0.3)\n    plt.axvline(0, color='grey', lw=1, alpha=0.3)\n    plt.title(f\"Ramachandran: {title}\")\n    plt.xlabel(\"Phi (\u03a6)\")\n    plt.ylabel(\"Psi (\u03a8)\")\n    plt.grid(alpha=0.2)\n    plt.show()\n\nplot_ramachandran(native, \"Native (Ideal Alpha Helix)\")\nplot_ramachandran(hard_decoy, \"Hard Decoy (15\u00b0 Noise)\")\n</pre> def get_rama_angles(pdb_str):     \"\"\"Extract phi/psi angles using biotite\"\"\"     import biotite.structure as struc     import biotite.structure.io.pdb as pdb     from io import StringIO          text_file = StringIO(pdb_str)     array = pdb.PDBFile.read(text_file).get_structure(model=1)     # dihedral_backbone returns (phi, psi, omega) arrays     phi, psi, omega = struc.dihedral_backbone(array)     return np.degrees(phi), np.degrees(psi)  def plot_ramachandran(batch, title):     all_phi = []     all_psi = []     # Sample 10 structures from the batch     for i in range(min(10, batch.coords.shape[0])):         phi, psi = get_rama_angles(batch.to_pdb(i))         all_phi.extend(phi[~np.isnan(phi)])         all_psi.extend(psi[~np.isnan(psi)])              plt.figure(figsize=(6, 6))     plt.scatter(all_phi, all_psi, alpha=0.5, s=10, color='#667eea')     plt.xlim(-180, 180)     plt.ylim(-180, 180)     plt.axhline(0, color='grey', lw=1, alpha=0.3)     plt.axvline(0, color='grey', lw=1, alpha=0.3)     plt.title(f\"Ramachandran: {title}\")     plt.xlabel(\"Phi (\u03a6)\")     plt.ylabel(\"Psi (\u03a8)\")     plt.grid(alpha=0.2)     plt.show()  plot_ramachandran(native, \"Native (Ideal Alpha Helix)\") plot_ramachandran(hard_decoy, \"Hard Decoy (15\u00b0 Noise)\") In\u00a0[\u00a0]: Copied! <pre>def plot_contact_map(batch, title):\n    # Get CA atom coordinates for the first model\n    c = batch.coords[0]\n    atom_names = batch.atom_names\n    ca_mask = np.array([name == \"CA\" for name in atom_names])\n    ca_coords = c[ca_mask]\n    \n    # Calculate pairwise distances\n    diff = ca_coords[:, np.newaxis, :] - ca_coords[np.newaxis, :, :]\n    dist_matrix = np.sqrt((diff**2).sum(-1))\n    \n    plt.figure(figsize=(6, 5))\n    plt.imshow(dist_matrix, cmap='viridis_r')\n    plt.colorbar(label=\"Distance (\u00c5)\")\n    plt.title(f\"Contact Map: {title}\")\n    plt.xlabel(\"Residue Index\")\n    plt.ylabel(\"Residue Index\")\n    plt.show()\n\nplot_contact_map(native, \"Native Contacts\")\nplot_contact_map(hard_decoy, \"Decoy Contacts (Scattered)\")\n</pre> def plot_contact_map(batch, title):     # Get CA atom coordinates for the first model     c = batch.coords[0]     atom_names = batch.atom_names     ca_mask = np.array([name == \"CA\" for name in atom_names])     ca_coords = c[ca_mask]          # Calculate pairwise distances     diff = ca_coords[:, np.newaxis, :] - ca_coords[np.newaxis, :, :]     dist_matrix = np.sqrt((diff**2).sum(-1))          plt.figure(figsize=(6, 5))     plt.imshow(dist_matrix, cmap='viridis_r')     plt.colorbar(label=\"Distance (\u00c5)\")     plt.title(f\"Contact Map: {title}\")     plt.xlabel(\"Residue Index\")     plt.ylabel(\"Residue Index\")     plt.show()  plot_contact_map(native, \"Native Contacts\") plot_contact_map(hard_decoy, \"Decoy Contacts (Scattered)\") In\u00a0[\u00a0]: Copied! <pre>import random\n\ndef create_shuffled_decoy(batch):\n    original_seq = batch.sequence\n    shuffled_seq = original_seq.copy()\n    random.shuffle(shuffled_seq)\n    \n    print(f\"Native Sequence:  {' '.join(original_seq[:8])}...\")\n    print(f\"Shuffled Decoy:  {' '.join(shuffled_seq[:8])}...\")\n    return shuffled_seq\n\nshuffled_labels = create_shuffled_decoy(native)\nprint(\"\\n\u2705 This structural data now points to a nonsensical chemical identity.\")\n</pre> import random  def create_shuffled_decoy(batch):     original_seq = batch.sequence     shuffled_seq = original_seq.copy()     random.shuffle(shuffled_seq)          print(f\"Native Sequence:  {' '.join(original_seq[:8])}...\")     print(f\"Shuffled Decoy:  {' '.join(shuffled_seq[:8])}...\")     return shuffled_seq  shuffled_labels = create_shuffled_decoy(native) print(\"\\n\u2705 This structural data now points to a nonsensical chemical identity.\") In\u00a0[\u00a0]: Copied! <pre>template_seq = \"TRP-TRP-TRP-TRP-TRP-TRP-TRP-TRP-TRP\"\nthread_seq = \"GLY-GLY-GLY-GLY-GLY-GLY-GLY-GLY-GLY\"\n\ngenerator = BatchedGenerator(template_seq, n_batch=1, full_atom=True)\nbatch = generator.generate_batch()\n\nprint(f\"Backbone generated for Template: {template_seq}\")\nprint(f\"Threaded with Decoy Sequence: {thread_seq}\")\n\nview = py3Dmol.view(width=400, height=300)\nview.setBackgroundColor(\"#fdfdfd\")\n\n# ROBUST CENTERING (Ported from ml_handover_demo)\nc = batch.coords[0].copy()\nmask = np.any(c != 0, axis=1)\nc_clean = c[mask]\ncenter = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2\nc_centered = c_clean - center\n\np_tmp = BatchedPeptide(\n    c_centered[np.newaxis, ...], \n    batch.sequence, \n    np.array(batch.atom_names)[mask].tolist(), \n    np.array(batch.residue_indices)[mask].tolist()\n)\n\nview.addModel(p_tmp.to_pdb(0), 'pdb')\nview.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}})\nview.zoomTo()\nview.center()\nview.zoom(1.2)\nview.show()\n</pre> template_seq = \"TRP-TRP-TRP-TRP-TRP-TRP-TRP-TRP-TRP\" thread_seq = \"GLY-GLY-GLY-GLY-GLY-GLY-GLY-GLY-GLY\"  generator = BatchedGenerator(template_seq, n_batch=1, full_atom=True) batch = generator.generate_batch()  print(f\"Backbone generated for Template: {template_seq}\") print(f\"Threaded with Decoy Sequence: {thread_seq}\")  view = py3Dmol.view(width=400, height=300) view.setBackgroundColor(\"#fdfdfd\")  # ROBUST CENTERING (Ported from ml_handover_demo) c = batch.coords[0].copy() mask = np.any(c != 0, axis=1) c_clean = c[mask] center = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2 c_centered = c_clean - center  p_tmp = BatchedPeptide(     c_centered[np.newaxis, ...],      batch.sequence,      np.array(batch.atom_names)[mask].tolist(),      np.array(batch.residue_indices)[mask].tolist() )  view.addModel(p_tmp.to_pdb(0), 'pdb') view.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}}) view.zoomTo() view.center() view.zoom(1.2) view.show() In\u00a0[\u00a0]: Copied! <pre>view = py3Dmol.view(width=800, height=400)\nview.setBackgroundColor(\"#fdfdfd\")\ncolors = [\"#ff9999\", \"#66b3ff\", \"#99ff99\", \"#ffcc99\", \"#c2c2f0\"]\n\nfor i in range(min(5, hard_decoy.coords.shape[0])):\n    # ROBUST PER-MODEL CENTERING\n    c = hard_decoy.coords[i].copy()\n    mask = np.any(c != 0, axis=1)\n    c_clean = c[mask]\n    \n    center = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2\n    c_centered = c_clean - center\n    \n    p_tmp = BatchedPeptide(\n        c_centered[np.newaxis, ...], \n        hard_decoy.sequence, \n        np.array(hard_decoy.atom_names)[mask].tolist(), \n        np.array(hard_decoy.residue_indices)[mask].tolist()\n    )\n    \n    view.addModel(p_tmp.to_pdb(0), 'pdb')\n    view.setStyle({'model': i}, {'stick': {'radius': 0.15, 'color': colors[i], 'opacity': 0.8}})\n\nview.zoomTo()\nview.center()\nview.zoom(1.8)\nview.show()\n</pre> view = py3Dmol.view(width=800, height=400) view.setBackgroundColor(\"#fdfdfd\") colors = [\"#ff9999\", \"#66b3ff\", \"#99ff99\", \"#ffcc99\", \"#c2c2f0\"]  for i in range(min(5, hard_decoy.coords.shape[0])):     # ROBUST PER-MODEL CENTERING     c = hard_decoy.coords[i].copy()     mask = np.any(c != 0, axis=1)     c_clean = c[mask]          center = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2     c_centered = c_clean - center          p_tmp = BatchedPeptide(         c_centered[np.newaxis, ...],          hard_decoy.sequence,          np.array(hard_decoy.atom_names)[mask].tolist(),          np.array(hard_decoy.residue_indices)[mask].tolist()     )          view.addModel(p_tmp.to_pdb(0), 'pdb')     view.setStyle({'model': i}, {'stick': {'radius': 0.15, 'color': colors[i], 'opacity': 0.8}})  view.zoomTo() view.center() view.zoom(1.8) view.show()"},{"location":"tutorials/hard_decoy_challenge/#the-hard-decoy-challenge","title":"\ud83e\uddec The Hard Decoy Challenge\u00b6","text":"<p>Objective: Learn how to generate high-quality negative samples for training Protein AI models.</p> <p>In the world of Protein AI (like AlphaFold-3 or RosettaFold), generating \"good\" structures is only half the battle. To train robust models, researchers need Hard Decoys\u2014structures that look physically plausible (correct bond lengths, no overlaps) but are biologically or topologically incorrect.</p>"},{"location":"tutorials/hard_decoy_challenge/#why-do-we-need-hard-decoys","title":"Why do we need Hard Decoys?\u00b6","text":"<ul> <li>Teaching the Global Minimum: If a model only ever sees perfect structures, it won't know why they are better than slightly distorted ones.</li> <li>Improving Discriminators: To train a model to score protein quality, you need a balanced dataset of 'Natives' (Score 1.0) and 'Decoys' (Score 0.0).</li> <li>Robustness: Hard decoys test if a model is just memorizing patterns or actually understanding biophysics.</li> </ul>"},{"location":"tutorials/hard_decoy_challenge/#how-to-run-important","title":"\u26a0\ufe0f How to Run (Important!)\u00b6","text":"<p>This notebook requires a specific environment setup. Follow these steps strictly:</p> <ol> <li>Run All Cells (<code>Runtime</code> -&gt; <code>Run all</code> or <code>Ctrl+F9</code>).</li> <li>Wait for the Crash: If on Colab, the setup cell will automatically restart the session to load libraries. This is normal.</li> <li>Local Users: If you are running locally after editing the library code, Restart your Kernel manually to ensure changes take effect.</li> <li>Wait 10 Seconds: Allow the session to reconnect.</li> <li>Run All Cells AGAIN: This time, the setup will detect it is ready ('\u2705 Dependencies Ready') and proceed typically.</li> </ol>"},{"location":"tutorials/hard_decoy_challenge/#strategy-1-torsion-angle-drift-conformational-noise","title":"Strategy 1: Torsion Angle Drift (Conformational Noise)\u00b6","text":"<p>Objective: Generate \"Near-Native\" decoys by adding controlled Gaussian noise to the ideal Ramachandran angles.</p> <p>In AI training, we use the <code>--drift</code> parameter to test model sensitivity to backbone precision.</p>"},{"location":"tutorials/hard_decoy_challenge/#visualization-a-the-ramachandran-plot","title":"\ud83d\udcc8 Visualization A: The Ramachandran Plot\u00b6","text":"<p>A Ramachandran Plot maps the backbone torsion angles (Phi and Psi) for every residue.</p> <ul> <li>Natives cluster tightly in favored regions (e.g., the bottom-left for alpha-helices).</li> <li>Decoys leak into disallowed regions as the noise increases, breaking the \"physical law\" of protein folding.</li> </ul>"},{"location":"tutorials/hard_decoy_challenge/#visualization-b-the-contact-map","title":"\ud83d\uddfa\ufe0f Visualization B: The Contact Map\u00b6","text":"<p>A Contact Map is a 2D matrix where each pixel $(i, j)$ represents the distance between residue $i$ and $j$.</p> <ul> <li>Perfect structures have clear patterns (helixes show a dark line parallel to the diagonal).</li> <li>High-drift decoys smear these patterns, showing the model \"what not to predict\".</li> </ul>"},{"location":"tutorials/hard_decoy_challenge/#strategy-2-label-shuffling-chemical-mismatch","title":"Strategy 2: Label Shuffling (Chemical Mismatch)\u00b6","text":"<p>Objective: Create a physically perfect structure that is chemically impossible.</p> <p>By shuffling residue labels, we create structures where bulky residues are forced into cramped spaces, or hydrophobic residues are exposed to solvent, forcing the model to learn that Backbone Geometry must match Sidechain Chemistry.</p>"},{"location":"tutorials/hard_decoy_challenge/#strategic-insight-residue-to-structure-mismatch","title":"\ud83d\udd2c Strategic Insight: Residue-to-Structure Mismatch\u00b6","text":"<p>Imagine training a model to predict side-chain orientations (Rotamers). If you provide a Shuffled Decoy, the backbone will suggest a tiny Glycine spot, but the label will say \"Tryptophan\".</p> <p>This forces the model to learn that Backbone Geometry must match Sidechain Chemistry.</p>"},{"location":"tutorials/hard_decoy_challenge/#strategy-3-sequence-threading-fold-mismatch","title":"Strategy 3: Sequence Threading (Fold Mismatch)\u00b6","text":"<p>Objective: Force a sequence onto a fold it cannot naturally adopt.</p> <p>Example: Threading a Poly-Glycine sequence onto the backbone of a Poly-Tryptophan alpha helix.</p>"},{"location":"tutorials/hard_decoy_challenge/#the-challenge-mass-dataset-generation","title":"\ud83c\udfc6 The Challenge: Mass Dataset Generation\u00b6","text":"<p>In a production pipeline, you would use these strategies to generate millions of rows:</p> <pre># Mock Training Loop logic\nfor i in range(1000):\n    is_native = (i % 2 == 0)\n    drift = 0.0 if is_native else 10.0\n    data = generator.generate_batch(drift=drift)\n    # Feed to GNN/Transformer...\n</pre> <p>By generating hard decoys on the fly, you create an infinite stream of diverse training data that prevents your model from overfitting! \ud83d\ude80</p>"},{"location":"tutorials/hard_decoy_challenge/#strategy-3-structure-threading-view","title":"Strategy 3: Structure Threading View\u00b6","text":"<p>Let's visualize a hard decoy ensemble.</p>"},{"location":"tutorials/hard_decoy_challenge/#next-steps","title":"\ud83c\udfc6 Next Steps\u00b6","text":"<ol> <li>Increase the <code>drift</code> to 30.0. How does the 3D ensemble change?</li> <li>Try generating a batch with <code>full_atom=False</code>. \ud83d\ude80</li> </ol>"},{"location":"tutorials/hormone_lab/","title":"\ud83d\udc8d The Bio-Active Hormone Lab: Peptide Drug Discovery \ud83e\uddec","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol biotite numpy matplotlib')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol biotite numpy matplotlib')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport py3Dmol\nfrom synth_pdb.generator import generate_pdb_content\nfrom synth_pdb.batch_generator import BatchedGenerator\n\nprint(\"Molecular Pharmacopoeia: ONLINE \ud83e\uddea\")\n</pre> import numpy as np import py3Dmol from synth_pdb.generator import generate_pdb_content from synth_pdb.batch_generator import BatchedGenerator  print(\"Molecular Pharmacopoeia: ONLINE \ud83e\uddea\") In\u00a0[\u00a0]: Copied! <pre># Sequence: CYS-TYR-ILE-GLN-ASN-CYS-PRO-LEU-GLY\noxytocin_seq = \"CYS-TYR-ILE-GLN-ASN-CYS-PRO-LEU-GLY\"\n\nprint(\"\ud83d\udc8d Synthesizing Oxytocin with Disulfide Closure...\")\n\n# We generate the structure and enable minimization to resolve the loop\noxy_pdb = generate_pdb_content(\n    sequence_str=oxytocin_seq, \n    minimize_energy=True, \n    cap_termini=True\n)\n\nprint(\"\u2705 Synthesis Complete.\")\n</pre> # Sequence: CYS-TYR-ILE-GLN-ASN-CYS-PRO-LEU-GLY oxytocin_seq = \"CYS-TYR-ILE-GLN-ASN-CYS-PRO-LEU-GLY\"  print(\"\ud83d\udc8d Synthesizing Oxytocin with Disulfide Closure...\")  # We generate the structure and enable minimization to resolve the loop oxy_pdb = generate_pdb_content(     sequence_str=oxytocin_seq,      minimize_energy=True,      cap_termini=True )  print(\"\u2705 Synthesis Complete.\") In\u00a0[\u00a0]: Copied! <pre>import py3Dmol\nview = py3Dmol.view(width=800, height=500)\nview.setBackgroundColor('#fdfdfd')\nview.addModel(oxy_pdb, 'pdb')\n\n# 1. Style the main backbone with ribbons\nview.setStyle({'model': -1}, {'cartoon': {'color': '#a29bfe', 'opacity': 0.9}})\n\n# 2. STYLE THE BRIDGE: Show Cys side chains as thick sticks\n# Use addStyle to layer the Cys representation without breaking connectivity.\nview.addStyle({'resn': 'CYS'}, {'stick': {'radius': 0.2, 'color': '#fdcb6e'}})\n\n# 3. Highlight the Sulfur atoms as spheres for prominence\nview.addStyle({'resn': 'CYS', 'atom': 'SG'}, {'sphere': {'radius': 0.4, 'color': '#fdcb6e'}})\nview.addLabel(\"Disulfide Bridge\", {'backgroundColor': '#e17055', 'fontColor': 'white'}, {'resn': 'CYS', 'atom': 'SG'})\n\nview.zoomTo()\nview.center()\nview.show()\n\nprint(\"Educational Insight: Note how 'Cys1' and 'Cys6' residues are forced into proximity to satisfy the disulfide geometry.\")\n</pre> import py3Dmol view = py3Dmol.view(width=800, height=500) view.setBackgroundColor('#fdfdfd') view.addModel(oxy_pdb, 'pdb')  # 1. Style the main backbone with ribbons view.setStyle({'model': -1}, {'cartoon': {'color': '#a29bfe', 'opacity': 0.9}})  # 2. STYLE THE BRIDGE: Show Cys side chains as thick sticks # Use addStyle to layer the Cys representation without breaking connectivity. view.addStyle({'resn': 'CYS'}, {'stick': {'radius': 0.2, 'color': '#fdcb6e'}})  # 3. Highlight the Sulfur atoms as spheres for prominence view.addStyle({'resn': 'CYS', 'atom': 'SG'}, {'sphere': {'radius': 0.4, 'color': '#fdcb6e'}}) view.addLabel(\"Disulfide Bridge\", {'backgroundColor': '#e17055', 'fontColor': 'white'}, {'resn': 'CYS', 'atom': 'SG'})  view.zoomTo() view.center() view.show()  print(\"Educational Insight: Note how 'Cys1' and 'Cys6' residues are forced into proximity to satisfy the disulfide geometry.\") In\u00a0[\u00a0]: Copied! <pre># We use a representative 11-mer with D-Alanine to show the cyclic capability\ncyclosporine_proxy = \"ALA-VAL-LEU-ILE-D-ALA-GLY-MET-PHE-PRO-LEU-VAL\"\n\nprint(\"\ud83d\udc8d Cyclizing 11-mer with D-amino acid integration...\")\n\ncyc_pdb = generate_pdb_content(\n    sequence_str=cyclosporine_proxy,\n    cyclic=True,       # Enable head-to-tail closure\n    minimize_energy=True,\n    cap_termini=False\n)\n\nprint(\"\u2705 Cyclic Macrocycle Generated.\")\n</pre> # We use a representative 11-mer with D-Alanine to show the cyclic capability cyclosporine_proxy = \"ALA-VAL-LEU-ILE-D-ALA-GLY-MET-PHE-PRO-LEU-VAL\"  print(\"\ud83d\udc8d Cyclizing 11-mer with D-amino acid integration...\")  cyc_pdb = generate_pdb_content(     sequence_str=cyclosporine_proxy,     cyclic=True,       # Enable head-to-tail closure     minimize_energy=True,     cap_termini=False )  print(\"\u2705 Cyclic Macrocycle Generated.\") In\u00a0[\u00a0]: Copied! <pre>import py3Dmol\nview = py3Dmol.view(width=800, height=500)\nview.setBackgroundColor('#fdfdfd')\nview.addModel(cyc_pdb, 'pdb')\n\n# Style the Cyclic Backbone with high-contrast colors\nview.setStyle({'model': -1}, {'cartoon': {'color': '#00b894', 'opacity': 0.8}})\nview.setStyle({'model': -1}, {'stick': {'radius': 0.2, 'color': '#55efc4'}})\n\n# Highlight the D-Alanine residue in Intense Red\nview.setStyle({'resn': 'D-ALA'}, {'stick': {'radius': 0.5, 'color': '#d63031'}})\nview.addLabel(\"D-Alanine Hinge\", {'backgroundColor': '#d63031', 'fontColor': 'white'}, {'resn': 'D-ALA'})\n\nview.zoomTo()\nview.center()\nview.show()\n\nprint(\"Educational Insight: The D-Alanine (red) provides a 'hinge' that helps stabilize the circular backbone.\")\n</pre> import py3Dmol view = py3Dmol.view(width=800, height=500) view.setBackgroundColor('#fdfdfd') view.addModel(cyc_pdb, 'pdb')  # Style the Cyclic Backbone with high-contrast colors view.setStyle({'model': -1}, {'cartoon': {'color': '#00b894', 'opacity': 0.8}}) view.setStyle({'model': -1}, {'stick': {'radius': 0.2, 'color': '#55efc4'}})  # Highlight the D-Alanine residue in Intense Red view.setStyle({'resn': 'D-ALA'}, {'stick': {'radius': 0.5, 'color': '#d63031'}}) view.addLabel(\"D-Alanine Hinge\", {'backgroundColor': '#d63031', 'fontColor': 'white'}, {'resn': 'D-ALA'})  view.zoomTo() view.center() view.show()  print(\"Educational Insight: The D-Alanine (red) provides a 'hinge' that helps stabilize the circular backbone.\") In\u00a0[\u00a0]: Copied! <pre>n_peptides = 20\nprint(f\"\ud83d\udd25 Sampling {n_peptides} possible conformations for our therapeutic lead...\")\n\ngenerator = BatchedGenerator(oxytocin_seq, n_batch=n_peptides, full_atom=True)\nbatch = generator.generate_batch(drift=10.0)\n\nprint(\"\u2705 Ensemble Generated.\")\nprint(\"Educational Note: In a real lab, you would run MD simulations on these samples to find the one with the best binding affinity.\")\n</pre> n_peptides = 20 print(f\"\ud83d\udd25 Sampling {n_peptides} possible conformations for our therapeutic lead...\")  generator = BatchedGenerator(oxytocin_seq, n_batch=n_peptides, full_atom=True) batch = generator.generate_batch(drift=10.0)  print(\"\u2705 Ensemble Generated.\") print(\"Educational Note: In a real lab, you would run MD simulations on these samples to find the one with the best binding affinity.\") In\u00a0[\u00a0]: Copied! <pre>import py3Dmol\nview = py3Dmol.view(width=800, height=450)\nview.setBackgroundColor('#fdfdfd')\n\n# Qualitative palette for the ensemble\ncolors = ['#6c5ce7', '#e17055', '#00b894', '#0984e3', '#fdcb6e']\n\nfor i in range(min(5, n_peptides)):\n    view.addModel(batch.to_pdb(i), 'pdb')\n    # Use thin \"sticks\" for an ultra-premium look across the ensemble\n    view.setStyle({'model': i}, {'stick': {'radius': 0.15, 'color': colors[i % len(colors)], 'opacity': 0.8}})\n    # Use addStyle for the spheres so they don't erase the side-chain sticks\n    view.addStyle({'model': i, 'atom': 'SG'}, {'sphere': {'radius': 0.4, 'color': '#fab1a0'}})\n\nview.zoomTo()\nview.center()\nview.show()\n</pre> import py3Dmol view = py3Dmol.view(width=800, height=450) view.setBackgroundColor('#fdfdfd')  # Qualitative palette for the ensemble colors = ['#6c5ce7', '#e17055', '#00b894', '#0984e3', '#fdcb6e']  for i in range(min(5, n_peptides)):     view.addModel(batch.to_pdb(i), 'pdb')     # Use thin \"sticks\" for an ultra-premium look across the ensemble     view.setStyle({'model': i}, {'stick': {'radius': 0.15, 'color': colors[i % len(colors)], 'opacity': 0.8}})     # Use addStyle for the spheres so they don't erase the side-chain sticks     view.addStyle({'model': i, 'atom': 'SG'}, {'sphere': {'radius': 0.4, 'color': '#fab1a0'}})  view.zoomTo() view.center() view.show()"},{"location":"tutorials/hormone_lab/#the-bio-active-hormone-lab-peptide-drug-discovery","title":"\ud83d\udc8d The Bio-Active Hormone Lab: Peptide Drug Discovery \ud83e\uddec\u00b6","text":"<p>Objective: Learn how to model real-world therapeutic macrocycles like Oxytocin and Cyclosporine A using physics-based generation.</p>"},{"location":"tutorials/hormone_lab/#what-is-a-macrocycle","title":"\ud83c\udf1f What is a Macrocycle?\u00b6","text":"<p>In drug discovery, a macrocycle is a molecule containing a large ring (usually 12 or more atoms). Unlike linear peptides which are floppy and easily destroyed by the body, macrocycles are pre-organized into specific shapes. This makes them:</p> <ol> <li>Potent: They fit into their target protein like a perfect key.</li> <li>Stable: Their circular structure protects them from being chopped up by enzymes.</li> </ol> <p>In this lab, we use <code>synth-pdb</code> to find the \"Native\" physical conformation of these therapeutic giants.</p>"},{"location":"tutorials/hormone_lab/#1-case-study-oxytocin-the-disulfide-loop","title":"1. Case Study: Oxytocin (The Disulfide Loop)\u00b6","text":"<p>Oxytocin is a 9-residue peptide hormone. It is held in its active shape by a disulfide bridge between its first and sixth residues (<code>Cys1</code> and <code>Cys6</code>).</p> <p>The Challenge: To close a disulfide loop, the two Sulfur atoms must come within ~2.0\u00c5 of each other. In a random linear chain, this is nearly impossible. We use physics-based minimization to \"pull\" the ring shut.</p>"},{"location":"tutorials/hormone_lab/#2-case-study-cyclosporine-a-d-amino-acid-macrocycle","title":"2. Case Study: Cyclosporine A (D-Amino Acid Macrocycle)\u00b6","text":"<p>Cyclosporine A is a powerhouse drug used to prevent organ transplant rejection. It is an 11-mer cyclic peptide that features multiple D-amino acids.</p> <p>The Challenge: Head-to-tail cyclization requires the first residue to bond with the last residue. D-amino acids (mirror images of normal L-amino acids) are used to prevent the cycle from being broken down by the body.</p>"},{"location":"tutorials/hormone_lab/#3-finding-the-native-state-the-low-energy-ensemble","title":"3. Finding the \"Native\" State (The Low-Energy Ensemble)\u00b6","text":"<p>Macrocycles are highly constrained, but they can still \"breathe\". In drug discovery, we want the structure that is the most stable (lowest energy). We use Batched Generation to sample many possibilities and find the global minimum.</p>"},{"location":"tutorials/hormone_lab/#experiment-for-the-user","title":"\ud83c\udfc6 Experiment for the User\u00b6","text":"<p>Try replacing <code>PRO</code> in the macrocycle with <code>D-PRO</code> and see if the ring closure becomes easier or harder. \ud83e\uddea</p> <p>The molecules are yours to discover. \ud83e\uddea\ud83d\udc8d\ud83e\uddec</p>"},{"location":"tutorials/latent_space_explorer/","title":"\ud83c\udf0c AI Latent Space Explorer","text":"In\u00a0[\u00a0]: Copied! <pre># \ud83d\udd27 Environment Detection &amp; Setup\nimport sys, os\nIN_COLAB = 'google.colab' in sys.modules\n\nif IN_COLAB:\n    print('\ud83c\udf10 Running in Google Colab')\n    try:\n        import synth_pdb\n        print('   \u2705 synth-pdb already installed')\n    except ImportError:\n        print('   \ud83d\udce6 Installing synth-pdb...')\n        !pip install -q synth-pdb\n        print('   \u2705 Installation complete')\n    import plotly.io as pio\n    pio.renderers.default = 'colab'\nelse:\n    print('\ud83d\udcbb Running in local Jupyter environment')\n    sys.path.append(os.path.abspath('../../'))\n\nprint('\u2705 Environment configured!')\n</pre> # \ud83d\udd27 Environment Detection &amp; Setup import sys, os IN_COLAB = 'google.colab' in sys.modules  if IN_COLAB:     print('\ud83c\udf10 Running in Google Colab')     try:         import synth_pdb         print('   \u2705 synth-pdb already installed')     except ImportError:         print('   \ud83d\udce6 Installing synth-pdb...')         !pip install -q synth-pdb         print('   \u2705 Installation complete')     import plotly.io as pio     pio.renderers.default = 'colab' else:     print('\ud83d\udcbb Running in local Jupyter environment')     sys.path.append(os.path.abspath('../../'))  print('\u2705 Environment configured!') In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, HTML, clear_output\nimport ipywidgets as widgets\nfrom ipywidgets import interact, IntSlider\nimport numpy as np\nimport py3Dmol\nimport matplotlib.pyplot as plt\nfrom sklearn.decomposition import PCA\nimport plotly.graph_objects as go\nfrom synth_pdb import PeptideGenerator\nfrom synth_pdb.batch_generator import BatchedGenerator\nimport biotite.structure as struc\n\nprint('\u2705 Latent Space Explorer Ready!')\n</pre> from IPython.display import display, HTML, clear_output import ipywidgets as widgets from ipywidgets import interact, IntSlider import numpy as np import py3Dmol import matplotlib.pyplot as plt from sklearn.decomposition import PCA import plotly.graph_objects as go from synth_pdb import PeptideGenerator from synth_pdb.batch_generator import BatchedGenerator import biotite.structure as struc  print('\u2705 Latent Space Explorer Ready!') In\u00a0[\u00a0]: Copied! <pre>sequence = \"TRP-SER-GLY-ALA-VAL-PRO-ILE\"\nn_batch = 500\n\ndisplay(HTML(f\"\"\"\n&lt;div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            color: white; padding: 15px; border-radius: 10px;\n            font-family: monospace; margin-bottom: 15px;'&gt;\n    &lt;b&gt;\ud83d\ude80 Batch Generation&lt;/b&gt;&lt;br&gt;\n    Sequence: {sequence}&lt;br&gt;\n    Structures: {n_batch}&lt;br&gt;\n    Method: Vectorized NeRF algorithm\n&lt;/div&gt;\n\"\"\"))\n\nprint(f\"Generating {n_batch} structures...\")\nbg = BatchedGenerator(sequence, n_batch=n_batch)\nbatch = bg.generate_batch()\n\nprint(f\"\u2705 Generated {batch.coords.shape[0]} structures\")\nprint(f\"   Shape: {batch.coords.shape} (Batch, Atoms, XYZ)\")\n</pre> sequence = \"TRP-SER-GLY-ALA-VAL-PRO-ILE\" n_batch = 500  display(HTML(f\"\"\"  \ud83d\ude80 Batch Generation     Sequence: {sequence}     Structures: {n_batch}     Method: Vectorized NeRF algorithm  \"\"\"))  print(f\"Generating {n_batch} structures...\") bg = BatchedGenerator(sequence, n_batch=n_batch) batch = bg.generate_batch()  print(f\"\u2705 Generated {batch.coords.shape[0]} structures\") print(f\"   Shape: {batch.coords.shape} (Batch, Atoms, XYZ)\") In\u00a0[\u00a0]: Copied! <pre>print(\"Computing 6D orientograms...\")\norients = batch.get_6d_orientations()\n\nprint(f\"\u2705 Computed orientations for {n_batch} structures\")\nprint(f\"   Available features: {list(orients.keys())}\")\nprint(f\"   Shape per feature: {orients['dist'].shape} (Batch, Residues, Residues)\")\n</pre> print(\"Computing 6D orientograms...\") orients = batch.get_6d_orientations()  print(f\"\u2705 Computed orientations for {n_batch} structures\") print(f\"   Available features: {list(orients.keys())}\") print(f\"   Shape per feature: {orients['dist'].shape} (Batch, Residues, Residues)\") In\u00a0[\u00a0]: Copied! <pre># Flatten all features into one vector per structure\nfeature_vector = np.concatenate([\n    orients['dist'].reshape(n_batch, -1),\n    orients['omega'].reshape(n_batch, -1),\n    orients['theta'].reshape(n_batch, -1),\n    orients['phi'].reshape(n_batch, -1)\n], axis=1)\n\nprint(f\"Feature vector dimensionality: {feature_vector.shape[1]}\")\n\n# Apply PCA\npca = PCA(n_components=2)\nlatent_points = pca.fit_transform(feature_vector)\n\n# Show variance explained\nvar_explained = pca.explained_variance_ratio_\nprint(f\"\\n\u2705 PCA complete\")\nprint(f\"   PC1 variance: {var_explained[0]:.1%}\")\nprint(f\"   PC2 variance: {var_explained[1]:.1%}\")\nprint(f\"   Total variance captured: {var_explained.sum():.1%}\")\n</pre> # Flatten all features into one vector per structure feature_vector = np.concatenate([     orients['dist'].reshape(n_batch, -1),     orients['omega'].reshape(n_batch, -1),     orients['theta'].reshape(n_batch, -1),     orients['phi'].reshape(n_batch, -1) ], axis=1)  print(f\"Feature vector dimensionality: {feature_vector.shape[1]}\")  # Apply PCA pca = PCA(n_components=2) latent_points = pca.fit_transform(feature_vector)  # Show variance explained var_explained = pca.explained_variance_ratio_ print(f\"\\n\u2705 PCA complete\") print(f\"   PC1 variance: {var_explained[0]:.1%}\") print(f\"   PC2 variance: {var_explained[1]:.1%}\") print(f\"   Total variance captured: {var_explained.sum():.1%}\") In\u00a0[\u00a0]: Copied! <pre>fig = go.Figure(data=[go.Scatter(\n    x=latent_points[:, 0],\n    y=latent_points[:, 1],\n    mode='markers',\n    marker=dict(\n        size=8,\n        color=np.arange(n_batch),\n        colorscale='Viridis',\n        showscale=True,\n        colorbar=dict(title='Structure ID'),\n        line=dict(width=0.5, color='white')\n    ),\n    text=[f\"Structure {i}\" for i in range(n_batch)],\n    hovertemplate='%{text}&lt;br&gt;PC1: %{x:.2f}&lt;br&gt;PC2: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'\n)])\n\nfig.update_layout(\n    title=dict(\n        text=f'Protein Latent Space (PCA of 6D Orientograms)&lt;br&gt;&lt;sub&gt;Variance explained: PC1={var_explained[0]:.1%}, PC2={var_explained[1]:.1%}&lt;/sub&gt;',\n        x=0.5,\n        xanchor='center'\n    ),\n    xaxis_title='Principal Component 1',\n    yaxis_title='Principal Component 2',\n    width=900, height=600,\n    template=\"plotly_dark\",\n    hovermode='closest'\n)\n\nfig.show()\n</pre> fig = go.Figure(data=[go.Scatter(     x=latent_points[:, 0],     y=latent_points[:, 1],     mode='markers',     marker=dict(         size=8,         color=np.arange(n_batch),         colorscale='Viridis',         showscale=True,         colorbar=dict(title='Structure ID'),         line=dict(width=0.5, color='white')     ),     text=[f\"Structure {i}\" for i in range(n_batch)],     hovertemplate='%{text}PC1: %{x:.2f}PC2: %{y:.2f}' )])  fig.update_layout(     title=dict(         text=f'Protein Latent Space (PCA of 6D Orientograms)<sub>Variance explained: PC1={var_explained[0]:.1%}, PC2={var_explained[1]:.1%}</sub>',         x=0.5,         xanchor='center'     ),     xaxis_title='Principal Component 1',     yaxis_title='Principal Component 2',     width=900, height=600,     template=\"plotly_dark\",     hovermode='closest' )  fig.show() In\u00a0[\u00a0]: Copied! <pre># Output widget for clean updates\nout = widgets.Output()\n\n# Slider\nslider = IntSlider(min=0, max=n_batch-1, step=1, value=0, description='Structure:', layout=widgets.Layout(width='500px'))\n\n# Track initialization\n_initializing = True\n\ndef view_from_latent(change=None):\n    global _initializing\n    if _initializing and change is not None:\n        return\n    \n    index = slider.value\n    coords = batch.coords[index]\n    \n    # Create structure\n    pgen = PeptideGenerator(sequence)\n    res = pgen.generate()\n    \n    if res.structure.array_length() == coords.shape[0]:\n        res.structure.coord = coords\n    \n    with out:\n        clear_output(wait=True)\n        \n        print(f'Structure {index} | PC1={latent_points[index,0]:.2f}, PC2={latent_points[index,1]:.2f}\\n')\n        \n        # 3D viewer\n        view = py3Dmol.view(width=500, height=400)\n        view.addModel(res.pdb, \"pdb\")\n        view.setStyle({'stick': {'colorscheme': 'chainHetatm'}})\n        view.setBackgroundColor('#1a1a1a')\n        view.zoomTo()\n        display(view.show())\n        \n        # Distance map\n        fig, ax = plt.subplots(1, 1, figsize=(4, 4))\n        im = ax.imshow(orients['dist'][index], cmap='magma', vmin=0, vmax=20)\n        ax.set_title(\"Distance Map (AI View)\", color='white')\n        ax.set_xlabel(\"Residue\", color='white')\n        ax.set_ylabel(\"Residue\", color='white')\n        ax.tick_params(colors='white')\n        fig.patch.set_facecolor('#1a1a1a')\n        ax.set_facecolor('#1a1a1a')\n        plt.colorbar(im, ax=ax, label='Distance (\u00c5)')\n        plt.tight_layout()\n        plt.show()\n        plt.close(fig)  # Important: close figure to prevent memory leak\n\n# Connect slider\nslider.observe(view_from_latent, 'value')\n\n# Display UI\ndisplay(widgets.VBox([slider, out]))\n\n# Initialize\n_initializing = False\nview_from_latent()\n</pre> # Output widget for clean updates out = widgets.Output()  # Slider slider = IntSlider(min=0, max=n_batch-1, step=1, value=0, description='Structure:', layout=widgets.Layout(width='500px'))  # Track initialization _initializing = True  def view_from_latent(change=None):     global _initializing     if _initializing and change is not None:         return          index = slider.value     coords = batch.coords[index]          # Create structure     pgen = PeptideGenerator(sequence)     res = pgen.generate()          if res.structure.array_length() == coords.shape[0]:         res.structure.coord = coords          with out:         clear_output(wait=True)                  print(f'Structure {index} | PC1={latent_points[index,0]:.2f}, PC2={latent_points[index,1]:.2f}\\n')                  # 3D viewer         view = py3Dmol.view(width=500, height=400)         view.addModel(res.pdb, \"pdb\")         view.setStyle({'stick': {'colorscheme': 'chainHetatm'}})         view.setBackgroundColor('#1a1a1a')         view.zoomTo()         display(view.show())                  # Distance map         fig, ax = plt.subplots(1, 1, figsize=(4, 4))         im = ax.imshow(orients['dist'][index], cmap='magma', vmin=0, vmax=20)         ax.set_title(\"Distance Map (AI View)\", color='white')         ax.set_xlabel(\"Residue\", color='white')         ax.set_ylabel(\"Residue\", color='white')         ax.tick_params(colors='white')         fig.patch.set_facecolor('#1a1a1a')         ax.set_facecolor('#1a1a1a')         plt.colorbar(im, ax=ax, label='Distance (\u00c5)')         plt.tight_layout()         plt.show()         plt.close(fig)  # Important: close figure to prevent memory leak  # Connect slider slider.observe(view_from_latent, 'value')  # Display UI display(widgets.VBox([slider, out]))  # Initialize _initializing = False view_from_latent()"},{"location":"tutorials/latent_space_explorer/#ai-latent-space-explorer","title":"\ud83c\udf0c AI Latent Space Explorer\u00b6","text":""},{"location":"tutorials/latent_space_explorer/#visualizing-how-protein-ai-models-see-structural-diversity","title":"Visualizing How Protein AI Models \"See\" Structural Diversity\u00b6","text":""},{"location":"tutorials/latent_space_explorer/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn\u00b6","text":"<p>Modern protein folding AI models like AlphaFold and trRosetta don't predict 3D coordinates directly. Instead, they:</p> <ol> <li>Predict inter-residue geometry (distances and orientations)</li> <li>Use these 2D \"maps\" to reconstruct 3D structure</li> </ol> <p>In this tutorial:</p> <ul> <li>\ud83d\ude80 Generate 500 protein conformations in parallel using <code>BatchedGenerator</code></li> <li>\ud83d\udcd0 Compute 6D trRosetta orientograms (the AI's \"view\" of structure)</li> <li>\ud83c\udfa8 Use PCA to visualize the high-dimensional \"latent space\" in 2D</li> <li>\ud83d\udd0d Explore individual structures from the latent space galaxy</li> </ul> <p>\ud83d\udca1 Why This Matters: Understanding how AI models represent proteins is crucial for:</p> <ul> <li>Protein structure prediction</li> <li>Generative protein design</li> <li>Transfer learning in structural biology</li> </ul>"},{"location":"tutorials/latent_space_explorer/#theoretical-foundation","title":"\ud83d\udcda Theoretical Foundation\u00b6","text":""},{"location":"tutorials/latent_space_explorer/#protein-representation-learning","title":"Protein Representation Learning\u00b6","text":"<p>Why not use Cartesian coordinates directly?</p> <p>Cartesian coordinates (x, y, z) have several problems:</p> <ul> <li>Not rotation-invariant: Same structure, different orientation = different coordinates</li> <li>Not translation-invariant: Same structure, different position = different coordinates</li> <li>High dimensional: N atoms \u00d7 3 coordinates = 3N dimensions</li> </ul> <p>Solution: Inter-residue Geometry</p> <p>Instead, AI models use pairwise geometric relationships between residues:</p> Feature Symbol Description Range Distance d C\u03b2-C\u03b2 distance 0-20 \u00c5 Omega \u03c9 Dihedral angle between C\u03b2-C\u03b2 frames -180\u00b0 to +180\u00b0 Theta \u03b8 Planar angle in first frame 0\u00b0 to 180\u00b0 Phi \u03c6 Planar angle in second frame 0\u00b0 to 180\u00b0 <p>These 4 values (plus 2 more for complete orientation) form the 6D orientogram.</p>"},{"location":"tutorials/latent_space_explorer/#dimensionality-reduction-pca","title":"Dimensionality Reduction: PCA\u00b6","text":"<p>Principal Component Analysis finds the directions of maximum variance in high-dimensional data.</p> <p>Given data matrix $\\mathbf{X} \\in \\mathbb{R}^{n \\times d}$ (n samples, d features):</p> <ol> <li><p>Center the data: $\\mathbf{X}_{centered} = \\mathbf{X} - \\bar{\\mathbf{X}}$</p> </li> <li><p>Compute covariance: $\\mathbf{C} = \\frac{1}{n-1}\\mathbf{X}_{centered}^T \\mathbf{X}_{centered}$</p> </li> <li><p>Eigendecomposition: $\\mathbf{C} = \\mathbf{V}\\mathbf{\\Lambda}\\mathbf{V}^T$</p> </li> <li><p>Project: $\\mathbf{Z} = \\mathbf{X}_{centered}\\mathbf{V}_k$ (keep top k eigenvectors)</p> </li> </ol> <p>Why PCA for proteins?</p> <ul> <li>Reveals the \"principal modes\" of structural variation</li> <li>Reduces ~1000 dimensions to 2-3 for visualization</li> <li>Preserves maximum variance (information)</li> </ul> <p>\ud83d\udd2c Alternative: t-SNE preserves local structure better but is non-linear and slower</p>"},{"location":"tutorials/latent_space_explorer/#1-parallel-structure-generation","title":"1. Parallel Structure Generation\u00b6","text":"<p>We'll generate 500 diverse conformations of a 7-residue peptide using <code>BatchedGenerator</code>, which uses vectorized NumPy operations for speed.</p>"},{"location":"tutorials/latent_space_explorer/#2-computing-6d-orientograms","title":"2. Computing 6D Orientograms\u00b6","text":"<p>For every pair of residues in every protein, we calculate the 6D geometric relationship. This is exactly what trRosetta predicts before reconstructing 3D structure.</p> <p>The 6D representation:</p> <ul> <li>Distance (d)</li> <li>Omega (\u03c9) - dihedral between frames</li> <li>Theta (\u03b8) - planar angle in frame 1</li> <li>Phi (\u03c6) - planar angle in frame 2</li> <li>(Plus 2 more for complete orientation)</li> </ul> <p>This creates a rotation and translation invariant representation of structure.</p>"},{"location":"tutorials/latent_space_explorer/#3-dimensionality-reduction-with-pca","title":"3. Dimensionality Reduction with PCA\u00b6","text":"<p>We flatten the 2D geometry maps into high-dimensional feature vectors and use PCA to project them into 2D for visualization.</p> <p>Feature vector construction:</p> <ul> <li>Distance maps: 7\u00d77 = 49 features</li> <li>Omega maps: 7\u00d77 = 49 features</li> <li>Theta maps: 7\u00d77 = 49 features</li> <li>Phi maps: 7\u00d77 = 49 features</li> <li>Total: 196 dimensions \u2192 2 dimensions via PCA</li> </ul>"},{"location":"tutorials/latent_space_explorer/#4-interactive-latent-space-galaxy","title":"4. Interactive Latent Space Galaxy\u00b6","text":"<p>Each point represents one protein conformation. Points close together have similar geometric properties. This is the \"latent space\" - a compressed representation of structural diversity.</p>"},{"location":"tutorials/latent_space_explorer/#5-structure-explorer","title":"5. Structure Explorer\u00b6","text":"<p>Use the slider to browse individual structures and see their corresponding distance maps (how the AI \"sees\" them).</p>"},{"location":"tutorials/latent_space_explorer/#key-insights","title":"\ud83c\udf93 Key Insights\u00b6","text":"<ol> <li>Geometric Representation: AI models use inter-residue geometry (distances + orientations) instead of raw coordinates</li> <li>Rotation Invariance: 6D orientograms are invariant to rotation and translation</li> <li>Latent Space: PCA reveals the \"principal modes\" of structural variation</li> <li>Dimensionality: 196D \u2192 2D while preserving ~XX% of variance</li> </ol>"},{"location":"tutorials/latent_space_explorer/#further-reading","title":"\ud83d\udcd6 Further Reading\u00b6","text":"<p>Protein Structure Prediction:</p> <ul> <li>Jumper et al. (2021). \"Highly accurate protein structure prediction with AlphaFold.\" Nature 596:583-589. DOI: 10.1038/s41586-021-03819-2</li> <li>Yang et al. (2020). \"Improved protein structure prediction using predicted interresidue orientations.\" PNAS 117:1496-1503. DOI: 10.1073/pnas.1914677117</li> </ul> <p>Protein Representation Learning:</p> <ul> <li>Rao et al. (2019). \"Evaluating protein transfer learning with TAPE.\" NeurIPS 2019. arXiv:1906.08230</li> <li>Greener et al. (2018). \"Design of metalloproteins and novel protein folds using variational autoencoders.\" Sci Rep 8:16189. DOI: 10.1038/s41598-018-34533-1</li> </ul> <p>Dimensionality Reduction:</p> <ul> <li>Pearson, K. (1901). \"On lines and planes of closest fit to systems of points in space.\" Phil Mag 2:559-572.</li> <li>van der Maaten &amp; Hinton (2008). \"Visualizing data using t-SNE.\" JMLR 9:2579-2605.</li> </ul> \ud83c\udf89 Exploration Complete! <p>You've mastered protein latent space visualization!</p>"},{"location":"tutorials/macrocycle_lab/","title":"\ud83d\udc8d Macrocycle Design Lab: Engineering Cyclic Peptides","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\n# Ensure the local synth_pdb source code is prioritized if running from the repo\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  # Ensure the local synth_pdb source code is prioritized if running from the repo try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport py3Dmol\nfrom synth_pdb.generator import generate_pdb_content\n\ndef center_pdb(pdb_str):\n    lines = pdb_str.splitlines()\n    coords = []\n    for line in lines:\n        if line.startswith(\"ATOM\"):\n            coords.append([float(line[30:38]), float(line[38:46]), float(line[46:54])])\n    if not coords: return pdb_str\n    coords = np.array(coords)\n    # Robust centroid calculation\n    center = (coords.min(axis=0) + coords.max(axis=0)) / 2\n    new_lines = []\n    for line in lines:\n        if line.startswith(\"ATOM\"):\n            x, y, z = float(line[30:38]) - center[0], float(line[38:46]) - center[1], float(line[46:54]) - center[2]\n            new_lines.append(line[:30] + f\"{x:&gt;8.3f}{y:&gt;8.3f}{z:&gt;8.3f}\" + line[54:])\n        else: new_lines.append(line)\n    return \"\\n\".join(new_lines)\n\nprint(\"Libraries Loaded.\")\n</pre> import numpy as np import py3Dmol from synth_pdb.generator import generate_pdb_content  def center_pdb(pdb_str):     lines = pdb_str.splitlines()     coords = []     for line in lines:         if line.startswith(\"ATOM\"):             coords.append([float(line[30:38]), float(line[38:46]), float(line[46:54])])     if not coords: return pdb_str     coords = np.array(coords)     # Robust centroid calculation     center = (coords.min(axis=0) + coords.max(axis=0)) / 2     new_lines = []     for line in lines:         if line.startswith(\"ATOM\"):             x, y, z = float(line[30:38]) - center[0], float(line[38:46]) - center[1], float(line[46:54]) - center[2]             new_lines.append(line[:30] + f\"{x:&gt;8.3f}{y:&gt;8.3f}{z:&gt;8.3f}\" + line[54:])         else: new_lines.append(line)     return \"\\n\".join(new_lines)  print(\"Libraries Loaded.\") In\u00a0[\u00a0]: Copied! <pre>sequence = \"TRP-SER-GLY-VAL-VAL-ASN-GLY-SER\" # A random 8-mer\n\nprint(\"Generating Linear Control...\")\nlinear_pdb = generate_pdb_content(sequence_str=sequence, cyclic=False, minimize_energy=True)\n\nprint(\"Generating Cyclic Macrocycle (Minimized)...\")\ncyclic_pdb = generate_pdb_content(sequence_str=sequence, cyclic=True, minimize_energy=True)\n\nprint(\"Generation Complete.\")\n</pre> sequence = \"TRP-SER-GLY-VAL-VAL-ASN-GLY-SER\" # A random 8-mer  print(\"Generating Linear Control...\") linear_pdb = generate_pdb_content(sequence_str=sequence, cyclic=False, minimize_energy=True)  print(\"Generating Cyclic Macrocycle (Minimized)...\") cyclic_pdb = generate_pdb_content(sequence_str=sequence, cyclic=True, minimize_energy=True)  print(\"Generation Complete.\") In\u00a0[\u00a0]: Copied! <pre>def view_structures(pdb1, title1, pdb2, title2):\n    view = py3Dmol.view(width=800, height=400, linked=False, viewergrid=(1, 2))\n    view.setBackgroundColor(\"#fdfdfd\")\n    \n    # Centering proteins for a tighter view\n    pdb1 = center_pdb(pdb1)\n    pdb2 = center_pdb(pdb2)\n    \n    # Model 1\n    view.addModel(pdb1, 'pdb', viewer=(0, 0))\n    view.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}}, viewer=(0, 0))\n    view.addLabel(title1, {'position': {'x': 0, 'y': 20, 'z': 0}, 'backgroundColor': 'white', 'fontColor':'black'}, viewer=(0, 0))\n    \n    # Model 2\n    view.addModel(pdb2, 'pdb', viewer=(0, 1))\n    view.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}}, viewer=(0, 1))\n    view.addLabel(title2, {'position': {'x': 0, 'y': 20, 'z': 0}, 'backgroundColor': 'white', 'fontColor':'black'}, viewer=(0, 1))\n    \n    view.zoomTo()\n    view.center()\n    view.zoom(1.2)\n    view.show()\n\nview_structures(linear_pdb, \"Linear Peptide\", cyclic_pdb, \"Cyclic Macrocycle\")\n</pre> def view_structures(pdb1, title1, pdb2, title2):     view = py3Dmol.view(width=800, height=400, linked=False, viewergrid=(1, 2))     view.setBackgroundColor(\"#fdfdfd\")          # Centering proteins for a tighter view     pdb1 = center_pdb(pdb1)     pdb2 = center_pdb(pdb2)          # Model 1     view.addModel(pdb1, 'pdb', viewer=(0, 0))     view.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}}, viewer=(0, 0))     view.addLabel(title1, {'position': {'x': 0, 'y': 20, 'z': 0}, 'backgroundColor': 'white', 'fontColor':'black'}, viewer=(0, 0))          # Model 2     view.addModel(pdb2, 'pdb', viewer=(0, 1))     view.setStyle({'stick': {'radius': 0.15}, 'cartoon': {'color': 'spectrum'}}, viewer=(0, 1))     view.addLabel(title2, {'position': {'x': 0, 'y': 20, 'z': 0}, 'backgroundColor': 'white', 'fontColor':'black'}, viewer=(0, 1))          view.zoomTo()     view.center()     view.zoom(1.2)     view.show()  view_structures(linear_pdb, \"Linear Peptide\", cyclic_pdb, \"Cyclic Macrocycle\") In\u00a0[\u00a0]: Copied! <pre>print(\"--- Cyclic PDB Footer (CONECT records for loop closure) ---\")\nlines = cyclic_pdb.splitlines()\nconect_lines = [l for l in lines if l.startswith(\"CONECT\")]\nfor l in conect_lines[-3:]:\n    print(l)\n</pre> print(\"--- Cyclic PDB Footer (CONECT records for loop closure) ---\") lines = cyclic_pdb.splitlines() conect_lines = [l for l in lines if l.startswith(\"CONECT\")] for l in conect_lines[-3:]:     print(l) In\u00a0[\u00a0]: Copied! <pre># Generate 3 random macrocycles\nresults = []\nfor i in range(3):\n    print(f\"Generating Macrocycle {i+1}...\")\n    p = generate_pdb_content(length=7, cyclic=True, minimize_energy=True)\n    results.append(p)\n\nprint(\"\u2705 Generated library of 3 unique macrocycles.\")\n</pre> # Generate 3 random macrocycles results = [] for i in range(3):     print(f\"Generating Macrocycle {i+1}...\")     p = generate_pdb_content(length=7, cyclic=True, minimize_energy=True)     results.append(p)  print(\"\u2705 Generated library of 3 unique macrocycles.\")"},{"location":"tutorials/macrocycle_lab/#macrocycle-design-lab-engineering-cyclic-peptides","title":"\ud83d\udc8d Macrocycle Design Lab: Engineering Cyclic Peptides\u00b6","text":"<p>Objective: Explore how <code>synth-pdb</code> generates random cyclic peptides and visualize the \"closure\" of the macrocycle via physics-based minimization.</p>"},{"location":"tutorials/macrocycle_lab/#why-macrocycles","title":"\ud83d\udc8a Why Macrocycles?\u00b6","text":"<p>Macrocycles (cyclic peptides) are the \"Goldilocks\" of drug discovery. They are larger than small molecules but smaller than proteins, allowing them to bind to difficult targets while remaining stable in the body. They offer three key advantages over linear peptides:</p> <ul> <li>Improve Stability: Protect the peptide from degradation by proteases in the body.</li> <li>Increase Binding Affinity: Reduce the \"entropy penalty\" of binding by pre-shaping the peptide to match its target.</li> <li>Cross Membranes: Many cyclic peptides (like Cyclosporine A) can enter cells more easily than linear ones.</li> </ul> <p>In AI models (like AlphaFold-3), training on cyclic peptides is difficult because they are rare in the Protein Data Bank (PDB). <code>synth-pdb</code> allows you to generate millions of \"Correctly Closed\" macrocycles to train more robust models.</p> <ul> <li>Cyclosporine A: A famous immunosuppressant that is a 11-mer cyclic peptide.</li> <li>Oxytocin: The \"love hormone\" is a 9-mer cyclic peptide.</li> </ul>"},{"location":"tutorials/macrocycle_lab/#the-engineering-challenge","title":"\ud83c\udfd7\ufe0f The Engineering Challenge\u00b6","text":"<p>How do you \"close the ring\"? In this lab, we use Forcefield Minimization to pull the N-terminus and C-terminus together into a physically realistic bond.</p>"},{"location":"tutorials/macrocycle_lab/#1-generating-a-macrocycle","title":"1. Generating a Macrocycle\u00b6","text":"<p>We use the <code>cyclic=True</code> flag to signal the generator to produce a head-to-tail bond. However, simply placing atoms in space isn't enough\u2014the N-terminus and C-terminus might be far apart.</p> <p>To solve this, we use Physics-Based Minimization (<code>minimize_energy=True</code>) powered by OpenMM. This pulls the termini together into a physically plausible bond.</p>"},{"location":"tutorials/macrocycle_lab/#2-visual-comparison-linear-vs-cyclic","title":"2. Visual Comparison: Linear vs. Cyclic\u00b6","text":"<p>Observe the difference in the \"Global Topology\". Let's visualize both structures. In the cyclic version, you should see a continuous loop where the first and last residues are bonded, while the linear peptide remains a flexible string.</p>"},{"location":"tutorials/macrocycle_lab/#3-atomic-breakdown-the-closure-bond","title":"3. Atomic Breakdown: The Closure Bond\u00b6","text":"<p>Look at the <code>CONECT</code> records at the end of the PDB. This is how software knows the ring is closed.</p> <p>In a linear peptide, the N-terminus has extra hydrogens (or a capping group), and the C-terminus has an Oxygen (OXT). In a Cyclic peptide, these are replaced by a standard Peptide Bond (C-N).</p> <p>Notice in the PDB output of the cyclic peptide that residue 1 is bonded to residue 8.</p>"},{"location":"tutorials/macrocycle_lab/#4-scaling-the-lab-random-macrocycle-libraries","title":"4. Scaling the Lab: Random Macrocycle Libraries\u00b6","text":"<p>We can use this to generate a library of diverse macrocycles for ML datasets. By using <code>--minimize</code>, we ensure every structure is a geometrically valid \"negative\" or \"positive\" sample for a design model.</p>"},{"location":"tutorials/macrocycle_lab/#next-steps","title":"\ud83c\udfc6 Next Steps\u00b6","text":"<ol> <li>Try creating a D-Amino Acid macrocycle by adding <code>D-</code> to your sequence (e.g., <code>D-ALA-D-VAL</code>). How does the chiral inversion affect the ring shape? \ud83e\uddea\ud83d\udc8d</li> <li>Try changing the length or adding the <code>--refine-clashes</code> flag to see how it affects the density of the cyclic loop! \ud83d\ude80</li> </ol>"},{"location":"tutorials/ml_handover_demo/","title":"ML Integration: Data Factory Flow \ud83e\udd16","text":"<p>This notebook demonstrates how to use <code>synth-pdb</code> as a high-speed data factory for Training Protein AI models.</p> <p>We leverage the <code>BatchedGenerator</code> to produce thousands of structures in milliseconds and feed them directly into PyTorch and JAX with Zero-Copy memory handover.</p> In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\n# Ensure the local synth_pdb source code is prioritized if running from the repo\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  # Ensure the local synth_pdb source code is prioritized if running from the repo try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb py3Dmol')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         print(\"\u26a0\ufe0f Please wait 10 seconds, then Run All Cells again.\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__} from {synth_pdb.__file__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport time\nimport matplotlib.pyplot as plt\nfrom synth_pdb.batch_generator import BatchedGenerator\n\nprint(\"Libraries Loaded.\")\n</pre> import numpy as np import time import matplotlib.pyplot as plt from synth_pdb.batch_generator import BatchedGenerator  print(\"Libraries Loaded.\") In\u00a0[\u00a0]: Copied! <pre># Construct a clean sequence\nresidues = [\"ALA\", \"GLY\", \"SER\", \"LEU\", \"VAL\", \"ILE\", \"MET\"] * 7\nsequence = \"-\".join(residues)\nn_batch = 1000\n\ngenerator = BatchedGenerator(sequence, n_batch=n_batch, full_atom=False)\n\nstart = time.time()\nbatch = generator.generate_batch(drift=5.0)\nprint(f\"Generated {n_batch} structures.\")\n</pre> # Construct a clean sequence residues = [\"ALA\", \"GLY\", \"SER\", \"LEU\", \"VAL\", \"ILE\", \"MET\"] * 7 sequence = \"-\".join(residues) n_batch = 1000  generator = BatchedGenerator(sequence, n_batch=n_batch, full_atom=False)  start = time.time() batch = generator.generate_batch(drift=5.0) print(f\"Generated {n_batch} structures.\")  In\u00a0[\u00a0]: Copied! <pre>from synth_pdb.generator import generate_pdb_content\n\ndef run_benchmark(n=100):\n    start_serial = time.time()\n    for _ in range(n):\n        _ = generate_pdb_content(sequence_str=sequence, minimize_energy=False)\n    serial_dt = time.time() - start_serial\n    \n    start_batched = time.time()\n    _ = generator.generate_batch(drift=1.0)\n    batched_dt = time.time() - start_batched\n    \n    return serial_dt, batched_dt\n\nn_test = 100\ns_time, b_time = run_benchmark(n_test)\n\ns_1k = s_time * (1000/n_test)\nb_1k = b_time * (1000/n_batch) if n_batch &gt; 0 else b_time\n\nplt.figure(figsize=(8, 4))\nbars = plt.bar([\"Traditional Serial\", \"synth-pdb Batched\"], [s_1k, b_time], color=[\"#ff9999\", \"#667eea\"])\nplt.ylabel(\"Seconds per 1,000 Structures\")\nplt.title(f\"Real-World Performance Comparison\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\nfor bar in bars:\n    yval = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width()/2, yval + (s_1k*0.02), f\"{yval:.3f}s\", ha=\"center\", va=\"bottom\", fontweight=\"bold\")\n\nplt.show()\n\nprint(f\"Vectorization Speedup: {s_1k / b_time:.1f}x\")\nprint(f\"Theoretical throughput: {1000/b_time:.0f} structures/sec\")\n</pre> from synth_pdb.generator import generate_pdb_content  def run_benchmark(n=100):     start_serial = time.time()     for _ in range(n):         _ = generate_pdb_content(sequence_str=sequence, minimize_energy=False)     serial_dt = time.time() - start_serial          start_batched = time.time()     _ = generator.generate_batch(drift=1.0)     batched_dt = time.time() - start_batched          return serial_dt, batched_dt  n_test = 100 s_time, b_time = run_benchmark(n_test)  s_1k = s_time * (1000/n_test) b_1k = b_time * (1000/n_batch) if n_batch &gt; 0 else b_time  plt.figure(figsize=(8, 4)) bars = plt.bar([\"Traditional Serial\", \"synth-pdb Batched\"], [s_1k, b_time], color=[\"#ff9999\", \"#667eea\"]) plt.ylabel(\"Seconds per 1,000 Structures\") plt.title(f\"Real-World Performance Comparison\") plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)  for bar in bars:     yval = bar.get_height()     plt.text(bar.get_x() + bar.get_width()/2, yval + (s_1k*0.02), f\"{yval:.3f}s\", ha=\"center\", va=\"bottom\", fontweight=\"bold\")  plt.show()  print(f\"Vectorization Speedup: {s_1k / b_time:.1f}x\") print(f\"Theoretical throughput: {1000/b_time:.0f} structures/sec\") In\u00a0[\u00a0]: Copied! <pre>try:\n    import torch\n    \n    torch_tensor = torch.from_numpy(batch.coords).float()\n    \n    print(\"\u2705 PyTorch Handover successful!\")\n    print(f\"Tensor Device: {torch_tensor.device}\")\n    print(f\"Contiguous in memory: {torch_tensor.is_contiguous()}\")\nexcept ImportError:\n    print(\"\u274c PyTorch not found. Use 'pip install torch' to see this in action.\")\n</pre> try:     import torch          torch_tensor = torch.from_numpy(batch.coords).float()          print(\"\u2705 PyTorch Handover successful!\")     print(f\"Tensor Device: {torch_tensor.device}\")     print(f\"Contiguous in memory: {torch_tensor.is_contiguous()}\") except ImportError:     print(\"\u274c PyTorch not found. Use 'pip install torch' to see this in action.\") In\u00a0[\u00a0]: Copied! <pre>try:\n    import jax.numpy as jnp\n    \n    jax_array = jnp.array(batch.coords)\n    print(\"\u2705 JAX Handover successful!\")\n    print(f\"JAX Device: {jax_array.device}\")\nexcept ImportError:\n    print(\"\u274c JAX not found.\")\n</pre> try:     import jax.numpy as jnp          jax_array = jnp.array(batch.coords)     print(\"\u2705 JAX Handover successful!\")     print(f\"JAX Device: {jax_array.device}\") except ImportError:     print(\"\u274c JAX not found.\") In\u00a0[\u00a0]: Copied! <pre>plt.figure(figsize=(10, 6))\nfor i in range(10):\n    plt.plot(batch.coords[i, :, 0], batch.coords[i, :, 1], alpha=0.3, label=f\"Model {i}\" if i==0 else \"\")\n\nplt.title(\"Ensemble Drift: Structural Noise for ML Training\")\nplt.xlabel(\"X (\u00c5)\")\nplt.ylabel(\"Y (\u00c5)\")\nplt.legend()\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) for i in range(10):     plt.plot(batch.coords[i, :, 0], batch.coords[i, :, 1], alpha=0.3, label=f\"Model {i}\" if i==0 else \"\")  plt.title(\"Ensemble Drift: Structural Noise for ML Training\") plt.xlabel(\"X (\u00c5)\") plt.ylabel(\"Y (\u00c5)\") plt.legend() plt.show() In\u00a0[\u00a0]: Copied! <pre>try:\n    import py3Dmol\n    import numpy as np\n    from synth_pdb.batch_generator import BatchedPeptide\n    \n    c = batch.coords[0].copy()\n    mask = np.any(c != 0, axis=1)\n    c_clean = c[mask]\n    \n    center = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2\n    c_centered = c_clean - center\n    \n    p = BatchedPeptide(\n        c_centered[np.newaxis, ...], \n        batch.sequence, \n        np.array(batch.atom_names)[mask].tolist(), \n        np.array(batch.residue_indices)[mask].tolist()\n    )\n    \n    view = py3Dmol.view(width=800, height=400)\n    view.setBackgroundColor(\"#fdfdfd\")\n    view.addModel(p.to_pdb(0), \"pdb\")\n    view.setStyle({\"stick\": {\"radius\": 0.15}, \"cartoon\": {\"color\": \"spectrum\"}})\n    \n    view.zoomTo()\n    view.center()\n    view.zoom(1.2)\n    view.show()\n    \n    print(f\"Viewer Ready. Visualizing {len(c_clean)} atoms.\")\nexcept ImportError:\n    print(\"py3Dmol not installed.\")\n</pre> try:     import py3Dmol     import numpy as np     from synth_pdb.batch_generator import BatchedPeptide          c = batch.coords[0].copy()     mask = np.any(c != 0, axis=1)     c_clean = c[mask]          center = (c_clean.min(axis=0) + c_clean.max(axis=0)) / 2     c_centered = c_clean - center          p = BatchedPeptide(         c_centered[np.newaxis, ...],          batch.sequence,          np.array(batch.atom_names)[mask].tolist(),          np.array(batch.residue_indices)[mask].tolist()     )          view = py3Dmol.view(width=800, height=400)     view.setBackgroundColor(\"#fdfdfd\")     view.addModel(p.to_pdb(0), \"pdb\")     view.setStyle({\"stick\": {\"radius\": 0.15}, \"cartoon\": {\"color\": \"spectrum\"}})          view.zoomTo()     view.center()     view.zoom(1.2)     view.show()          print(f\"Viewer Ready. Visualizing {len(c_clean)} atoms.\") except ImportError:     print(\"py3Dmol not installed.\")"},{"location":"tutorials/ml_handover_demo/#ml-integration-data-factory-flow","title":"ML Integration: Data Factory Flow \ud83e\udd16\u00b6","text":""},{"location":"tutorials/ml_handover_demo/#the-data-factory-workflow","title":"The Data Factory Workflow\u00b6","text":"<p>Traditional structural bio tools are optimized for single-file PDB processing. <code>synth-pdb</code> is optimized for tensor throughput.</p> <p></p>"},{"location":"tutorials/ml_handover_demo/#how-to-run-important","title":"\u26a0\ufe0f How to Run (Important!)\u00b6","text":"<p>This notebook requires a specific environment setup. Follow these steps strictly:</p> <ol> <li>Run All Cells (<code>Runtime</code> -&gt; <code>Run all</code> or <code>Ctrl+F9</code>).</li> <li>Wait for the Crash: If on Colab, the setup cell will automatically restart the session to load libraries. This is normal.</li> <li>Local Users: If you are running locally after editing the library code, Restart your Kernel manually to ensure changes take effect.</li> <li>Wait 10 Seconds: Allow the session to reconnect.</li> <li>Run All Cells AGAIN: This time, the setup will detect it is ready ('\u2705 Dependencies Ready') and proceed typically.</li> </ol>"},{"location":"tutorials/ml_handover_demo/#1-high-speed-generation","title":"1. High-Speed Generation\u00b6","text":"<p>We'll generate a batch of 1,000 peptides of length 50. In a traditional serial loop, this would take significant time. In <code>synth-pdb</code>, it's a single matrix operation.</p>"},{"location":"tutorials/ml_handover_demo/#benchmark-serial-vs-batched-generation","title":"Benchmark: Serial vs. Batched Generation\u00b6","text":"<p>Why use <code>BatchedGenerator</code>? Below we compare the time to generate 1000 structures one-by-one vs. generating them in a single batch.</p>"},{"location":"tutorials/ml_handover_demo/#2-pytorch-handover-zero-copy","title":"2. PyTorch Handover (Zero-Copy)\u00b6","text":"<p>PyTorch can \"wrap\" a NumPy array without copying it. Any change to the NumPy array will be reflected in the Tensor (and vice versa).</p>"},{"location":"tutorials/ml_handover_demo/#3-jax-mlx-handover","title":"3. JAX / MLX Handover\u00b6","text":"<p>JAX also supports efficient conversion from NumPy.</p>"},{"location":"tutorials/ml_handover_demo/#4-educational-note-why-does-this-matter","title":"4. Educational Note: Why does this matter?\u00b6","text":"<p>In deep learning for proteins, the Data Loading step is often the bottleneck. If your GPU has to wait for Python loops to calculate coordinates, it sits idle.</p> <p>By using <code>BatchedGenerator</code>, you can:</p> <ol> <li>Keep generation on the CPU/AMX units while the GPU trains.</li> <li>Avoid expensive serialized PDB parsing.</li> <li>Feed thousands of \"Hard Decoys\" (structures with noise) to help your model learn the energy landscape.</li> </ol>"},{"location":"tutorials/ml_handover_demo/#4-visualizing-the-data-structural-ensembles","title":"4. Visualizing the Data: Structural Ensembles\u00b6","text":"<p>In ML, we often want to train on \"Hard Decoys\"\u2014structures that are mostly correct but have physical noise. <code>BatchedGenerator</code> can produce these ensembles instantly.</p>"},{"location":"tutorials/ml_handover_demo/#interactive-3d-inspection","title":"Interactive 3D Inspection\u00b6","text":"<p>Use <code>3Dmol.js</code> to inspect a sample structure from the batch.</p>"},{"location":"tutorials/nerf_geometry_lab/","title":"\ud83d\udd2c The NeRF Geometry Lab","text":"In\u00a0[\u00a0]: Copied! <pre># \ud83d\udd27 Environment Detection &amp; Setup\nimport sys, os\nIN_COLAB = 'google.colab' in sys.modules\n\nif IN_COLAB:\n    print('\ud83c\udf10 Running in Google Colab')\n    try:\n        import synth_pdb\n        print('   \u2705 synth-pdb already installed')\n    except ImportError:\n        print('   \ud83d\udce6 Installing synth-pdb...')\n        !pip install -q synth-pdb\n        print('   \u2705 Installation complete')\n    import plotly.io as pio\n    pio.renderers.default = 'colab'\nelse:\n    print('\ud83d\udcbb Running in local Jupyter environment')\n    sys.path.append(os.path.abspath('../../'))\n\nprint('\u2705 Environment configured!')\n</pre> # \ud83d\udd27 Environment Detection &amp; Setup import sys, os IN_COLAB = 'google.colab' in sys.modules  if IN_COLAB:     print('\ud83c\udf10 Running in Google Colab')     try:         import synth_pdb         print('   \u2705 synth-pdb already installed')     except ImportError:         print('   \ud83d\udce6 Installing synth-pdb...')         !pip install -q synth-pdb         print('   \u2705 Installation complete')     import plotly.io as pio     pio.renderers.default = 'colab' else:     print('\ud83d\udcbb Running in local Jupyter environment')     sys.path.append(os.path.abspath('../../'))  print('\u2705 Environment configured!') In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, HTML, clear_output\nimport ipywidgets as widgets\nimport numpy as np\nimport py3Dmol\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom synth_pdb import PeptideGenerator\nfrom biotite.structure.io.pdb import PDBFile\nimport io\n\ngen = PeptideGenerator('ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA')\nprint('\u2705 NeRF Geometry Lab Ready!')\nprint('   Loaded: 10-residue polyalanine \u03b1-helix')\n</pre> from IPython.display import display, HTML, clear_output import ipywidgets as widgets import numpy as np import py3Dmol import plotly.graph_objects as go from plotly.subplots import make_subplots from synth_pdb import PeptideGenerator from biotite.structure.io.pdb import PDBFile import io  gen = PeptideGenerator('ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA-ALA') print('\u2705 NeRF Geometry Lab Ready!') print('   Loaded: 10-residue polyalanine \u03b1-helix') In\u00a0[\u00a0]: Copied! <pre># Output area\nout = widgets.Output()\n\n# Sliders with enhanced styling\nphi_slider = widgets.FloatSlider(\n    min=-180, max=180, step=10, value=0,\n    description='\u0394\u03c6:',\n    continuous_update=False,\n    style={'description_width': '50px'},\n    layout=widgets.Layout(width='500px')\n)\n\npsi_slider = widgets.FloatSlider(\n    min=-180, max=180, step=10, value=0,\n    description='\u0394\u03c8:',\n    continuous_update=False,\n    style={'description_width': '50px'},\n    layout=widgets.Layout(width='500px')\n)\n\n# Track initialization\n_initializing = True\n\ndef update(change=None):\n    global _initializing\n    if _initializing and change is not None:\n        return\n    \n    phi, psi = phi_slider.value, psi_slider.value\n    phis, psis = [-57.0]*10, [-47.0]*10\n    phis[4] += phi\n    psis[4] += psi\n    res = gen.generate(phi_list=phis, psi_list=psis)\n    \n    final_phi = -57.0 + phi\n    final_psi = -47.0 + psi\n    \n    # Determine region\n    region = 'Unknown'\n    region_color = '#FFD700'\n    if -90 &lt; final_phi &lt; -30 and -70 &lt; final_psi &lt; -20:\n        region = '\u03b1-helix \u2713'\n        region_color = '#00FF00'\n    elif -150 &lt; final_phi &lt; -90 and 90 &lt; final_psi &lt; 150:\n        region = '\u03b2-sheet \u2713'\n        region_color = '#87CEEB'\n    elif -90 &lt; final_phi &lt; -60 and 120 &lt; final_psi &lt; 170:\n        region = 'PPII \u2713'\n        region_color = '#90EE90'\n    else:\n        region = 'Non-canonical \u26a0\ufe0f'\n        region_color = '#FF6B6B'\n    \n    with out:\n        clear_output(wait=True)\n        \n        # Info panel\n        display(HTML(f\"\"\"\n        &lt;div style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n                    color: white; padding: 15px; border-radius: 10px;\n                    font-family: monospace; box-shadow: 0 4px 6px rgba(0,0,0,0.3);\n                    margin-bottom: 15px;'&gt;\n            &lt;b&gt;\ud83c\udfaf Current Angles:&lt;/b&gt;&lt;br&gt;\n            \u03c6 = {final_phi:.1f}\u00b0 | \u03c8 = {final_psi:.1f}\u00b0&lt;br&gt;\n            &lt;b&gt;Region:&lt;/b&gt; &lt;span style='color: {region_color};'&gt;{region}&lt;/span&gt;\n        &lt;/div&gt;\n        \"\"\"))\n        \n        # 3D structure\n        pf = PDBFile()\n        pf.set_structure(res.structure)\n        s = io.StringIO()\n        pf.write(s)\n        v = py3Dmol.view(width=700, height=400)\n        v.addModel(s.getvalue(), 'pdb')\n        v.setStyle({'stick': {'colorscheme': 'chainHetatm', 'radius': 0.15}})\n        v.setStyle({'resi': 5}, {'stick': {'color': 'red', 'radius': 0.25}})\n        v.setBackgroundColor('#1a1a1a')\n        v.zoomTo()\n        display(v.show())\n        \n        # Plots\n        fig = make_subplots(\n            rows=1, cols=2,\n            subplot_titles=('Ramachandran Plot', 'C\u03b1 Distance Matrix')\n        )\n        \n        # Ramachandran with regions\n        regions = [\n            dict(type='rect', x0=-90, x1=-30, y0=-70, y1=-20,\n                 fillcolor='rgba(0,100,200,0.2)', line=dict(width=0)),\n            dict(type='rect', x0=-150, x1=-90, y0=90, y1=150,\n                 fillcolor='rgba(200,100,0,0.2)', line=dict(width=0)),\n            dict(type='rect', x0=-90, x1=-60, y0=120, y1=170,\n                 fillcolor='rgba(100,200,0,0.2)', line=dict(width=0))\n        ]\n        for r in regions:\n            fig.add_shape(r, row=1, col=1)\n        \n        fig.add_trace(go.Scatter(\n            x=[final_phi], y=[final_psi], mode='markers',\n            marker=dict(size=15, color='red', symbol='star',\n                       line=dict(color='white', width=2)),\n            hovertemplate='\u03c6: %{x:.1f}\u00b0&lt;br&gt;\u03c8: %{y:.1f}\u00b0&lt;extra&gt;&lt;/extra&gt;'\n        ), row=1, col=1)\n        \n        fig.update_xaxes(title_text='Phi \u03c6 (degrees)', range=[-180,180], dtick=60, row=1, col=1)\n        fig.update_yaxes(title_text='Psi \u03c8 (degrees)', range=[-180,180], dtick=60, row=1, col=1)\n        \n        # Distance matrix\n        ca = res.structure[res.structure.atom_name=='CA']\n        n = len(ca)\n        dm = np.zeros((n,n))\n        for i in range(n):\n            for j in range(n):\n                dm[i,j] = np.linalg.norm(ca.coord[i] - ca.coord[j])\n        \n        fig.add_trace(go.Heatmap(\n            z=dm, colorscale='Viridis',\n            colorbar=dict(title='Distance (\u00c5)'),\n            hovertemplate='Residue %{x} \u2194 %{y}&lt;br&gt;Distance: %{z:.1f} \u00c5&lt;extra&gt;&lt;/extra&gt;'\n        ), row=1, col=2)\n        \n        fig.update_xaxes(title_text='Residue', dtick=1, row=1, col=2)\n        fig.update_yaxes(title_text='Residue', dtick=1, row=1, col=2)\n        \n        fig.update_layout(\n            height=400, width=900,\n            template='plotly_dark',\n            showlegend=False\n        )\n        display(fig)\n\n# Connect sliders\nphi_slider.observe(update, 'value')\npsi_slider.observe(update, 'value')\n\n# Display UI\ndisplay(widgets.VBox([phi_slider, psi_slider, out]))\n\n# Initialize\n_initializing = False\nupdate()\n</pre> # Output area out = widgets.Output()  # Sliders with enhanced styling phi_slider = widgets.FloatSlider(     min=-180, max=180, step=10, value=0,     description='\u0394\u03c6:',     continuous_update=False,     style={'description_width': '50px'},     layout=widgets.Layout(width='500px') )  psi_slider = widgets.FloatSlider(     min=-180, max=180, step=10, value=0,     description='\u0394\u03c8:',     continuous_update=False,     style={'description_width': '50px'},     layout=widgets.Layout(width='500px') )  # Track initialization _initializing = True  def update(change=None):     global _initializing     if _initializing and change is not None:         return          phi, psi = phi_slider.value, psi_slider.value     phis, psis = [-57.0]*10, [-47.0]*10     phis[4] += phi     psis[4] += psi     res = gen.generate(phi_list=phis, psi_list=psis)          final_phi = -57.0 + phi     final_psi = -47.0 + psi          # Determine region     region = 'Unknown'     region_color = '#FFD700'     if -90 &lt; final_phi &lt; -30 and -70 &lt; final_psi &lt; -20:         region = '\u03b1-helix \u2713'         region_color = '#00FF00'     elif -150 &lt; final_phi &lt; -90 and 90 &lt; final_psi &lt; 150:         region = '\u03b2-sheet \u2713'         region_color = '#87CEEB'     elif -90 &lt; final_phi &lt; -60 and 120 &lt; final_psi &lt; 170:         region = 'PPII \u2713'         region_color = '#90EE90'     else:         region = 'Non-canonical \u26a0\ufe0f'         region_color = '#FF6B6B'          with out:         clear_output(wait=True)                  # Info panel         display(HTML(f\"\"\"          \ud83c\udfaf Current Angles:             \u03c6 = {final_phi:.1f}\u00b0 | \u03c8 = {final_psi:.1f}\u00b0 Region: {region}          \"\"\"))                  # 3D structure         pf = PDBFile()         pf.set_structure(res.structure)         s = io.StringIO()         pf.write(s)         v = py3Dmol.view(width=700, height=400)         v.addModel(s.getvalue(), 'pdb')         v.setStyle({'stick': {'colorscheme': 'chainHetatm', 'radius': 0.15}})         v.setStyle({'resi': 5}, {'stick': {'color': 'red', 'radius': 0.25}})         v.setBackgroundColor('#1a1a1a')         v.zoomTo()         display(v.show())                  # Plots         fig = make_subplots(             rows=1, cols=2,             subplot_titles=('Ramachandran Plot', 'C\u03b1 Distance Matrix')         )                  # Ramachandran with regions         regions = [             dict(type='rect', x0=-90, x1=-30, y0=-70, y1=-20,                  fillcolor='rgba(0,100,200,0.2)', line=dict(width=0)),             dict(type='rect', x0=-150, x1=-90, y0=90, y1=150,                  fillcolor='rgba(200,100,0,0.2)', line=dict(width=0)),             dict(type='rect', x0=-90, x1=-60, y0=120, y1=170,                  fillcolor='rgba(100,200,0,0.2)', line=dict(width=0))         ]         for r in regions:             fig.add_shape(r, row=1, col=1)                  fig.add_trace(go.Scatter(             x=[final_phi], y=[final_psi], mode='markers',             marker=dict(size=15, color='red', symbol='star',                        line=dict(color='white', width=2)),             hovertemplate='\u03c6: %{x:.1f}\u00b0\u03c8: %{y:.1f}\u00b0'         ), row=1, col=1)                  fig.update_xaxes(title_text='Phi \u03c6 (degrees)', range=[-180,180], dtick=60, row=1, col=1)         fig.update_yaxes(title_text='Psi \u03c8 (degrees)', range=[-180,180], dtick=60, row=1, col=1)                  # Distance matrix         ca = res.structure[res.structure.atom_name=='CA']         n = len(ca)         dm = np.zeros((n,n))         for i in range(n):             for j in range(n):                 dm[i,j] = np.linalg.norm(ca.coord[i] - ca.coord[j])                  fig.add_trace(go.Heatmap(             z=dm, colorscale='Viridis',             colorbar=dict(title='Distance (\u00c5)'),             hovertemplate='Residue %{x} \u2194 %{y}Distance: %{z:.1f} \u00c5'         ), row=1, col=2)                  fig.update_xaxes(title_text='Residue', dtick=1, row=1, col=2)         fig.update_yaxes(title_text='Residue', dtick=1, row=1, col=2)                  fig.update_layout(             height=400, width=900,             template='plotly_dark',             showlegend=False         )         display(fig)  # Connect sliders phi_slider.observe(update, 'value') psi_slider.observe(update, 'value')  # Display UI display(widgets.VBox([phi_slider, psi_slider, out]))  # Initialize _initializing = False update()"},{"location":"tutorials/nerf_geometry_lab/#the-nerf-geometry-lab","title":"\ud83d\udd2c The NeRF Geometry Lab\u00b6","text":""},{"location":"tutorials/nerf_geometry_lab/#interactive-exploration-of-the-hidden-math-behind-protein-ai","title":"Interactive Exploration of the \"Hidden Math\" Behind Protein AI\u00b6","text":""},{"location":"tutorials/nerf_geometry_lab/#what-youll-learn","title":"\ud83c\udfaf What You'll Learn\u00b6","text":"<p>Most modern protein AI models (like AlphaFold and trRosetta) don't predict 3D coordinates directly. Instead, they predict internal coordinates (bond lengths, angles, and torsions) and then use an algorithm called NeRF (Natural Extension Reference Frame) to build the 3D model atom-by-atom.</p> <p>In this tutorial:</p> <ol> <li>\ud83d\udcd0 Explore the Z-Matrix (internal coordinate representation)</li> <li>\ud83c\udf9b\ufe0f Use interactive sliders to manipulate backbone torsions (\u03c6 and \u03c8)</li> <li>\ud83d\udcca Watch a real-time Ramachandran plot update as you change angles</li> <li>\ud83d\uddfa\ufe0f Visualize distance matrices showing how local changes affect global structure</li> </ol> <p>\ud83d\udca1 Why This Matters: Understanding internal coordinates is crucial for protein structure prediction, molecular dynamics, and protein design. This is the mathematical foundation of modern structural biology AI.</p>"},{"location":"tutorials/nerf_geometry_lab/#internal-coordinates-the-language-of-protein-structure","title":"\ud83d\udcda Internal Coordinates: The Language of Protein Structure\u00b6","text":""},{"location":"tutorials/nerf_geometry_lab/#z-matrix-representation","title":"Z-Matrix Representation\u00b6","text":"<p>Instead of Cartesian coordinates (x, y, z), proteins can be described using internal coordinates:</p> Coordinate Symbol Description Typical Range Bond Length r Distance between bonded atoms 1.0-1.5 \u00c5 Bond Angle \u03b8 Angle between 3 consecutive atoms 100-120\u00b0 Dihedral Angle \u03c6, \u03c8, \u03c9 Rotation around bonds -180\u00b0 to +180\u00b0"},{"location":"tutorials/nerf_geometry_lab/#the-backbone-dihedrals","title":"The Backbone Dihedrals\u00b6","text":"<p>For each residue i, we have three key angles:</p> <p>$$\\phi_i = \\text{dihedral}(C_{i-1}, N_i, C\\alpha_i, C_i)$$ $$\\psi_i = \\text{dihedral}(N_i, C\\alpha_i, C_i, N_{i+1})$$ $$\\omega_i = \\text{dihedral}(C\\alpha_i, C_i, N_{i+1}, C\\alpha_{i+1})$$</p> <ul> <li>\u03c6 (phi): Rotation around N-C\u03b1 bond</li> <li>\u03c8 (psi): Rotation around C\u03b1-C bond</li> <li>\u03c9 (omega): Peptide bond rotation (usually ~180\u00b0 for trans, ~0\u00b0 for cis)</li> </ul> <p>\ud83d\udd2c NeRF Algorithm: Given these angles, NeRF reconstructs 3D coordinates by:</p> <ol> <li>Placing the first 3 atoms arbitrarily</li> <li>For each new atom: use bond length, angle, and dihedral to calculate position</li> <li>Build the entire structure atom-by-atom in a single forward pass</li> </ol>"},{"location":"tutorials/nerf_geometry_lab/#interactive-geometry-lab","title":"\ud83c\udf9b\ufe0f Interactive Geometry Lab\u00b6","text":"<p>Use the sliders below to modify the \u03c6 and \u03c8 angles of the central residue (residue 5). Watch how:</p> <ul> <li>The 3D structure changes in real-time</li> <li>The Ramachandran plot shows your current position</li> <li>The distance matrix reveals how local changes affect global structure</li> </ul> <p>Try these experiments:</p> <ul> <li>Move to the \u03b2-sheet region: \u03c6 \u2248 -120\u00b0, \u03c8 \u2248 +120\u00b0</li> <li>Explore forbidden regions and see steric clashes</li> <li>Create a \u03b2-turn by setting \u03c6 \u2248 -60\u00b0, \u03c8 \u2248 -30\u00b0</li> </ul> <p>\u26a0\ufe0f Important: If you see duplicate visualizations, restart your kernel (Kernel \u2192 Restart Kernel) and run all cells from the top.</p>"},{"location":"tutorials/nerf_geometry_lab/#key-insights","title":"\ud83c\udf93 Key Insights\u00b6","text":"<ol> <li>Local Changes \u2192 Global Effects: Changing one residue's angles affects the entire downstream structure</li> <li>Ramachandran Constraints: Only certain \u03c6/\u03c8 combinations are sterically allowed</li> <li>Distance Patterns: \u03b1-helices show characteristic i, i+4 contacts; \u03b2-sheets show long-range contacts</li> <li>NeRF Reconstruction: This is exactly how AlphaFold and other AI models build 3D structures!</li> </ol>"},{"location":"tutorials/nerf_geometry_lab/#further-reading","title":"\ud83d\udcd6 Further Reading\u00b6","text":"<ul> <li>Jumper et al. (2021). \"Highly accurate protein structure prediction with AlphaFold.\" Nature 596:583-589. DOI: 10.1038/s41586-021-03819-2</li> <li>Parsons et al. (2005). \"Practical conversion from torsion space to Cartesian space for in silico protein synthesis.\" J Comput Chem 26:1063-1068. DOI: 10.1002/jcc.20237</li> <li>Ramachandran et al. (1963). \"Stereochemistry of polypeptide chain configurations.\" J Mol Biol 7:95-99. DOI: 10.1016/S0022-2836(63)80023-680023-6)</li> </ul> \ud83c\udf89 Lab Session Complete! <p>You've mastered internal coordinates and NeRF geometry!</p>"},{"location":"tutorials/neural_nmr_pipeline/","title":"\ud83e\udde0 Multi-Modal AI Research: The Structural-Magnetic Bridge \u269b\ufe0f","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb torch numpy matplotlib py3Dmol biotite')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb torch numpy matplotlib py3Dmol biotite')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\") In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport time\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nimport matplotlib.pyplot as plt\nimport py3Dmol\nimport biotite.structure as struc\nfrom synth_pdb.batch_generator import BatchedGenerator\nfrom synth_pdb.chemical_shifts import predict_chemical_shifts, calculate_csi\nfrom synth_pdb.generator import generate_pdb_content\n\nprint(\"Magnetic Resonance Engine: ONLINE \u26a1\")\n</pre> import numpy as np import time import torch from torch.utils.data import Dataset, DataLoader import matplotlib.pyplot as plt import py3Dmol import biotite.structure as struc from synth_pdb.batch_generator import BatchedGenerator from synth_pdb.chemical_shifts import predict_chemical_shifts, calculate_csi from synth_pdb.generator import generate_pdb_content  print(\"Magnetic Resonance Engine: ONLINE \u26a1\") In\u00a0[\u00a0]: Copied! <pre># FIX: Use explicit hyphenation to avoid 'ASPTRP' merging errors\nsequence = \"-\".join([\"TRP-PHE-TYR-HIS-LYS-GLU-ASP\"] * 3) # 21 residues, rich in Aromatics\nn_samples = 100\n\nprint(f\"\ud83d\ude80 Generating {n_samples} synchronized multi-modal structural samples...\")\n\ngenerator = BatchedGenerator(sequence, n_batch=n_samples, full_atom=True)\nbatch = generator.generate_batch(drift=2.0) \n\nprint(\"\u2705 Structural Tensors Generated.\")\nprint(\"\u26a1 Predicting Chemical Shifts (SPARTA-Lite + Ring Currents)...\")\n\nall_shifts = []\nfor i in range(5): # We'll analyze the first 5 in detail for the demo\n    # Convert batch member to biotite structure for the NMR engine\n    pdb_str = batch.to_pdb(i)\n    from io import StringIO\n    import biotite.structure.io.pdb as pdb_io\n    struct = pdb_io.PDBFile.read(StringIO(pdb_str)).get_structure(model=1)\n    \n    shifts = predict_chemical_shifts(struct)\n    all_shifts.append(shifts)\n\nprint(f\"\u2705 Paired Data Ready. Sample 0 Chain A Res 1 chemical shifts: {all_shifts[0]['A'][1]}\")\n</pre> # FIX: Use explicit hyphenation to avoid 'ASPTRP' merging errors sequence = \"-\".join([\"TRP-PHE-TYR-HIS-LYS-GLU-ASP\"] * 3) # 21 residues, rich in Aromatics n_samples = 100  print(f\"\ud83d\ude80 Generating {n_samples} synchronized multi-modal structural samples...\")  generator = BatchedGenerator(sequence, n_batch=n_samples, full_atom=True) batch = generator.generate_batch(drift=2.0)   print(\"\u2705 Structural Tensors Generated.\") print(\"\u26a1 Predicting Chemical Shifts (SPARTA-Lite + Ring Currents)...\")  all_shifts = [] for i in range(5): # We'll analyze the first 5 in detail for the demo     # Convert batch member to biotite structure for the NMR engine     pdb_str = batch.to_pdb(i)     from io import StringIO     import biotite.structure.io.pdb as pdb_io     struct = pdb_io.PDBFile.read(StringIO(pdb_str)).get_structure(model=1)          shifts = predict_chemical_shifts(struct)     all_shifts.append(shifts)  print(f\"\u2705 Paired Data Ready. Sample 0 Chain A Res 1 chemical shifts: {all_shifts[0]['A'][1]}\") In\u00a0[\u00a0]: Copied! <pre># Extract CA secondary shifts for Sample 0\nsample_idx = 0\nres_ids = sorted(all_shifts[sample_idx]['A'].keys())\nca_deltas = [all_shifts[sample_idx]['A'][r].get('CA', 0) - 52.5 for r in res_ids] # Relative to generic Ala baseline for visual\n\nplt.figure(figsize=(12, 4))\nplt.bar(res_ids, ca_deltas, color='#9b59b6', alpha=0.7, label=\"Delta-CA (Secondary Shift)\")\nplt.axhline(0.7, color='red', linestyle='--', alpha=0.3, label=\"Helix Threshold\")\nplt.axhline(-0.7, color='blue', linestyle='--', alpha=0.3, label=\"Sheet Threshold\")\nplt.title(\"The Magnetic Footprint of Protein Folding\")\nplt.xlabel(\"Residue Number\")\nplt.ylabel(\"CSI Deviation (ppm)\")\nplt.legend()\nplt.grid(alpha=0.2)\nplt.show()\n\nprint(\"Educational Insight: Note how consistent positive deviations signal a stable secondary structure.\")\n</pre> # Extract CA secondary shifts for Sample 0 sample_idx = 0 res_ids = sorted(all_shifts[sample_idx]['A'].keys()) ca_deltas = [all_shifts[sample_idx]['A'][r].get('CA', 0) - 52.5 for r in res_ids] # Relative to generic Ala baseline for visual  plt.figure(figsize=(12, 4)) plt.bar(res_ids, ca_deltas, color='#9b59b6', alpha=0.7, label=\"Delta-CA (Secondary Shift)\") plt.axhline(0.7, color='red', linestyle='--', alpha=0.3, label=\"Helix Threshold\") plt.axhline(-0.7, color='blue', linestyle='--', alpha=0.3, label=\"Sheet Threshold\") plt.title(\"The Magnetic Footprint of Protein Folding\") plt.xlabel(\"Residue Number\") plt.ylabel(\"CSI Deviation (ppm)\") plt.legend() plt.grid(alpha=0.2) plt.show()  print(\"Educational Insight: Note how consistent positive deviations signal a stable secondary structure.\") In\u00a0[\u00a0]: Copied! <pre>view = py3Dmol.view(width=800, height=400)\nview.setBackgroundColor(\"#fdfdfd\")\n\npdb_str = batch.to_pdb(0)\n\n# 1. Highlight the Aromatic Rings\nview.addModel(pdb_str, 'pdb')\nview.setStyle({'model': 0}, {'cartoon': {'color': '#667eea', 'opacity': 0.6}})\nview.setStyle({'resn': ['PHE', 'TYR', 'TRP']}, {'stick': {'radius': 0.25, 'color': '#ffcc00'}})\n\n# 2. Show the \"Magnetic Cloud\"\n# We'll put a surface around aromatics to visualize the 'Influence Zone'\nview.addSurface(py3Dmol.MS, {'opacity': 0.2, 'color': '#ffcc00'}, {'resn': ['PHE', 'TYR', 'TRP']})\n\nview.zoomTo()\nview.center()\nview.show()\n\nprint(\"Yellow regions indicate Aromatic hubs that distort the local magnetic field of nearby nuclei.\")\n</pre> view = py3Dmol.view(width=800, height=400) view.setBackgroundColor(\"#fdfdfd\")  pdb_str = batch.to_pdb(0)  # 1. Highlight the Aromatic Rings view.addModel(pdb_str, 'pdb') view.setStyle({'model': 0}, {'cartoon': {'color': '#667eea', 'opacity': 0.6}}) view.setStyle({'resn': ['PHE', 'TYR', 'TRP']}, {'stick': {'radius': 0.25, 'color': '#ffcc00'}})  # 2. Show the \"Magnetic Cloud\" # We'll put a surface around aromatics to visualize the 'Influence Zone' view.addSurface(py3Dmol.MS, {'opacity': 0.2, 'color': '#ffcc00'}, {'resn': ['PHE', 'TYR', 'TRP']})  view.zoomTo() view.center() view.show()  print(\"Yellow regions indicate Aromatic hubs that distort the local magnetic field of nearby nuclei.\") In\u00a0[\u00a0]: Copied! <pre>class MultiModalProteinDataset(Dataset):\n    def __init__(self, coords, shifts_list):\n        self.coords = torch.from_numpy(coords).float()\n        # Tensorize the 'CA' and 'HA' shifts as features\n        n_samples = len(shifts_list)\n        n_res = coords.shape[1] // 4 # Approximate for backbone clusters\n        \n        self.nmr_features = torch.zeros((n_samples, n_res, 2)) # [CA_shift, HA_shift]\n        \n        for i in range(n_samples):\n            # Only use chain A for the demo\n            if 'A' not in shifts_list[i]: continue\n            s = shifts_list[i]['A']\n            sorted_keys = sorted(s.keys())\n            for r_idx, r_id in enumerate(sorted_keys):\n                if r_idx &lt; n_res:\n                    self.nmr_features[i, r_idx, 0] = s[r_id].get('CA', 0.0)\n                    self.nmr_features[i, r_idx, 1] = s[r_id].get('HA', 0.0)\n                    \n    def __len__(self):\n        return len(self.coords)\n        \n    def __getitem__(self, idx):\n        return self.coords[idx], self.nmr_features[idx]\n\n# Create the synchronized dataset\nds = MultiModalProteinDataset(batch.coords[:5], all_shifts)\nloader = DataLoader(ds, batch_size=2, shuffle=True)\n\nbatch_coords, batch_nmr = next(iter(loader))\nprint(f\"\u2705 Multi-Modal Batch Data Ready.\")\nprint(f\"Geometry Shape: {batch_coords.shape}\")\nprint(f\"NMR Tensor Shape: {batch_nmr.shape} (Input for Transformer Encoded Shifts)\")\n</pre> class MultiModalProteinDataset(Dataset):     def __init__(self, coords, shifts_list):         self.coords = torch.from_numpy(coords).float()         # Tensorize the 'CA' and 'HA' shifts as features         n_samples = len(shifts_list)         n_res = coords.shape[1] // 4 # Approximate for backbone clusters                  self.nmr_features = torch.zeros((n_samples, n_res, 2)) # [CA_shift, HA_shift]                  for i in range(n_samples):             # Only use chain A for the demo             if 'A' not in shifts_list[i]: continue             s = shifts_list[i]['A']             sorted_keys = sorted(s.keys())             for r_idx, r_id in enumerate(sorted_keys):                 if r_idx &lt; n_res:                     self.nmr_features[i, r_idx, 0] = s[r_id].get('CA', 0.0)                     self.nmr_features[i, r_idx, 1] = s[r_id].get('HA', 0.0)                          def __len__(self):         return len(self.coords)              def __getitem__(self, idx):         return self.coords[idx], self.nmr_features[idx]  # Create the synchronized dataset ds = MultiModalProteinDataset(batch.coords[:5], all_shifts) loader = DataLoader(ds, batch_size=2, shuffle=True)  batch_coords, batch_nmr = next(iter(loader)) print(f\"\u2705 Multi-Modal Batch Data Ready.\") print(f\"Geometry Shape: {batch_coords.shape}\") print(f\"NMR Tensor Shape: {batch_nmr.shape} (Input for Transformer Encoded Shifts)\")"},{"location":"tutorials/neural_nmr_pipeline/#multi-modal-ai-research-the-structural-magnetic-bridge","title":"\ud83e\udde0 Multi-Modal AI Research: The Structural-Magnetic Bridge \u269b\ufe0f\u00b6","text":"<p>Objective: Learn how to generate synchronized datasets of 3D Structural Tensors and Experimental observables (NMR Chemical Shifts) for Multi-Modal AI training.</p>"},{"location":"tutorials/neural_nmr_pipeline/#the-vision-alphafold-nmr","title":"\ud83c\udf1f The Vision: \"AlphaFold-NMR\"\u00b6","text":"<p>In modern structural biology, 3D coordinates are only half the story. Real experimental verification often comes from Nuclear Magnetic Resonance (NMR). NMR chemical shifts are incredibly sensitive to the local electronic environment\u2014meaning every atom's magnetic frequency is a \"fingerprint\" of the local geometry.</p> <p>In this lab, we build an end-to-end pipeline that treats the protein as both a Geometric Object and a Magnetic Observable. This data is used to train models that can:</p> <ol> <li>Back-Calculate: Predict NMR shifts from structure.</li> <li>De-Novo Solve: Predict structure directly from chemical shifts.</li> </ol>"},{"location":"tutorials/neural_nmr_pipeline/#1-synchronized-generation-the-coords-shift-tensor","title":"1. Synchronized Generation: The Coords-Shift Tensor\u00b6","text":"<p>We will generate a batch of structures with significant structural drift, then compute the resulting chemical shifts for every atom. This creates a paired dataset: <code>(X, Y) = (Coordinates, NMR Shifts)</code>.</p>"},{"location":"tutorials/neural_nmr_pipeline/#2-fold-recognition-the-csi-plot","title":"2. Fold Recognition: The CSI Plot\u00b6","text":"<p>The Chemical Shift Index (CSI) is the deviation of an atom's frequency from its \"Random Coil\" baseline.</p> <ul> <li>Alpha Helices: Move C-alpha shifts Upfield (+ ppm).</li> <li>Beta Sheets: Move C-alpha shifts Downfield (- ppm).</li> </ul> <p>Let's visualize this footprint for our first sample.</p>"},{"location":"tutorials/neural_nmr_pipeline/#3-visualizing-ring-current-effects-tertiary-proximity","title":"3. Visualizing Ring Current Effects (Tertiary Proximity)\u00b6","text":"<p>Aromatic rings (Phe, Tyr, Trp) act like tiny electromagnets. Atoms that get too close to the \"face\" of the ring are shielded and shift toward lower frequencies. This is how NMR \"sees\" tertiary packing.</p>"},{"location":"tutorials/neural_nmr_pipeline/#4-multi-modal-pytorch-pipeline","title":"4. Multi-Modal PyTorch Pipeline\u00b6","text":"<p>Finally, we combine both signals into a single high-performance <code>DataLoader</code>. Every sample is a tuple of <code>(Geometry, NMR)</code>.</p>"},{"location":"tutorials/neural_nmr_pipeline/#next-steps","title":"\ud83c\udfc6 Next Steps\u00b6","text":"<ol> <li>Predicting Reality: Try generating structures with <code>--conformation beta</code> and see how the CSI Plot flips! \ud83d\udcc9</li> <li>Transformer Training: Feed the <code>batch_nmr</code> tensor into a 1D Transformer to see if it can recover secondary structure labels.</li> </ol> <p>You are now generating the same type of data used to train the next generation of experimental AI solvers. The lab is yours. \ud83e\uddec\ud83e\udd16</p>"},{"location":"tutorials/orientogram_lab/","title":"\ud83d\udcd0 Geometry Factory: The trRosetta 6D Orientogram \u269b\ufe0f","text":"In\u00a0[\u00a0]: Copied! <pre># @title Setup &amp; Installation { display-mode: \"form\" }\nimport os\nimport sys\nfrom pathlib import Path\n\ntry:\n    current_path = Path(\".\").resolve()\n    repo_root = current_path.parent.parent \n    if (repo_root / \"synth_pdb\").exists():\n        if str(repo_root) not in sys.path:\n            sys.path.insert(0, str(repo_root))\n            print(f\"\ud83d\udccc Added local library to path: {repo_root}\")\nexcept Exception:\n    pass\n\nif 'google.colab' in str(get_ipython()):\n    if not os.path.exists(\"installed.marker\"):\n        print(\"Running on Google Colab. Installing dependencies...\")\n        get_ipython().run_line_magic('pip', 'install synth-pdb numpy matplotlib py3Dmol biotite')\n        \n        with open(\"installed.marker\", \"w\") as f:\n            f.write(\"done\")\n        \n        print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")\n        os.kill(os.getpid(), 9)\n    else:\n        print(\"\u2705 Dependencies Ready.\")\nelse:\n    import synth_pdb\n    print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\")\n</pre> # @title Setup &amp; Installation { display-mode: \"form\" } import os import sys from pathlib import Path  try:     current_path = Path(\".\").resolve()     repo_root = current_path.parent.parent      if (repo_root / \"synth_pdb\").exists():         if str(repo_root) not in sys.path:             sys.path.insert(0, str(repo_root))             print(f\"\ud83d\udccc Added local library to path: {repo_root}\") except Exception:     pass  if 'google.colab' in str(get_ipython()):     if not os.path.exists(\"installed.marker\"):         print(\"Running on Google Colab. Installing dependencies...\")         get_ipython().run_line_magic('pip', 'install synth-pdb numpy matplotlib py3Dmol biotite')                  with open(\"installed.marker\", \"w\") as f:             f.write(\"done\")                  print(\"\ud83d\udd04 Installation complete. KERNEL RESTARTING AUTOMATICALLY...\")         os.kill(os.getpid(), 9)     else:         print(\"\u2705 Dependencies Ready.\") else:     import synth_pdb     print(f\"\u2705 Running locally. Using synth-pdb version: {synth_pdb.__version__}\")  In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom synth_pdb.batch_generator import BatchedGenerator\nfrom synth_pdb.orientogram import compute_6d_orientations\n\nprint(\"Geometric kernels loaded. Ready to compute orientograms. \ud83d\udcd0\")\n</pre> import numpy as np import matplotlib.pyplot as plt from synth_pdb.batch_generator import BatchedGenerator from synth_pdb.orientogram import compute_6d_orientations  print(\"Geometric kernels loaded. Ready to compute orientograms. \ud83d\udcd0\")  In\u00a0[\u00a0]: Copied! <pre>sequence = \"ALA-VAL-LEU-ILE-SER-GLY-MET-TRP\" * 4 # 32 residues\ngenerator = BatchedGenerator(sequence, n_batch=1, full_atom=False) # Backbone only\nbatch = generator.generate_batch(conformation='beta') # Beta sheets have distinctive 6D signals\n\nprint(\"Structure Batch Generated.\")\nprint(\"Computing 6D Orientations...\")\n\norientations = batch.get_6d_orientations()\nprint(f\"Orientations computed for {batch.n_residues} residues.\")\nprint(f\"Tensors available: {list(orientations.keys())}\")\n</pre> sequence = \"ALA-VAL-LEU-ILE-SER-GLY-MET-TRP\" * 4 # 32 residues generator = BatchedGenerator(sequence, n_batch=1, full_atom=False) # Backbone only batch = generator.generate_batch(conformation='beta') # Beta sheets have distinctive 6D signals  print(\"Structure Batch Generated.\") print(\"Computing 6D Orientations...\")  orientations = batch.get_6d_orientations() print(f\"Orientations computed for {batch.n_residues} residues.\") print(f\"Tensors available: {list(orientations.keys())}\")  In\u00a0[\u00a0]: Copied! <pre>fig, axes = plt.subplots(2, 2, figsize=(12, 11))\nplt.subplots_adjust(hspace=0.3, wspace=0.2)\n\n# Using raw strings (r\"...\") to ensure Python 3.12 compatibility with LaTeX\ntitles = {\n    'dist': r'A. Distance Map (C-beta) ($d$) [$\\AA$]', \n    'omega': r'B. Omega Dihedral (Torsion) ($\\omega$) [$^\\circ$]',\n    'theta': r'C. Theta Angle (Plane) ($\\theta$) [$^\\circ$]',\n    'phi': r'D. Phi Dihedral (Polar) ($\\phi$) [$^\\circ$]'\n}\ncmaps = {'dist': 'viridis_r', 'omega': 'hsv', 'theta': 'magma', 'phi': 'twilight'}\n\nfor i, key in enumerate(['dist', 'omega', 'theta', 'phi']):\n    ax = axes[i // 2, i % 2]\n    data = orientations[key][0] # First batch member\n    \n    if key == 'dist':\n        im = ax.imshow(data, cmap=cmaps[key], vmax=15.0) # Cap distance for visual clarity\n    else:\n        # For periodic angles, clarify -180 to 180\n        # Angular values wrap from -180 to 180\n        im = ax.imshow(data, cmap=cmaps[key], vmin=-180, vmax=180)\n        \n    ax.set_title(titles[key], fontweight='bold')\n    fig.colorbar(im, ax=ax, shrink=0.8)\n\nplt.suptitle(\"The 6D Orientogram: A 'Computer Vision' View of Protein Structure\", fontsize=16, y=0.95)\nplt.show()\n</pre> fig, axes = plt.subplots(2, 2, figsize=(12, 11)) plt.subplots_adjust(hspace=0.3, wspace=0.2)  # Using raw strings (r\"...\") to ensure Python 3.12 compatibility with LaTeX titles = {     'dist': r'A. Distance Map (C-beta) ($d$) [$\\AA$]',      'omega': r'B. Omega Dihedral (Torsion) ($\\omega$) [$^\\circ$]',     'theta': r'C. Theta Angle (Plane) ($\\theta$) [$^\\circ$]',     'phi': r'D. Phi Dihedral (Polar) ($\\phi$) [$^\\circ$]' } cmaps = {'dist': 'viridis_r', 'omega': 'hsv', 'theta': 'magma', 'phi': 'twilight'}  for i, key in enumerate(['dist', 'omega', 'theta', 'phi']):     ax = axes[i // 2, i % 2]     data = orientations[key][0] # First batch member          if key == 'dist':         im = ax.imshow(data, cmap=cmaps[key], vmax=15.0) # Cap distance for visual clarity     else:         # For periodic angles, clarify -180 to 180         # Angular values wrap from -180 to 180         im = ax.imshow(data, cmap=cmaps[key], vmin=-180, vmax=180)              ax.set_title(titles[key], fontweight='bold')     fig.colorbar(im, ax=ax, shrink=0.8)  plt.suptitle(\"The 6D Orientogram: A 'Computer Vision' View of Protein Structure\", fontsize=16, y=0.95) plt.show() In\u00a0[\u00a0]: Copied! <pre>gly_res_idx = [i for i, r in enumerate(batch.sequence) if r == \"GLY\"]\nprint(f\"Analyzing Glycine at indices: {gly_res_idx}\")\n\n# Look at distance to neighboring residues for a GLY entry\nfor idx in gly_res_idx[:1]:\n    dist_row = orientations['dist'][0, idx, :]\n    print(f\"\\n\ud83d\udd0e Virtual C-beta mapping for GLY {idx+1}:\")\n    print(f\"Distances to neighbors: {dist_row[max(0, idx-2):min(idx+3, len(dist_row))]}\")\n    print(\"Note how the values are consistent with the rest of the chain!\")\nprint(\"\u2705 Virtual C-beta mapping successful.\")\n</pre> gly_res_idx = [i for i, r in enumerate(batch.sequence) if r == \"GLY\"] print(f\"Analyzing Glycine at indices: {gly_res_idx}\")  # Look at distance to neighboring residues for a GLY entry for idx in gly_res_idx[:1]:     dist_row = orientations['dist'][0, idx, :]     print(f\"\\n\ud83d\udd0e Virtual C-beta mapping for GLY {idx+1}:\")     print(f\"Distances to neighbors: {dist_row[max(0, idx-2):min(idx+3, len(dist_row))]}\")     print(\"Note how the values are consistent with the rest of the chain!\") print(\"\u2705 Virtual C-beta mapping successful.\")"},{"location":"tutorials/orientogram_lab/#geometry-factory-the-trrosetta-6d-orientogram","title":"\ud83d\udcd0 Geometry Factory: The trRosetta 6D Orientogram \u269b\ufe0f\u00b6","text":"<p>Objective: Understand the \"Inter-Residue Reference Frame\" and how we translate 3D protein folds into 6-dimensional mathematical signatures for AI training.</p>"},{"location":"tutorials/orientogram_lab/#why-1d-distances-arent-enough","title":"\ud83c\udf1f Why 1D distances aren't enough?\u00b6","text":""},{"location":"tutorials/orientogram_lab/#traditional-structural-models-like-early-gnns-often-relied-solely-on-distance-maps-while-helpful-distance-only-tells-you-how-close-two-points-areit-doesnt-tell-you-their-relative-twist-or-orientation","title":"Traditional structural models (like early GNNs) often relied solely on Distance Maps. While helpful, distance only tells you how close two points are\u2014it doesn't tell you their relative \"twist\" or orientation.\u00b6","text":""},{"location":"tutorials/orientogram_lab/#the-philosophy-from-distances-to-frames","title":"\ud83c\udf1f The Philosophy: From Distances to Frames\u00b6","text":"<p>The trRosetta (transform-restrained Rosetta) paper revolutionized AI structure prediction by providing 6D relative orientations between every pair of residues. This allows models to learn the complex 3D assembly of helices and sheets with much higher precision.Imagine trying to describe a dance to someone. If you only tell them the distance between the dancers' feet, they can't see the full performance. They don't know if the dancers are facing each other, looking away, or leaning in. They are missing the Orientations.</p> <p>In structural biology, residues (amino acids) are like those dancers.</p> <ol> <li>Early AI (Coarse-Grained): Used simple Distance Maps ($L \\times L$). They knew where the residues were, but not how they \"faced\" each other.</li> <li>Modern AI (Frame-Based): Uses 6D Orientations. Every residue is treated as a \"Rigid Body\" or local coordinate frame. By measuring the 6 relative values between every pair of residues, we capture the full 3D assembly with mathematical completeness.</li> </ol> <p>This notebook demonstrates how synth-pdb generates these advanced descriptors, which powered the breakthroughs in models like trRosetta and AlphaFold.</p>"},{"location":"tutorials/orientogram_lab/#1-defining-the-6d-descriptors","title":"1. Defining the 6D Descriptors\u00b6","text":"<p>For any two residues $i$ and $j$, we define the orientation of residue $j$ relative to $i$ using their $C\\alpha$ and $C\\beta$ positions (plus $N$ to fix the rotation). we calculate 4 primary tensors:</p> <p>We will generate a peptide with a mixed Alpha/Beta structure and analyze its geometric footprint.1. $d$ (Distance): The straight-line distance between $C\\beta_i$ and $C\\beta_j$. This is the foundation of the \"Contact Map\". 2. $\\\\omega$ (Omega): The dihedral (twist) angle $C\\alpha_i - C\\beta_i - C\\beta_j - C\\alpha_j$. It tells us how the backbones of the two residues are rotated relative to each other. 3. $\\\\theta$ (Theta): The plane angle $C\\alpha_i - C\\beta_i - C\\beta_j$. It describes how residue $i$ \"looks at\" residue $j$. 4. $\\\\phi$ (Phi): The polar dihedral $N_i - C\\alpha_i - C\\beta_i - C\\beta_j$. It anchors the orientation to the backbone's local coordinate system.</p> <p>Let's generate a Beta Sheet fold, where these angles are particularly well-defined and structured.</p>"},{"location":"tutorials/orientogram_lab/#2-visualizing-the-orientogram","title":"2. Visualizing the Orientogram\u00b6","text":"<p>Let's look at the 4 primary descriptors for our batch member 0:</p> <ol> <li>Distance ($d$): $C\\beta - C\\beta$ Euclidean distance.</li> <li>$\\\\omega$: Absolute rotation between frames.</li> <li>$\\\\theta$: Orientation angle.</li> <li>$\\\\phi$: Dihedral angle between frames. Below we plot the four tensors as $L \\times L$ heatmaps.</li> </ol> <p>Educational Insight: Note how the 6D tensors capture the diagonal structure of the fold differently than a simple distance map.### How to read these \"Images\":</p> <ul> <li>Symmetry: $d$ is symmetric ($dist_{i,j} = dist_{j,i}$), but the others might not be! $\\\\theta$ is specifically defined relative to the \"source\" residue $i$.</li> <li>Regularity: The dashed patterns you see are the hallmark of real protein physics. Beta sheets create rhythmic, staggered patterns in these maps because of the alternating \"up-down\" nature of the amino acid sidechains in a sheet.</li> <li>AI Readiness: For a Computer Vision model (like a CNN), these are 4 \"channels\" (like Red, Green, Blue) that describe the protein's essence perfectly.</li> </ul>"},{"location":"tutorials/orientogram_lab/#3-handling-the-invisible-residue-glycine","title":"3. Handling the \"Invisible\" Residue: Glycine\u00b6","text":"<p>In 6D geometry, you must have a $C\\beta$ atom to define the residue's orientation frame. But there's a problem: Glycine (GLY) has no $C\\beta$! Its sidechain is just a single Hydrogen atom.</p> <p>Glycine is the only amino acid without a side chain (just a Hydrogen). However, AI models require a consistent $C\\beta$ node for every residue to maintain a rigid frame.</p>"},{"location":"tutorials/orientogram_lab/#the-fix-virtual-reconstruction","title":"The Fix: Virtual Reconstruction\u00b6","text":"<p>AI models solve this by reconstructing a Virtual C-beta. Even though it's not physically there in Glycine, we can calculate where it would be if Glycine were an L-Alanine.</p> <p>synth-pdb automatically reconstructs the \"Ideal L-Alanine Position\" for any Glycine in your sequence, ensuring your tensors are compatible with model requirements.It uses the positions of $N, C\\alpha,$ and $C$ to \"project\" the virtual $C\\beta$ into space using ideal geometry. This ensures your data tensors are always contiguous and complete, even for highly flexible Glycine-rich loops.</p>"},{"location":"tutorials/orientogram_lab/#4-why-does-this-exist","title":"4. Why does this exist?\u00b6","text":"<p>This pipeline exists because Generating 3D Coordinates is HARD, but Generating 2D Tensors is FAST.</p> <ol> <li>Training AI: We generate millions of such tensors from synthetic PDBs. The AI learns the \"Language\" of these heatmaps.</li> <li>Prediction: When we give the AI a new sequence, it predicts these heatmaps.</li> <li>Recovery: We then use a process called \"Minimization\" or \"Folding\" to reconstruct the 3D structure that best fits those predicted 6D heatmaps.</li> </ol> <p>By providing these descriptors, synth-pdb allows you to bench-test the entire lifecycle of an AI model, from data production to descriptor analysis.</p>"},{"location":"tutorials/orientogram_lab/#experiment-for-the-user","title":"\ud83c\udfc6 Experiment for the User\u00b6","text":"<ol> <li>Ensemble Variance: Generate a batch with <code>drift=10.0</code> and plot the Standard Deviation of the distance maps. \ud83d\udcc9</li> <li>Feature Engineering: Standardize these tensors (e.g. <code>log(dist)</code>) to prepare them as direct inputs for a Convolutional Neural Network (CNN) classifier. Try generating structures with <code>conformation='alpha'</code> instead of <code>'beta'</code>.</li> </ol> <p>Predict: How will the distance map change? (Hint: Alpha helices stay closer to their immediate neighbors, creating a thick diagonal line!).</p> <p>You are now extracting the rich 3D information that powers modern structural AI. Happy building. \ud83d\udcd0\ud83e\udd16The structural signatures are yours to explore. \ud83e\uddec\ud83d\udcd0\ud83e\udd16</p>"}]}