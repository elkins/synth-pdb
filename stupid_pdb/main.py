"""
CLI entry point for the stupid-pdb tool.
"""

import argparse
import logging
import datetime
import os
import sys

from .generator import generate_pdb_content, get_current_date_pdb_format
from .validator import PDBValidator

# Get a logger for this module
logger = logging.getLogger(__name__)

def _get_atomic_content_from_full_pdb(full_pdb_content: str) -> str:
    """
    Extracts only ATOM, HETATM, and TER lines from a full PDB content string.
    """
    atomic_lines = []
    for line in full_pdb_content.splitlines():
        if line.startswith("ATOM") or line.startswith("HETATM") or line.startswith("TER"):
            atomic_lines.append(line)
    return "\n".join(atomic_lines)

def _add_pdb_header_and_footer(atomic_content: str, args, sequence_length: int) -> str:
    """
    Assembles the full PDB file content including header and footer records around atomic content.
    """
    header_lines = []
    current_date = get_current_date_pdb_format()
    
    header_lines.append(f"HEADER    PEPTIDE           {current_date}    ")
    header_lines.append(f"TITLE     GENERATED LINEAR PEPTIDE OF LENGTH {sequence_length}")
    header_lines.append("REMARK 1  This PDB file was generated by the CLI 'stupid-pdb' tool.")
    header_lines.append("REMARK 2  It represents a simplified model of a linear peptide chain.")
    header_lines.append("REMARK 2  Coordinates are idealized and do not reflect real-world physics.")
    
    # Add command-line arguments for reproducibility (REMARK 3)
    header_lines.append("REMARK 3  ")
    header_lines.append("REMARK 3  GENERATION PARAMETERS:")
    
    # Build the command-line string
    cmd_parts = ["stupid-pdb"]
    if args.sequence:
        cmd_parts.append(f"--sequence {args.sequence}")
    else:
        cmd_parts.append(f"--length {args.length}")
    
    if args.plausible_frequencies:
        cmd_parts.append("--plausible-frequencies")
    if args.validate:
        cmd_parts.append("--validate")
    if args.guarantee_valid:
        cmd_parts.append("--guarantee-valid")
        cmd_parts.append(f"--max-attempts {args.max_attempts}")
    if args.best_of_N > 1:
        cmd_parts.append(f"--best-of-N {args.best_of_N}")
    if args.refine_clashes > 0:
        cmd_parts.append(f"--refine-clashes {args.refine_clashes}")
    if args.output:
        cmd_parts.append(f"--output {args.output}")
    
    cmd_string = " ".join(cmd_parts)
    
    # Split command into multiple lines if needed (PDB REMARK lines are max 80 chars)
    # Format: "REMARK 3  " = 10 chars, leaving 70 chars for content
    if len(cmd_string) <= 68:  # 10 + 68 = 78, leaving some margin
        header_lines.append(f"REMARK 3  Command: {cmd_string}")
    else:
        # Split into multiple lines
        header_lines.append("REMARK 3  Command:")
        # Wrap at 68 characters per line
        for i in range(0, len(cmd_string), 68):
            chunk = cmd_string[i:i+68]
            header_lines.append(f"REMARK 3    {chunk}")
    
    header_lines.append("REMARK 3  ")
    
    header_lines.append(f"COMPND    MOL_ID: 1; MOLECULE: LINEAR PEPTIDE; CHAIN: A; LENGTH: {sequence_length};")
    header_lines.append("SOURCE    ENGINEERED; SYNTHETIC CONSTRUCT;")
    header_lines.append("KEYWDS    PEPTIDE, LINEAR, GENERATED, THEORETICAL MODEL")
    header_lines.append("EXPDTA    THEORETICAL MODEL")
    header_lines.append("AUTHOR    STUPID PDB")
    header_lines.append("MODEL        1")

    footer_lines = [
        "ENDMDL",
        "END         ", # 10 spaces to match typical PDB END record length
    ]

    return "\n".join(header_lines) + "\n" + atomic_content.strip() + "\n" + "\n".join(footer_lines)


def main():
    """
    Main function to parse arguments and generate the PDB file.
    """
    parser = argparse.ArgumentParser(
        description="Generate a PDB file with a random linear amino acid sequence."
    )
    parser.add_argument(
        "--length",
        type=int,
        default=10,
        help="Length of the amino acid sequence (number of residues).",
    )
    parser.add_argument(
        "--output",
        type=str,
        help="Optional: Output PDB filename. If not provided, a default name will be generated.",
    )
    parser.add_argument(
        "--log-level",
        type=str,
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).",
    )

    parser.add_argument(
        "--sequence",
        type=str,
        help="Specify an amino acid sequence (e.g., 'AGV' or 'ALA-GLY-VAL'). Overrides random generation.",
    )
    parser.add_argument(
        "--plausible-frequencies",
        action="store_true",
        help="Use biologically plausible amino acid frequencies for random sequence generation (ignored if --sequence is provided).",
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="Run validation checks (bond lengths and angles, Ramachandran) on the generated PDB.",
    )
    parser.add_argument(
        "--guarantee-valid",
        action="store_true",
        help="If set, repeatedly generate PDB files until a valid one (no violations) is produced. Implies --validate. Will stop after --max-attempts if no valid PDB is found.",
    )
    parser.add_argument(
        "--max-attempts",
        type=int,
        default=100,
        help="Maximum number of regeneration attempts when --guarantee-valid is set.",
    )
    parser.add_argument(
        "--best-of-N",
        type=int,
        default=1,
        help="Generate N PDBs, validate each, and select the one with the fewest violations. Implies --validate. Overrides --guarantee-valid.",
    )
    parser.add_argument(
        "--refine-clashes",
        type=int,
        default=0, # Default to 0, meaning no refinement
        help="Number of iterations to refine generated PDB by minimally adjusting clashing atoms. Implies --validate. Applied after --guarantee-valid or --best-of-N selection.",
    )


    args = parser.parse_args()

    # Set the logging level based on user input
    log_level = getattr(logging, args.log_level.upper(), None)
    if not isinstance(log_level, int):
        raise ValueError(f"Invalid log level: {args.log_level}")
    logging.getLogger().setLevel(log_level)
    logger.debug("Logging level set to %s.", args.log_level.upper())
    
    logger.info("Starting PDB file generation process.")
    logger.debug(
        "Parsed arguments: length=%s, output='%s', sequence='%s', plausible_frequencies=%s, validate=%s",
        args.length,
        args.output,
        args.sequence,
        args.plausible_frequencies,
        args.validate,
    )

    # If --best-of-N is set, it overrides --guarantee-valid and implies --validate.
    if args.best_of_N > 1:
        args.validate = True
        args.guarantee_valid = False # Disable guarantee-valid if best-of-N is used
        logger.info(f"--best-of-N is set to {args.best_of_N}. Generating multiple PDBs to find the one with fewest violations.")
    elif args.guarantee_valid: # Only apply if best-of-N is not active
        args.validate = True
        logger.info("--guarantee-valid is set. Will attempt to generate a valid PDB.")
    
    if args.refine_clashes > 0:
        args.validate = True # Refinement implies validation during initial generation
        logger.info(f"--refine-clashes is set to {args.refine_clashes}. Validation will be performed.")

    # Validate length only if no sequence is provided
    if args.sequence is None and (args.length is None or args.length <= 0):
        logger.error("Length must be a positive integer when no sequence is provided.")
        sys.exit(1)

    length_for_generator = args.length if args.sequence is None else None

    final_pdb_content = None
    final_violations = None
    min_violations_count = float('inf')

    generation_attempts = 1 if not args.guarantee_valid and args.best_of_N <= 1 else args.max_attempts
    if args.best_of_N > 1:
        generation_attempts = args.best_of_N

    for attempt_num in range(1, generation_attempts + 1):
        logger.info(f"Generation attempt {attempt_num}/{generation_attempts}.")
        current_pdb_content = None
        current_violations = []

        try:
            current_pdb_content = generate_pdb_content(
                length=length_for_generator,
                sequence_str=args.sequence,
                use_plausible_frequencies=args.plausible_frequencies,
            )

            if not current_pdb_content:
                logger.warning(f"Failed to generate PDB content in attempt {attempt_num}. Skipping.")
                continue

            if args.validate:
                logger.info("Performing PDB validation checks for current generation...")
                logger.debug(f"PDB content passed to validator (attempt {attempt_num}):\n{current_pdb_content}")
                validator = PDBValidator(current_pdb_content)
                validator.validate_bond_lengths()
                validator.validate_bond_angles()
                validator.validate_ramachandran()
                validator.validate_steric_clashes()
                validator.validate_peptide_plane()
                validator.validate_sequence_improbabilities()
                current_violations = validator.get_violations()
                logger.debug(f"PDBValidator returned {len(current_violations)} violations for attempt {attempt_num}. Content: {current_violations}")
            
            if args.guarantee_valid:
                if not current_violations:
                    logger.info(f"Successfully generated a valid PDB file after {attempt_num} attempts.")
                    final_pdb_content = current_pdb_content
                    final_violations = current_violations
                    break # Exit loop, valid PDB found
                else:
                    logger.warning(f"PDB generated in attempt {attempt_num} has {len(current_violations)} violations. Retrying...")
                    if logger.isEnabledFor(logging.DEBUG):
                        logger.debug("--- PDB Validation Report for failed attempt ---")
                        for violation in current_violations:
                            logger.debug(violation)
                        logger.debug("--- End Validation Report ---")
            elif args.best_of_N > 1:
                if len(current_violations) < min_violations_count:
                    min_violations_count = len(current_violations)
                    final_pdb_content = current_pdb_content
                    final_violations = current_violations
                    logger.info(f"Attempt {attempt_num} yielded {len(current_violations)} violations (new minimum).")
                else:
                    logger.info(f"Attempt {attempt_num} yielded {len(current_violations)} violations. Current minimum is {min_violations_count}.")
            else: # No guarantee-valid or best-of-N, just take the first one
                final_pdb_content = current_pdb_content
                final_violations = current_violations
                break

        except ValueError as ve:
            logger.error(f"Error processing sequence during generation (attempt {attempt_num}): {ve}. Skipping.")
        except Exception as e:
            logger.error(f"An unexpected error occurred during generation (attempt {attempt_num}): {e}. Skipping.")

    if final_pdb_content is None:
        logger.error(f"Failed to generate a suitable PDB file after {generation_attempts} attempts.")
        sys.exit(1)
    else:
        # Extract atomic content from the initially selected PDB for subsequent refinement or final assembly.
        final_pdb_atomic_content = _get_atomic_content_from_full_pdb(final_pdb_content)

        # Apply refinement if requested
        if args.refine_clashes > 0:
            args.validate = True # Refinement implies validation
            logger.info(f"Starting steric clash refinement for {args.refine_clashes} iterations.")
            
            # current_refined_atomic_content will hold only ATOM/TER lines
            current_refined_atomic_content = final_pdb_atomic_content
            current_refined_violations = final_violations
            initial_violations_count = len(final_violations)

            for refine_iter in range(args.refine_clashes):
                logger.info(f"Refinement iteration {refine_iter + 1}/{args.refine_clashes}. Violations: {len(current_refined_violations)}")
                if not current_refined_violations:
                    logger.info("No violations remain, stopping refinement early.")
                    break

                # Parse atoms from current atomic PDB content
                # PDBValidator._parse_pdb_atoms can work directly on atomic lines.
                parsed_atoms_for_refinement = PDBValidator._parse_pdb_atoms(current_refined_atomic_content)
                
                # Apply steric clash tweak
                modified_atoms = PDBValidator._apply_steric_clash_tweak(parsed_atoms_for_refinement)

                # Convert modified atoms back to atomic PDB content (no header/footer)
                new_atomic_content_after_tweak = PDBValidator.atoms_to_pdb_content(modified_atoms)

                # Re-validate the tweaked atomic PDB content.
                # For validation, PDBValidator expects a full PDB string.
                # So, we'll temporarily add a minimal header/footer for validation.
                # We can use a dummy sequence_length as it's just for validation init.
                temp_validator = PDBValidator(
                    pdb_content=_add_pdb_header_and_footer(new_atomic_content_after_tweak, args, 1)
                )
                temp_validator.validate_bond_lengths()
                temp_validator.validate_bond_angles()
                temp_validator.validate_ramachandran()
                temp_validator.validate_steric_clashes()
                temp_validator.validate_peptide_plane()
                temp_validator.validate_sequence_improbabilities()
                new_violations = temp_validator.get_violations()

                if len(new_violations) < len(current_refined_violations):
                    logger.info(f"Refinement iteration {refine_iter + 1}: Reduced violations from {len(current_refined_violations)} to {len(new_violations)}.")
                    current_refined_atomic_content = new_atomic_content_after_tweak
                    current_refined_violations = new_violations
                else:
                    logger.info(f"Refinement iteration {refine_iter + 1}: No further reduction in violations ({len(new_violations)}). Stopping refinement.")
                    break # No improvement, stop refinement

            final_pdb_atomic_content = current_refined_atomic_content # This is now atomic-only
            final_violations = current_refined_violations
            if initial_violations_count > len(final_violations):
                logger.info(f"Refinement process completed. Reduced total violations from {initial_violations_count} to {len(final_violations)}.")
            elif initial_violations_count == len(final_violations):
                logger.info(f"Refinement process completed. No change in total violations ({len(final_violations)}).")
            else: # Should not happen if logic is correct, but for completeness
                logger.warning(f"Refinement process completed. Violations increased from {initial_violations_count} to {len(final_violations)}. This indicates an issue with the refinement logic.")
        # If no refinement was requested, final_pdb_atomic_content was already set from the initial extraction.

        # After successful generation (and optional validation)
        # Only proceed to file writing if final_pdb_atomic_content is not None
        if final_pdb_atomic_content is not None:
            # Determine the sequence length for the final header, especially if it was inferred from sequence string.
            final_sequence_length = args.length
            if args.sequence:
                final_sequence_length = len(args.sequence.replace("-", ""))
            elif args.length is None:
                # Infer length from the atomic content if not explicitly set
                # Temporarily create a PDBValidator with minimal header to get sequence length
                temp_full_pdb_for_length_inference = _add_pdb_header_and_footer(final_pdb_atomic_content, args, 1) # Dummy length 1
                temp_validator_for_length = PDBValidator(pdb_content=temp_full_pdb_for_length_inference)
                # Assuming a single chain 'A' for simplicity, as per current generator
                inferred_sequence = temp_validator_for_length._get_sequences_by_chain().get('A', [])
                final_sequence_length = len(inferred_sequence) if inferred_sequence else "VARIABLE"


            # Assemble the full PDB content with header and footer
            final_full_pdb_content_to_write = _add_pdb_header_and_footer(
                final_pdb_atomic_content, args, final_sequence_length
            )

            if args.output:
                output_filename = args.output
                logger.debug("Using user-provided output filename: %s", output_filename)
            else:
                timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                if args.sequence:
                    # Use a simplified sequence string for filename to avoid very long names
                    sequence_tag = args.sequence.replace("-", "")[
                        :10
                    ]  # Take first 10 chars, remove hyphens
                    output_filename = f"custom_peptide_{sequence_tag}_{timestamp}.pdb"
                else:
                    output_filename = f"random_linear_peptide_{args.length}_{timestamp}.pdb"
                logger.debug("Generated default output filename: %s", output_filename)

            try:
                with open(output_filename, "w") as f:
                    f.write(final_full_pdb_content_to_write)
                logger.info(
                    "Successfully generated PDB file: %s", os.path.abspath(output_filename)
                )

                # Print final validation report
                if final_violations:
                    logger.warning(f"--- PDB Validation Report for {os.path.abspath(output_filename)} ---")
                    logger.warning(f"Final PDB has {len(final_violations)} violations.")
                    for violation in final_violations:
                        logger.warning(violation)
                    logger.warning("--- End Validation Report ---")
                elif args.validate:
                    logger.info(f"No violations found in the final PDB for {os.path.abspath(output_filename)}.")

            except Exception as e:
                logger.error("An unexpected error occurred during file writing: %s", e)
                sys.exit(1)
        else:
            # If final_pdb_atomic_content is None (implies final_pdb_content was None originally)
            logger.error("No suitable PDB content was generated for writing.")
            sys.exit(1)


if __name__ == "__main__":
    main()
